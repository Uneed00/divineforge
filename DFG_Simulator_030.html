<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Divine Forge: Balance Simulator (Integrated)</title>
    <style>
    :root {
        --bg-color: #121212;
        --panel-color: #1e1e1e;
        --border-color: #333;
        --accent-color: #3498db;
        --text-main: #ecf0f1;
        --text-sub: #95a5a6;
        
        --c-olympus: #3498db;
        --c-egypt: #f1c40f;
        --c-nord: #9b59b6;
        --c-celt: #2ecc71;
    }

    body { font-family: 'Segoe UI', 'Roboto', monospace; background: var(--bg-color); color: var(--text-main); padding: 20px; margin: 0; line-height: 1.5; }
    h1, h2, h3 { color: var(--text-main); margin: 0 0 10px 0; font-weight: 600; }
    
    /* Layout */
    .control-panel { background: var(--panel-color); border: 1px solid var(--border-color); padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
    .control-group { margin-bottom: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    
    /* Inputs & Buttons */
    select, input { background: #2c3e50; border: 1px solid #444; color: white; padding: 6px 10px; border-radius: 4px; }
    button { padding: 8px 16px; border-radius: 4px; border: none; cursor: pointer; font-weight: bold; transition: 0.2s; }
    button:hover { opacity: 0.9; transform: translateY(-1px); }
    .btn-primary { background: var(--accent-color); color: white; }
    .btn-danger { background: #e74c3c; color: white; }
    .btn-warning { background: #e67e22; color: white; }

    /* Dashboard Grid */
    .dashboard-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 4ì—´ ê·¸ë¦¬ë“œ */
        gap: 15px;
        margin-top: 20px;
    }
    .panel {
        background: var(--panel-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
    }
    .panel.full-width { grid-column: span 4; }
    .panel.half-width { grid-column: span 2; }
    
    .panel-header {
        font-size: 14px;
        color: var(--text-sub);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
        border-bottom: 1px solid #333;
        padding-bottom: 5px;
        display: flex;
        justify-content: space-between;
    }

    /* Visual Elements */
    .stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 13px; }
    .stat-label { color: var(--text-sub); flex: 1; }
    .stat-value { font-weight: bold; color: var(--text-main); text-align: right; }
    
    .bar-wrapper { flex: 2; height: 8px; background: #333; border-radius: 4px; margin: 0 10px; overflow: hidden; position: relative; }
    .bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s ease; }
    
    .mini-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .mini-table th { text-align: left; color: var(--text-sub); padding: 4px; border-bottom: 1px solid #444; }
    .mini-table td { padding: 4px; border-bottom: 1px solid #333; }
    .mini-table tr:last-child td { border-bottom: none; }

    /* Colors */
    .c-olympus { color: var(--c-olympus); }
    .c-egypt { color: var(--c-egypt); }
    .c-nord { color: var(--c-nord); }
    .c-celt { color: var(--c-celt); }
    
    .log-area { height: 150px; overflow-y: auto; background: #000; border: 1px solid #333; padding: 10px; font-size: 11px; color: #aaa; font-family: monospace; margin-bottom: 10px; }
    
    #progressBar { height: 4px; background: #2ecc71; width: 0%; transition: width 0.2s; }
</style>
</head>
<body>

    <h1>âš–ï¸ Divine Forge Simulator v9.1 (Fixed)</h1>

    
       <div class="control-panel">
    <div class="control-group">
        <label>ì‹œë®¬ë ˆì´ì…˜ íšŸìˆ˜:</label>
        <select id="simCount">
            <option value="100">100íšŒ</option>
            <option value="1000">1,000íšŒ</option>
            <option value="10000" selected>10,000íšŒ</option>
        </select>
        <button onclick="simManager.startSimulation()">â–¶ ì¶”ê°€ ì‹¤í–‰ (ëˆ„ì )</button>
        <button class="stop-btn" onclick="simManager.stopSimulation()">â¹ ì¤‘ì§€</button>
        
        <div style="width: 20px;"></div> <button onclick="simManager.resetStats()" style="background: #e67e22;">ğŸ”„ í†µê³„ ì´ˆê¸°í™”</button>
    </div>
    
    <div class="control-group">
        <span>ì‹ í™” ë°°ì •(P1~P4):</span>
        <select id="p1Myth">
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p2Myth">
            <option value="egypt" selected>ì´ì§‘íŠ¸</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p3Myth">
            <option value="nord" selected>ë…¸ë¥´ë“œ</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p4Myth">
            <option value="celt" selected>ì¼ˆíŠ¸</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
        </select>
    </div>

    <details style="margin-top: 15px; background: #2c3e50; padding: 10px; border-radius: 4px; border: 1px solid #444;">
        <summary style="cursor: pointer; font-weight: bold; color: #ecf0f1;">âš™ï¸ ë°¸ëŸ°ìŠ¤ íŒŒë¼ë¯¸í„° ë¯¸ì„¸ ì¡°ì • (í´ë¦­í•˜ì—¬ ì—´ê¸°)</summary>
        
        <div class="control-group" style="margin-top: 10px; padding: 10px; border: 1px solid #2ecc71; border-radius: 4px; background: #1a252f; flex-direction: column; align-items: flex-start;">
    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
        <span style="color: #2ecc71; font-weight: bold;">â˜˜ï¸ ì¼ˆíŠ¸ ëŠ¥ë ¥ ì»¤ìŠ¤í…€ (Advanced)</span>
        <label style="font-size: 11px; color: #aaa; cursor: pointer;">
            <input type="checkbox" id="celtMimicToggle" checked> ë¯¸ë¯¹(3ë‹¨ê³„) í™œì„±
        </label>
    </div>

    <div style="width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <div>
            <label style="font-size: 11px; display:block; color: #ddd;">êµí™˜ íšŸìˆ˜ (0~3ë‹¨ê³„):</label>
            <input type="text" id="conf_celt_swap" value="0,1,2,3" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #555; color: white; padding: 4px;">
        </div>
        <div>
            <label style="font-size: 11px; display:block; color: #ddd;">ë³€í™˜(Any) ë°œë™ ë ˆë²¨:</label>
            <input type="text" id="conf_celt_lvl_convert" value="2" placeholder="ì˜ˆ: 2 (2ë‹¨ê³„ ì´ìƒ ë°œë™)" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #27ae60; color: white; padding: 4px;">
        </div>
        <div style="grid-column: span 2;">
            <label style="font-size: 11px; display:block; color: #ddd;">ë©´ì œ(Free) ë°œë™ ë ˆë²¨:</label>
            <input type="text" id="conf_celt_lvl_free" value="3" placeholder="ì˜ˆ: 3 (3ë‹¨ê³„ ì´ìƒ ë°œë™)" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #27ae60; color: white; padding: 4px;">
        </div>
    </div>
    <div style="font-size: 10px; color: #7f8c8d; margin-top: 5px;">
        * ë³€í™˜/ë©´ì œ: ì…ë ¥í•œ <b>ë ˆë²¨ ì´ìƒ(â‰¥)</b>ì¼ ë•Œ ëŠ¥ë ¥ì´ í™œì„±í™”ë©ë‹ˆë‹¤. (ìˆ«ì 1ê°œë§Œ ì…ë ¥)
    </div>
</div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
            <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #00bfff;">â˜ï¸ ì˜¬ë¦¼í¬ìŠ¤ (ì¬ë£Œ í• ì¸)</h3>
                <label style="font-size: 11px;">ë‹¨ê³„ë³„ í• ì¸ëŸ‰ (0,1,2,3ë‹¨ê³„):</label>
                <input type="text" id="conf_olympus_discount" value="0,2,5,12" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
            </div>

            <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #9b59b6;">â„ï¸ ë…¸ë¥´ë“œ (ìˆ˜ì§‘ ê°•í™”)</h3>
                <label style="font-size: 11px;">í•©ê³„ ì œí•œ (1,2,3ë‹¨ê³„):</label>
                <input type="text" id="conf_nord_sum" value="6,9,14" style="width: 100%; box-sizing: border-box; margin-bottom: 5px; background: #222; border: 1px solid #555; color: white;">
                <label style="font-size: 11px;">ì¥ìˆ˜ ì œí•œ (1,2,3ë‹¨ê³„):</label>
                <input type="text" id="conf_nord_count" value="2,2,3" style="width: 100%; box-sizing: border-box; margin-bottom: 5px; background: #222; border: 1px solid #555; color: white;">
                <label style="font-size: 11px;">ìˆ˜ì§‘ ì†ë„(í„´ìˆ˜ ê³„ì‚°ìš©):</label>
                <input type="text" id="conf_nord_speed" value="3.5,7.0,7.0,10.5" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
            </div>
            
            <div style="background: #34495e; padding: 10px; border-radius: 4px; grid-column: span 2; border: 1px dashed #f1c40f;">
                <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #f1c40f;">ğŸ‘ï¸ ì´ì§‘íŠ¸ (í–‰ë™ ë¹„ìš© ê°ì†Œ ìƒì„¸ ì„¤ì •)</h3>
                <table style="width: 100%; font-size: 11px; border-collapse: collapse; color: #eee;">
                    <tr style="border-bottom: 1px solid #555;">
                        <th style="text-align: left; padding: 4px; color: #aaa;">Level</th>
                        <th style="padding: 4px;">ì˜ˆì•½(Reserve)</th>
                        <th style="padding: 4px;">ìì›(Res)</th>
                        <th style="padding: 4px;">ì¶•ë³µ(Bless)</th>
                        <th style="padding: 4px;">ì œì‘(Craft)</th>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV1</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_r" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV2</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_res" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV3</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_bls" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_art" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                </table>
                <div style="font-size: 11px; color: #aaa; margin-top: 5px; text-align: right;">* ê° ë ˆë²¨ ë„ë‹¬ ì‹œ í•´ë‹¹ ìˆ˜ì¹˜ë§Œí¼ ë¹„ìš©ì´ <b>ì¶”ê°€ë¡œ</b> ê°ì†Œí•©ë‹ˆë‹¤.</div>
            </div>
        </div>
        
        <div style="margin-top: 10px; text-align: right; font-size: 11px; color: #95a5a6;">
        </div>
    </details>
    <div id="progressBar" style="width:0%; height:4px; background:#2ecc71; transition:width 0.2s; margin-top: 10px;"></div>
</div>
<div class="log-area" id="simLog" style="margin-bottom: 20px;">
        [System] ì¤€ë¹„ ì™„ë£Œ. ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•˜ë ¤ë©´ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.
    </div>

    <div id="mainStats" style="font-size: 24px; font-weight: bold; color: #f1c40f; margin-bottom: 10px;"></div>
    <div id="detailStats"></div>
<script>
// ==================================================================================
// [Part 1] Configuration & Databases (002 Ver. Integrated)
// ==================================================================================

const CONFIG = {
    MAX_TIME: 12,
    MAX_DAYS: 5,
    HAND_LIMIT: 8,
    COST: { RES: 3, BLESS: 2, ART: 2, RESERVE: 1, SWAP: 1 }
};

// 002 ë²„ì „ì˜ ë°¸ëŸ°ìŠ¤ ì»¨í”¼ê·¸ ì ìš©
// [Part 1] Config & Apply Function (ê¸°ì¡´ BALANCE_CONFIG, applyUserBalance ì§€ìš°ê³  ëŒ€ì²´)
// [Part 1] Config & Apply Function (ìˆ˜ì •ë¨)
const BALANCE_CONFIG = {
    EGYPT: [
        { RESERVE: 1, RES: 0, BLESS: 0, ART: 0 },
        { RESERVE: 0, RES: 1, BLESS: 0, ART: 0 },
        { RESERVE: 0, RES: 0, BLESS: 1, ART: 1 }
    ],
    NORD: { LIMIT_SUM: [6, 9, 14], LIMIT_COUNT: [2, 2, 3], GATHER_SPEED: [3.5, 7.0, 7.0, 10.5] },
    OLYMPUS: { DISCOUNT: [0, 2, 5, 12] },
    CELT: { 
        SWAP_LIMIT: [0, 1, 2, 3],
        LVL_CONVERT: 2, // [ë³€ê²½] ë°°ì—´ ëŒ€ì‹  ìˆ«ì(ìµœì†Œ ë ˆë²¨)ë¡œ ê´€ë¦¬
        LVL_FREE: 3     // [ë³€ê²½] ë°°ì—´ ëŒ€ì‹  ìˆ«ì(ìµœì†Œ ë ˆë²¨)ë¡œ ê´€ë¦¬
    }
};

function applyUserBalance() {
    try {
        const getElVal = (id) => { const el = document.getElementById(id); return el && el.value.trim() !== "" ? (parseInt(el.value) || 0) : 0; };
        const getArrVal = (id) => { const el = document.getElementById(id); return el && el.value.trim() !== "" ? el.value.split(',').map(v => Number(v.trim())).filter(n => !isNaN(n)) : []; };

        const mimicToggle = document.getElementById('celtMimicToggle');
        BALANCE_CONFIG.CELT.MIMIC_ENABLED = mimicToggle ? mimicToggle.checked : true;

        const olympusVal = getArrVal('conf_olympus_discount');
        if (olympusVal.length > 0) BALANCE_CONFIG.OLYMPUS.DISCOUNT = olympusVal;
        
        BALANCE_CONFIG.EGYPT = [
            { RESERVE: getElVal('conf_egypt_l1_r'), RES: getElVal('conf_egypt_l1_res'), BLESS: getElVal('conf_egypt_l1_bls'), ART: getElVal('conf_egypt_l1_art') },
            { RESERVE: getElVal('conf_egypt_l2_r'), RES: getElVal('conf_egypt_l2_res'), BLESS: getElVal('conf_egypt_l2_bls'), ART: getElVal('conf_egypt_l2_art') },
            { RESERVE: getElVal('conf_egypt_l3_r'), RES: getElVal('conf_egypt_l3_res'), BLESS: getElVal('conf_egypt_l3_bls'), ART: getElVal('conf_egypt_l3_art') }
        ];

        const nordSum = getArrVal('conf_nord_sum'); if (nordSum.length > 0) BALANCE_CONFIG.NORD.LIMIT_SUM = nordSum;
        const nordCount = getArrVal('conf_nord_count'); if (nordCount.length > 0) BALANCE_CONFIG.NORD.LIMIT_COUNT = nordCount;
        const nordSpeed = getArrVal('conf_nord_speed'); if (nordSpeed.length > 0) BALANCE_CONFIG.NORD.GATHER_SPEED = nordSpeed;

        const celtSwap = getArrVal('conf_celt_swap'); if (celtSwap.length > 0) BALANCE_CONFIG.CELT.SWAP_LIMIT = celtSwap;
        
        // [Logic Change] ë°°ì—´ì˜ ì²« ë²ˆì§¸ ê°’ì„ ìµœì†Œ ë ˆë²¨(Threshold)ë¡œ ì‚¬ìš©
        const convertArr = getArrVal('conf_celt_lvl_convert');
        BALANCE_CONFIG.CELT.LVL_CONVERT = convertArr.length > 0 ? convertArr[0] : 999; 
        
        const freeArr = getArrVal('conf_celt_lvl_free');
        BALANCE_CONFIG.CELT.LVL_FREE = freeArr.length > 0 ? freeArr[0] : 999;

        console.log("[System] Balance Applied (Logic: Threshold >=).");
    } catch (e) { console.error("Balance Apply Error:", e); }
}
const START_RULE = [
    { res: 0, bless: 0, loki: 0, score: 0 }, // P1
    { res: 0, bless: 0, loki: 0, score: 0 }, // P2
    { res: 0, bless: 0, loki: 0, score: 0 }, // P3
    { res: 0, bless: 0, loki: 0, score: 0 }  // P4
];

const RES_NAMES = { adamantite: "ì•„ë‹¤ë§Œíƒ€ì´íŠ¸", mithril: "ë¯¸ìŠ¤ë¦´", dragonBone: "ìš©ì˜ ë¼ˆ", starFragment: "ë³„ì˜ íŒŒí¸" };
const TYPE_NAMES = { nord: "ë…¸ë¥´ë“œ", egypt: "ì´ì§‘íŠ¸", olympus: "ì˜¬ë¦¼í¬ìŠ¤", celt: "ì¼ˆíŠ¸" };

// 002 ë²„ì „ì˜ ìœ ë¬¼ ë°ì´í„°ë² ì´ìŠ¤ (ê·¸ëŒ€ë¡œ ìœ ì§€)
const ARTIFACT_DB = [
    // Olympus (Bronze)
    {name:"ê·€ê²ŒìŠ¤ì˜ ë°˜ì§€", type:"olympus", score:4, grade:"Bronze", cost:{adamantite:3, starFragment:3}},
    {name:"í—¤ë¥´ë©”ìŠ¤ì˜ ì‹ ë°œ", type:"olympus", score:5, grade:"Bronze", cost:{dragonBone:3, mithril:4}},
    {name:"í¬ë¦¬ì…€ë¼ì¹´í† ìŠ¤", type:"olympus", score:6, grade:"Bronze", cost:{mithril:3, starFragment:5}},
    // Olympus (Silver)
    {name:"í€´ë„¤ì—", type:"olympus", score:10, grade:"Silver", cost:{dragonBone:2, mithril:4, starFragment:5}},
    {name:"ì¼€ìŠ¤í† ìŠ¤ íˆë§ˆìŠ¤", type:"olympus", score:12, grade:"Silver", cost:{adamantite:4, starFragment:9}},
    {name:"íŠ¸ë¼ì•„ì´ë‚˜", type:"olympus", score:12, grade:"Silver", cost:{adamantite:2, dragonBone:7, mithril:3}},
    {name:"ì•„í´ë¡ ì˜ ë¦¬ë¼", type:"olympus", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:3, starFragment:6}},
    {name:"ì•„ì´ê¸°ìŠ¤", type:"olympus", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:8}},
    {name:"íí”¼ë“œì˜ í™”ì‚´", type:"olympus", score:16, grade:"Silver", cost:{adamantite:5, dragonBone:3, mithril:7, starFragment:2}},
    {name:"ì•„ë‹¤ë§ŒíŠ¸", type:"olympus", score:16, grade:"Silver", cost:{adamantite:12, dragonBone:2, starFragment:3}},
    // Olympus (Gold)
    {name:"ì•„ìŠ¤íŠ¸ë¼í˜", type:"olympus", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:5, mithril:5, starFragment:12}},

    // Egypt (Bronze)
    {name:"ë§ˆì•„íŠ¸ì˜ ê¹ƒí„¸", type:"egypt", score:4, grade:"Bronze", cost:{dragonBone:3, mithril:3}},
    {name:"ì˜¤ì‹œë¦¬ìŠ¤ì˜ ì™•í™€", type:"egypt", score:5, grade:"Bronze", cost:{adamantite:2, mithril:6}},
    {name:"ì•„ëˆ„ë¹„ìŠ¤ì˜ ì €ìš¸", type:"egypt", score:6, grade:"Bronze", cost:{adamantite:2, dragonBone:6}},
    // Egypt (Silver)
    {name:"ì„¸íŠ¸ì˜ ì „ìŸ ë„ë¼", type:"egypt", score:10, grade:"Silver", cost:{adamantite:6, dragonBone:2, mithril:2}},
    {name:"ì„¸í¬ë©”íŠ¸ì˜ ì—­ë³‘", type:"egypt", score:12, grade:"Silver", cost:{adamantite:3, dragonBone:6, mithril:3}},
    {name:"í† íŠ¸ì˜ ì„œ", type:"egypt", score:12, grade:"Silver", cost:{dragonBone:2, mithril:6, starFragment:5}},
    {name:"ì•„í©ì˜ ì´ë¹¨", type:"egypt", score:14, grade:"Silver", cost:{dragonBone:7, mithril:6, starFragment:2}},
    {name:"í˜¸ë£¨ìŠ¤ì˜ ëˆˆ", type:"egypt", score:14, grade:"Silver", cost:{adamantite:4, mithril:6, starFragment:5}},
    {name:"í¬ëˆ”ì˜ ë¬¼ë ˆ", type:"egypt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:2, starFragment:5}},
    {name:"ë§Œì•¼ë¥´íŠ¸", type:"egypt", score:16, grade:"Silver", cost:{dragonBone:5, mithril:4, starFragment:8}},
    // Egypt (Gold)
    {name:"ëˆ„ì˜ í•­ì•„ë¦¬", type:"egypt", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:14, mithril:2, starFragment:6}},

    // Nord (Bronze)
    {name:"ë“œë¼ìš°í”„ë‹ˆë¥´", type:"nord", score:4, grade:"Bronze", cost:{dragonBone:4, mithril:2}},
    {name:"ë¸Œë¦¬ì‹±ê°€ë©˜", type:"nord", score:5, grade:"Bronze", cost:{mithril:3, starFragment:4}},
    {name:"ë©”ê¸´ìš”ë¥´ë“œ", type:"nord", score:6, grade:"Bronze", cost:{adamantite:9}},
    // Nord (Silver)
    {name:"ê·¸ëŒ", type:"nord", score:10, grade:"Silver", cost:{dragonBone:3, mithril:5, starFragment:3}},
    {name:"ìŠ¤ë°œë¦°", type:"nord", score:12, grade:"Silver", cost:{adamantite:5, mithril:8}},
    {name:"ê²”ë¼ë¥´ í˜¸ë¥¸", type:"nord", score:12, grade:"Silver", cost:{dragonBone:5, mithril:5, starFragment:3}},
    {name:"ë‹¤ì¸ìŠ¬ë ˆì´í”„", type:"nord", score:14, grade:"Silver", cost:{adamantite:5, mithril:3, starFragment:7}},
    {name:"ê¶ë‹ˆë¥´", type:"nord", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:2, starFragment:6}},
    {name:"ê¸€ë ˆì´í”„ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:3, dragonBone:5, starFragment:8}},
    {name:"ë¬ ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:6, mithril:7, starFragment:4}},
    // Nord (Gold)
    {name:"ë ˆë°”í…Œì¸", type:"nord", score:24, grade:"Gold", cost:{adamantite:11, dragonBone:4, mithril:5, starFragment:6}},

    // Celt (Bronze)
    {name:"ì˜¤í•œ", type:"celt", score:4, grade:"Bronze", cost:{adamantite:2, starFragment:4}},
    {name:"ëˆ„ì•„ë‹¤ì˜ ì€íŒ”", type:"celt", score:5, grade:"Bronze", cost:{dragonBone:4, starFragment:2}},
    {name:"ë‹¤ê·¸ë‹¤ì˜ ì†¥", type:"celt", score:6, grade:"Bronze", cost:{dragonBone:4, starFragment:4}},
    // Celt (Silver)
    {name:"ë§ˆë‚˜ë‚œì˜ í™©ê¸ˆ ê°‘ì˜·", type:"celt", score:10, grade:"Silver", cost:{adamantite:7, starFragment:4}},
    {name:"ì¹¼ë¼ë“œë³¼ê·¸", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, mithril:5, starFragment:2}},
    {name:"í˜ë¥´ë””ì•„ì˜ ë¿”ê°€ì£½", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, dragonBone:6, mithril:2}},
    {name:"ê²Œ ë³¼ê·¸", type:"celt", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:4, mithril:4}},
    {name:"ê²Œ ë‹¤ëŸ¬ê·¸", type:"celt", score:14, grade:"Silver", cost:{dragonBone:8, starFragment:7}},
    {name:"í”„ë¼ê°€ë¼í", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:4, mithril:8}},
    {name:"ê²Œ ë¹„ì–´", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:4, starFragment:2}},
    // Celt (Gold)
    {name:"ë¸Œë¥˜ë‚˜í¬", type:"celt", score:24, grade:"Gold", cost:{dragonBone:5, mithril:17, starFragment:3}}
];

// [Update] ë¡œí‚¤ DB (Source: ë¡œí‚¤_ë°ì´í„° í…Œì´ë¸” v1.9.xlsx)
const LOKI_DB = [
    {id:1,name:"êµ¬ë¶€ëŸ¬ì§„ ì‹œê³—ë°”ëŠ˜",desc:"ì‹œê°„ -1H",type:"active_time", count:4},
    {id:2,name:"ë§ê°ì˜ ì£¼íŒ",desc:"ìœ ë¬¼ êµí™˜(ë³´ê´€<->ì‹œì¥)",type:"active_swap", count:1},
    {id:3,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì¼ˆíŠ¸",type:"bless_split",tags:['nord','celt'], count:1},
    {id:4,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì´ì§‘íŠ¸",type:"bless_split",tags:['nord','egypt'], count:1},
    {id:5,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì˜¬ë¦¼í¬ìŠ¤",type:"bless_split",tags:['nord','olympus'], count:1},
    {id:6,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì´ì§‘íŠ¸",type:"bless_split",tags:['olympus','egypt'], count:1},
    {id:7,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì´ì§‘íŠ¸ / ì¼ˆíŠ¸",type:"bless_split",tags:['egypt','celt'], count:1},
    {id:8,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì¼ˆíŠ¸",type:"bless_split",tags:['olympus','celt'], count:1},
    {id:9,name:"í˜¼ëˆì˜ ì±„ì„ë§ì¹˜",desc:"ì‹œì¥ ìì› ë¦¬ì…‹",type:"active_reset", count:1},
    {id:10,name:"ë¶€ì„œì§„ íšŒì¤‘ì‹œê³„",desc:"ìœ ë¬¼ ì œì‘ ì‹œê°„ 0",type:"passive_free", count:1},
    {id:11,name:"ê³„ìŠ¹ìì˜ ë¬¸ì¥",desc:"ì¦‰ì‹œ +2ì ",type:"instant_score", count:4},
    {id:12,name:"ë¯¸ë˜ ì¼ê¸°",desc:"ë± ìœ„ 3ì¥ í™•ì¸, 1ì¥ íšë“",type:"active_peek", count:1},
    {id:13,name:"ê²€ì€ ì£¼ì‚¬ìœ„",desc:"ì†íŒ¨ 2ì¥ ë²„ë¦¬ê³  2ì¥ ë“œë¡œìš°",type:"active_draw", count:1},
    {id:14,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'dragonBone',val:4}], count:1},
    {id:15,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'mithril',val:4}], count:1},
    {id:16,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'adamantite',val:4}], count:1},
    {id:17,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'dragonBone',val:4}], count:1},
    {id:18,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'mithril',val:4}], count:1},
    {id:19,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'dragonBone',val:4},{type:'mithril',val:4}], count:1},
    {id:20,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'dragonBone',val:2}], count:1},
    {id:21,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'mithril',val:2}], count:1},
    {id:22,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'mithril',val:2}], count:1},
    {id:23,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'starFragment',val:2}], count:1},
    {id:24,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'starFragment',val:2},{type:'mithril',val:2}], count:1},
    {id:25,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'starFragment',val:2}], count:1},
    {id:26,name:"íŒŒê´´ëœ ì„±ë°°",desc:"ì‹œì¥ ì¶•ë³µ ë¦¬ì…‹",type:"active_reset_bless", count:1}
];
class Card {
    constructor(cat, type, val = null, extra = null) {
        this.cat = cat;
        this.type = type; 
        this.val = val; 
        this.extra = extra;
        this.id = Math.random().toString(36).substr(2, 9);
    }
}

class Deck {
    constructor(cat) {
        this.cat = cat;
        this.cards = [];
        this.discardPile = [];
        this.init();
    }

    init() {
        if (this.cat === 'resource') {
            const types = Object.keys(RES_NAMES);
            const vals = [2, 3, 4, 5, 6, 7];
            types.forEach(t => vals.forEach(v => {
                for (let i = 0; i < 3; i++) this.cards.push(new Card('resource', t, v));
            }));
        } else if (this.cat === 'blessing') {
            const types = Object.keys(TYPE_NAMES);
            types.forEach(t => {
                for (let i = 0; i < 8; i++) this.cards.push(new Card('blessing', t));
            });
        } else if (this.cat === 'artifact') {
            ARTIFACT_DB.forEach(art => this.cards.push({ ...art })); 
        } else if (this.cat === 'loki') {
            LOKI_DB.forEach(def => {
                for(let i=0; i<def.count; i++) {
                    this.cards.push(new Card('loki', 'loki', null, def));
                }
            });
        }
        this.shuffle();
    }

    shuffle() { this.cards.sort(() => Math.random() - 0.5); }

    draw() {
        if (this.cards.length === 0) {
            if (this.cat === 'loki' || this.discardPile.length === 0) return null;
            this.cards = [...this.discardPile];
            this.discardPile = [];
            this.shuffle();
        }
        return this.cards.pop();
    }

    peek(count) { return this.cards.slice(-count).reverse(); } // ë¯¸ë˜ì¼ê¸°ìš©

    discard(card) { this.discardPile.push(card); }
    getCount() { return this.cards.length; }
}

class Player {
    constructor(id) {
        this.id = id;
        this.hand = [];
        this.reserved = [];
        this.artifacts = [];
        this.score = 0;
        this.time = 0;
        this.stackOrder = 0;
        this.targetMyth = null; 
        this.celtConvertCount = 0;
        this.celtMimicMode = null;
        this.aiTargetIdx = null;
        this.olympusDiscount = { type: null, amount: 0 };
        
        // [Data Mining] ë°ì´í„° ë¶„ì„ìš© í•„ë“œ (ê¸°ì¡´ ë¡œì§ê³¼ í˜¸í™˜)
        this.dailyScore = [-1, -1, -1, -1, -1]; 
        this.history = []; 
        
        // 1. í–‰ë™ê¶Œ ê²©ì°¨ ì¶”ì  (ì´ í„´ ìˆ˜)
        this.totalTurns = 0; 
        
        // 2. ì—”ì§„ ê°€ë™ íƒ€ì´ë° (3ë‹¨ê³„ ì™„ì„± í„´, ë¯¸ë‹¬ì„± ì‹œ -1)
        this.lvl3Turn = { olympus: -1, egypt: -1, nord: -1, celt: -1 };
        
        // 3. ë¡œí‚¤ ìƒì„¸ ì‚¬ìš© ê¸°ë¡ (ID ë°°ì—´)
        this.usedLokiIds = []; 

        this.metrics = { 
            savedRes: 0, wastedCards: 0, celtSwaps: 0,
            resAcquired: 0, resConsumed: 0, lokiUsed: 0      
        };
        this.milestones = {}; 
    }

    getHandCount() {
        return this.hand.filter(c => c.cat !== 'loki').length;
    }

    // [New] ë¡œí‚¤ ì‚¬ìš© ê¸°ë¡ í—¬í¼ ë©”ì„œë“œ
    recordLokiUse(card) {
        this.metrics.lokiUsed++;
        if (card && card.extra && card.extra.id) {
            this.usedLokiIds.push(card.extra.id);
        }
    }
}

// ==========================================
// [Part 2] Game Engine (Core Logic - UI Free)
// ==========================================

class Game {
    constructor() {
        this.isInitialized = false;
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        this.players = [];
        this.pIdx = 0;
    }

    init(mythAssignments) {
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        
        this.players = [new Player(1), new Player(2), new Player(3), new Player(4)];
        this.players.forEach((p, i) => {
            p.targetMyth = mythAssignments ? mythAssignments[i] : ['olympus', 'egypt', 'nord', 'celt'][i];
            const rule = START_RULE[i];
            p.score = rule.score;
            p.stackOrder = 3 - i; 
        });

        this.deckRes = new Deck('resource');
        this.deckBless = new Deck('blessing');
        this.deckArt = new Deck('artifact');
        this.deckLoki = new Deck('loki');

        this.fieldRes = [];
        this.fieldBless = [];
        this.fieldArt = [];

        this.fill('resource', 6);
        this.fill('blessing', 4);
        this.fill('artifact', 7);

        this.players.forEach((p, i) => {
            const rule = START_RULE[i];
            for(let k=0; k<rule.res; k++) { const c = this.deckRes.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.bless; k++) { const c = this.deckBless.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.loki; k++) { const c = this.deckLoki.draw(); if(c) p.hand.push(c); }
        });

        this.pIdx = 0;
        this.isInitialized = true;
    }

    get cp() { return this.players[this.pIdx]; }

    fill(cat, max) {
        const field = cat === 'resource' ? this.fieldRes : (cat === 'blessing' ? this.fieldBless : this.fieldArt);
        const deck = cat === 'resource' ? this.deckRes : (cat === 'blessing' ? this.deckBless : this.deckArt);
        while(field.length < max) {
            const c = deck.draw();
            if(c) field.push(c);
            else break;
        }
    }

    getArtLevel(type) {
        const p = this.cp;
        let count = p.artifacts.filter(a => a.type === type).length;
        const celtCount = p.artifacts.filter(a => a.type === 'celt').length;
        // ì¼ˆíŠ¸ 3ë‹¨ê³„ ë¯¸ë¯¹ ì ìš©
        if (type !== 'celt' && celtCount >= 3 && p.celtMimicMode === type) count += 1;
        // ì¼ˆíŠ¸ ìì‹ ì€ ë¯¸ë¯¹ íš¨ê³¼ ëª» ë°›ìŒ (ì´ë¯¸ 3ì¥ì´ë¯€ë¡œ ì˜ë¯¸ ì—†ê¸°ë„ í•¨)
        if (type === 'celt' && celtCount >= 3 && p.celtMimicMode !== null) return 0;
        return count;
    }

    getCost(action) {
        let cost = CONFIG.COST[action];
        const egyptLv = this.getArtLevel('egypt');
        
        // ì´ì§‘íŠ¸ í• ì¸ ì ìš© (ëˆ„ì  ë°©ì‹)
        let discount = 0;
        const maxLevel = Math.min(egyptLv, 3);
        
        for (let i = 0; i < maxLevel; i++) {
            // BALANCE_CONFIGê°€ ë°°ì—´ì¸ì§€ í™•ì¸í•˜ê³  ì•ˆì „í•˜ê²Œ ì ‘ê·¼
            if (Array.isArray(BALANCE_CONFIG.EGYPT)) {
                const levelConfig = BALANCE_CONFIG.EGYPT[i];
                if (levelConfig) {
                    if (action === 'RESERVE') discount += levelConfig.RESERVE;
                    else if (action === 'RES') discount += levelConfig.RES;
                    else if (action === 'BLESS') discount += levelConfig.BLESS;
                    else if (action === 'ART') discount += levelConfig.ART;
                }
            } else {
                // êµ¬ë²„ì „ í˜¸í™˜ìš© (í˜¹ì‹œ ëª¨ë¥¼ ì—ëŸ¬ ë°©ì§€)
                if (action === 'RESERVE' && i === 0) discount += 1;
                if (action === 'RES' && i === 1) discount += 1;
                if ((action === 'BLESS' || action === 'ART') && i === 2) discount += 1;
            }
        }
        
        cost -= discount;
        return Math.max(0, cost);
    }

    consumeTime(amount) {
        const p = this.cp;
        const targetTime = p.time + amount;
        let maxStack = -1;
        this.players.forEach(other => {
            if (other.id !== p.id && other.time === targetTime) {
                if (other.stackOrder > maxStack) maxStack = other.stackOrder;
            }
        });
        p.time = targetTime;
        p.stackOrder = maxStack + 1;
        this.determineNextTurn();
    }

    determineNextTurn() {
        if (this.isGameEnded) return;
        if (this.players.every(p => p.time >= CONFIG.MAX_TIME)) { this.processDayEnd(); return; }
        
        let candidates = this.players.filter(p => p.time < CONFIG.MAX_TIME);
        if (candidates.length === 0) { this.processDayEnd(); return; }

        candidates.sort((a, b) => {
            if (a.time !== b.time) return a.time - b.time;
            return b.stackOrder - a.stackOrder;
        });

        const nextPlayer = candidates[0];
        if (this.cp.id !== nextPlayer.id) {
            this.pIdx = this.players.indexOf(nextPlayer);
            this.cp.celtConvertCount = 0; // í„´ ë³€ê²½ ì‹œ ì¼ˆíŠ¸ ì¹´ìš´íŠ¸ ë¦¬ì…‹
        }
    }

   processDayEnd() {
        this.players.forEach(p => {
            // 1. ì ìˆ˜ ê¸°ë¡
            if (this.day <= 5) p.dailyScore[this.day - 1] = p.score;
            
            // 2. [ì¶”ê°€ë¨] ìœ ë¬¼ ìƒíƒœ ìŠ¤ëƒ…ìƒ· ê¸°ë¡ (ì—‘ì…€ ë¶„ì„ìš©)
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(a => { if(counts[a.type] !== undefined) counts[a.type]++; });
            
            p.history.push({
                day: this.day,
                score: p.score,
                olympus: counts.olympus,
                egypt: counts.egypt,
                nord: counts.nord,
                celt: counts.celt
            });
        });

        if (this.day >= CONFIG.MAX_DAYS) { this.endGame(); return; }
        
        this.processNightInstant();
        this.day++;
        
        this.fieldRes.forEach(c => this.deckRes.discard(c)); this.fieldRes = [];
        this.fieldBless.forEach(c => this.deckBless.discard(c)); this.fieldBless = [];
        this.fill('resource', 6); this.fill('blessing', 4);

        this.players.forEach(p => { p.time = Math.max(0, p.time - CONFIG.MAX_TIME); });

        if (this.day > CONFIG.MAX_DAYS) this.endGame();
        else this.determineNextTurn();
    }
    processNightInstant() {
        let offers = [];
        for(let i=0; i<6; i++) offers.push(this.deckLoki.draw());
        let selections = {};
        this.players.forEach(p => { selections[p.id] = Math.floor(Math.random() * 6); });
        let counts = {};
        Object.values(selections).forEach(slot => { counts[slot] = (counts[slot] || 0) + 1; });

        this.players.forEach(p => {
            const choice = selections[p.id];
            if (counts[choice] === 1 && offers[choice]) {
                const item = offers[choice];
                if (item.extra.type === 'instant_score') p.score += 2;
                else p.hand.push(item);
            }
        });
    }

    endGame() {
        if (this.isGameEnded) return;
        this.isGameEnded = true;
        this.players.forEach(p => {
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(art => { if(counts[art.type] !== undefined) counts[art.type]++; });
            
            // 4ì¢… í†µí•© ë³´ë„ˆìŠ¤
            if(counts.olympus > 0 && counts.egypt > 0 && counts.nord > 0 && counts.celt > 0) p.score += 5;
            
            // ì‹ í™” ì „ë¬¸í™” ë³´ë„ˆìŠ¤
            for(const [type, count] of Object.entries(counts)) {
                if(count >= 4) p.score += (count - 3) * 2;
            }
        });
    }
}

// ==========================================
// [Part 3] AI Brain (Cleaned & Integrated)
// ==========================================

// 1. [íƒœì„¸ ì „í™˜] ì¼ˆíŠ¸ 3ë‹¨ê³„ ëŠ¥ë ¥ ìë™ ìŠ¤ìœ„ì¹­
Game.prototype.aiAutoSwitchCeltMode = function(plan) {
    // [Safety Fix] ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ì„ ê²½ìš°(undefined) ê¸°ë³¸ê°’ trueë¥¼ ì‚¬ìš©
    const cachedSetting = BALANCE_CONFIG.CELT.MIMIC_ENABLED;
    const isMimicEnabled = (cachedSetting !== undefined) ? cachedSetting : true;

    if (!isMimicEnabled) {
        if (this.cp.celtMimicMode !== null) this.cp.celtMimicMode = null;
        return;
    }

    const ai = this.cp;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    if (realCeltCount < 3) return;

    let targetMode = null; 

    if (plan && plan.preferredMode) {
        // AIê°€ íŠ¹ì • ëª¨ë“œë¥¼ ì„ í˜¸í•˜ë©´ ê·¸ ëª¨ë“œë¡œ ì „í™˜ (celtëŠ” ë³¸ì²´ì´ë¯€ë¡œ null)
        targetMode = plan.preferredMode === 'celt' ? null : plan.preferredMode;
    } else {
        // ë¹„ìƒ ì‹œ ê¸°ë³¸ ë¡œì§ (Original Logic ìœ ì§€)
        if (plan && plan.action === 'GATHER' && ai.getHandCount() <= 4) targetMode = 'nord';
        else if (ai.time >= 9) targetMode = 'egypt';
    }

    if (ai.celtMimicMode !== targetMode) {
        ai.celtMimicMode = targetMode;
    }
};

// 2. [ê°€ì¹˜ íŒë‹¨] ìœ ë¬¼ ê°€ì¹˜ ë° ë¹„ìš© ê³„ì‚° (Core Logic)
// [Part 3] AI Valuation Logic (ê¸°ì¡´ Game.prototype.aiCalculateTargetValue ëŒ€ì²´)
Game.prototype.aiCalculateTargetValue = function(art, isReserved) {
    const ai = this.cp;
    
    // [Safety Fix] ìºì‹±ëœ ì„¤ì •ê°’ ì‚¬ìš©í•˜ë˜, ë¹„ì–´ìˆìœ¼ë©´ true ì²˜ë¦¬
    const cachedSetting = BALANCE_CONFIG.CELT.MIMIC_ENABLED;
    const mimicEnabled = (cachedSetting !== undefined) ? cachedSetting : true;

    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    const canMimic = (realCeltCount >= 3 && mimicEnabled);

    const myRes = { adamantite:0, mithril:0, dragonBone:0, starFragment:0 };
    let totalHandCount = 0;
    ai.hand.forEach(c => {
        totalHandCount++;
        if (c.cat === 'resource') myRes[c.type] = (myRes[c.type]||0) + c.val;
        else if (c.cat === 'loki' && c.extra.type === 'res_split') {
            myRes[c.extra.options[0].type] = (myRes[c.extra.options[0].type]||0) + 4;
        }
    });

    // ì‹œë‚˜ë¦¬ì˜¤ë³„ ë¹„ìš© ê³„ì‚° í•¨ìˆ˜
    const calculateScenario = (mode) => {
        let simOlympusLv, simCeltLv;
        if (!canMimic) { simOlympusLv = this.getArtLevel('olympus'); simCeltLv = realCeltCount; } 
        else {
            const realOlympus = ai.artifacts.filter(a => a.type === 'olympus').length;
            if (mode === 'olympus') { simOlympusLv = Math.max(realOlympus, 3); simCeltLv = 0; }
            else if (mode === 'celt') { simOlympusLv = realOlympus; simCeltLv = 3; }
            else { simOlympusLv = realOlympus; simCeltLv = realCeltCount; }
        }

        let tempCost = { ...art.cost };
        let discountType = null;
        if (simOlympusLv > 0) {
            const amt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(simOlympusLv, 3)];
            let maxSaved = -1;
            for(let t in tempCost) {
                if(tempCost[t] > 0) {
                    let saved = Math.min(tempCost[t], amt);
                    if(saved > maxSaved) { maxSaved = saved; discountType = t; }
                }
            }
            if(discountType) tempCost[discountType] = Math.max(0, tempCost[discountType] - amt);
        }

        let availableSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(simCeltLv, 3)] - ai.celtConvertCount;
        let needsSwap = false;
        let tempHandCount = totalHandCount;
        let missing = 0;

        for(let t in tempCost) {
            let need = Math.max(0, tempCost[t] - (myRes[t]||0));
            if (need > 0 && availableSwaps > 0) {
                const cardsNeeded = Math.ceil(need / 4);
                if (tempHandCount >= cardsNeeded && availableSwaps >= cardsNeeded) {
                    availableSwaps -= cardsNeeded; tempHandCount -= cardsNeeded; need = 0; needsSwap = true;
                }
            }
            missing += need;
        }
        return { missing, needsSwap, discountType, mode };
    };

    const currentMode = canMimic ? (ai.celtMimicMode || 'celt') : 'celt';
    let bestScenario = calculateScenario(currentMode); 
    
    // ë¯¸ë¯¹ ê°€ëŠ¥ ì‹œ ìµœì ì˜ ëª¨ë“œ íƒìƒ‰
    if (canMimic) {
        const sO = calculateScenario('olympus');
        const sC = calculateScenario('celt');
        if (sO.missing <= 0 && sC.missing > 0) bestScenario = sO;
        else if (sC.missing <= 0 && sO.missing > 0) bestScenario = sC;
        else if (sO.missing <= 0 && sC.missing <= 0) bestScenario = sO; 
        else bestScenario = (sO.missing < sC.missing) ? sO : sC;
    }

    let action = bestScenario.missing <= 0 ? 'CRAFT' : 'GATHER';
    let net = art.score * 10;
// [ìˆ˜ì • ì½”ë“œ] 3ê°œ ë¯¸ë§Œì¼ ë•Œë§Œ ê°€ì¤‘ì¹˜ ë¶€ì—¬ (3ê°œ ë‹¬ì„± ì‹œ í•´ì œ)
const currentMythCount = ai.artifacts.filter(a => a.type === ai.targetMyth).length;
if (ai.targetMyth && art.type === ai.targetMyth && currentMythCount < 3) {
    net += 100;
}
    if (action === 'CRAFT') {
        net += 5000;
        if (isReserved) net += 2000;
        if (bestScenario.needsSwap) net += 50; 
    } else {
        net += Math.max(0, 500 - bestScenario.missing * 5);
        
        // [Logic Fix: ì´ì¤‘ í˜œíƒ ë°©ì§€] 
        // ì˜¬ë¦¼í¬ìŠ¤(í• ì¸) ëª¨ë“œ ì„ íƒ ì‹œ ë…¸ë¥´ë“œ(ì†ë„) í˜œíƒì„ ë™ì‹œì— ë°›ì§€ ëª»í•˜ë„ë¡ ë³´ì •
        let effNord;
        if (!canMimic) {
            effNord = this.getArtLevel('nord');
        } else {
            // íƒœì„¸ê°€ 'nord'ì´ê±°ë‚˜, ì¼ˆíŠ¸(ê¸°ë³¸) ìƒíƒœì—¬ì„œ ìˆ˜ì§‘ í–‰ë™ ì‹œ ë…¸ë¥´ë“œë¡œ ë³€ì‹  ê°€ëŠ¥í•œ ê²½ìš°ë§Œ +1
            const isNordMode = bestScenario.mode === 'nord' || ai.celtMimicMode === 'nord';
            const canSwitchToNord = bestScenario.mode === 'celt' || bestScenario.mode === null;
            
            if (isNordMode || canSwitchToNord) {
                effNord = ai.artifacts.filter(a => a.type === 'nord').length + 1;
            } else {
                effNord = ai.artifacts.filter(a => a.type === 'nord').length;
            }
        }

        let speed = BALANCE_CONFIG.NORD.GATHER_SPEED[Math.min(effNord, 3)];
        net -= (Math.ceil(bestScenario.missing / speed) * 10);
    }

    let timeCost = CONFIG.COST[action];
    let effEgy = !canMimic ? this.getArtLevel('egypt') : (bestScenario.mode==='egypt'||ai.celtMimicMode==='egypt' ? Math.max(ai.artifacts.filter(a=>a.type==='egypt').length,3) : ai.artifacts.filter(a=>a.type==='egypt').length);
    let egyDisc = 0;
    for(let i=0; i<Math.min(effEgy, 3); i++) {
        const c = BALANCE_CONFIG.EGYPT[i];
        if(c) egyDisc += (action==='RESERVE'?c.RESERVE : action==='GATHER'?c.RES : action==='CRAFT'?c.ART : 0);
    }
    timeCost = Math.max(0, timeCost - egyDisc);
    if (timeCost <= 0) net += 150; else if (timeCost < CONFIG.COST[action]) net += 50;

    let hasBless = ai.hand.some(c => (c.cat === 'blessing' && c.type === art.type) || (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
    
    // [ë³€ê²½] includes -> >= (ìµœì†Œ ë ˆë²¨ ì´ìƒì´ë©´ ë°œë™)
    const allowConvert = realCeltCount >= BALANCE_CONFIG.CELT.LVL_CONVERT;
    const allowFree = realCeltCount >= BALANCE_CONFIG.CELT.LVL_FREE;

    if (!hasBless && allowConvert) {
        hasBless = ai.hand.some(c => c.cat === 'blessing' || (c.cat === 'loki' && c.extra.type === 'bless_split'));
    }
    let needBless = !hasBless && !allowFree;
    if (needBless) net -= 5000;
    // [Logic Restored] ìƒì„¸ ì„ í˜¸ íƒœì„¸ ê²°ì • ë¡œì§ (ì™„ì „ ë³µì›)
    let finalPreferredMode = bestScenario.mode;
    if (action === 'GATHER' && canMimic) {
        let nordIdx = Math.max(0, Math.min(this.getArtLevel('nord')+1, 3)-1);
        let nordCap = BALANCE_CONFIG.NORD.LIMIT_COUNT[Math.min(nordIdx, 2)];
        let rawMissing = 0; for(let t in art.cost) if(art.cost[t] > (myRes[t]||0)) rawMissing += (art.cost[t]-(myRes[t]||0));
        
        if (bestScenario.needsSwap) {
             if (ai.getHandCount() <= 4 && rawMissing >= 2 && nordCap >= 2) { finalPreferredMode = 'nord'; net += 150; }
             else { finalPreferredMode = 'celt'; net += 200; }
        } else if (rawMissing >= 1 && nordCap >= 2 && ai.getHandCount() <= 6) { 
            finalPreferredMode = 'nord'; net += 150; 
        } else if (bestScenario.missing === 1 && finalPreferredMode !== 'celt') { 
            finalPreferredMode = 'egypt'; net += 40; 
        }
    }

    return { art, netValue: net, action, fromReserve: isReserved, discountType: bestScenario.discountType, targetIdx: -1, needBless, missingVal: bestScenario.missing, preferredMode: finalPreferredMode };
};

// 3. [ì „ìˆ  ì‹¤í–‰] ë¡œí‚¤ ì¹´ë“œ ì‚¬ìš© (v9.2 Integrated)
Game.prototype.aiPlayLokiTactics = function() {
    const ai = this.cp;
    
    // 1. ê³„ìŠ¹ìì˜ ë¬¸ì¥
    const crestIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'instant_score');
    if (crestIdx !== -1) { 
        ai.score += 2; 
        const card = ai.hand[crestIdx];
        ai.hand.splice(crestIdx, 1); 
        ai.recordLokiUse(card); 
        return true; 
    }

    // 2. êµ¬ë¶€ëŸ¬ì§„ ì‹œê³—ë°”ëŠ˜
    const clockIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_time');
    if (clockIdx !== -1) {
        if (ai.time >= 9 || (ai.score < 10 && ai.time >= 7)) {
            ai.time = Math.max(0, ai.time - 1); 
            const card = ai.hand[clockIdx];
            ai.hand.splice(clockIdx, 1); 
            ai.recordLokiUse(card); 
            return true;
        }
    }

    // 3. ê²€ì€ ì£¼ì‚¬ìœ„
    const diceIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_draw');
    if (diceIdx !== -1) {
        const junkIndices = ai.hand.map((c, i) => (c.cat === 'resource' && c.val <= 3) ? i : -1).filter(i => i !== -1);
        
        if (junkIndices.length >= 2) {
            let targets = [diceIdx, junkIndices[0], junkIndices[1]];
            targets = [...new Set(targets)];
            targets.sort((a, b) => b - a); 

            // ì¹´ë“œë¥¼ spliceí•˜ê¸° ì „ì— ì°¸ì¡° ê°ì²´ í™•ë³´
            const lokiCard = ai.hand[diceIdx]; 

            targets.forEach(idx => ai.hand.splice(idx, 1));
            
            for(let k=0; k<2; k++) { 
                const newCard = this.deckRes.draw(); 
                if(newCard) {
                    ai.hand.push(newCard);
                    ai.metrics.resAcquired += newCard.val;
                }
            }
            ai.recordLokiUse(lokiCard); 
            this.consumeTime(1); 
            return true;
        }
    }

    // 4. ë¯¸ë˜ ì¼ê¸°
    const diaryIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_peek');
    if (diaryIdx !== -1 && ai.getHandCount() < 8) {
        if (this.deckArt.cards.length < 3) {
             this.deckArt.cards = [...this.deckArt.discardPile];
             this.deckArt.discardPile = [];
             this.deckArt.shuffle();
        }
        const candidates = [];
        for(let k=0; k<3; k++) { let c = this.deckArt.draw(); if(c) candidates.push(c); }
        
        if (candidates.length > 0) {
            candidates.sort((a, b) => b.score - a.score);
            const selected = candidates[0];
            
            if (ai.reserved.length < 1) {
                ai.reserved.push(selected);
            } else {
                this.deckArt.discard(selected);
            }
            for(let k=1; k<candidates.length; k++) this.deckArt.discard(candidates[k]);
        }

        const card = ai.hand[diaryIdx];
        ai.hand.splice(diaryIdx, 1);
        ai.recordLokiUse(card); 
        this.consumeTime(1);
        return true;
    }

    // 5. í˜¼ëˆì˜ ì±„ì„ë§ì¹˜
    const hammerIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_reset');
    if (hammerIdx !== -1) {
        const fieldSum = this.fieldRes.reduce((a, b) => a + b.val, 0);
        const fieldAvg = this.fieldRes.length > 0 ? fieldSum / this.fieldRes.length : 0;
        const hasHighValue = this.fieldRes.some(c => c.val >= 6);

        if (fieldAvg <= 3.5 && !hasHighValue) {
            this.fieldRes.forEach(c => this.deckRes.discard(c));
            this.fieldRes = [];
            this.fill('resource', 6);
            
            const card = ai.hand[hammerIdx];
            ai.hand.splice(hammerIdx, 1);
            ai.recordLokiUse(card); 
            this.consumeTime(1);
            return true;
        }
    }
    return false;
};

// 4. [ì „ëµ ìˆ˜ë¦½] ìµœì  ê³„íš ì°¾ê¸°
Game.prototype.aiFindBestPlan = function() {
    const ai = this.cp;
    let bestScore = -Infinity;
    let bestPlan = null;

    // ë§ê°ì˜ ì£¼íŒ (ì „ëµì  êµí™˜)
    const abacusIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_swap');
    if (abacusIdx !== -1 && ai.reserved.length > 0 && this.fieldArt.length > 0) {
        let worstRes = { score: 999, idx: -1 };
        ai.reserved.forEach((art, i) => { if(art.score < worstRes.score) worstRes = {score: art.score, idx: i}; });
        let bestMkt = { score: -1, idx: -1 };
        this.fieldArt.forEach((art, i) => { if(art.score > bestMkt.score) bestMkt = {score: art.score, idx: i}; });
        
        if (bestMkt.score - worstRes.score >= 6) {
            return { action: 'SWAP_ARTIFACT', handIdx: abacusIdx, reserveIdx: worstRes.idx, marketIdx: bestMkt.idx };
        }
    }

    // ì˜ˆì•½ ìœ ë¬¼ í‰ê°€
    ai.reserved.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, true);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    // ì‹œì¥ ìœ ë¬¼ í‰ê°€
    this.fieldArt.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, false);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    return bestPlan;
};

// 5. [í–‰ë™ ì‹¤í–‰] ì œì‘ íŠ¸ëœì­ì…˜ (ìì› ì†Œëª¨ ë¡œì§)
// [Part 3] Craft Transaction (ê¸°ì¡´ Game.prototype.processCraftTransaction ëŒ€ì²´)
Game.prototype.processCraftTransaction = function(ai, plan) {
    const art = plan.art;
    const fromReserve = plan.fromReserve;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;

    let requirements = { ...art.cost };
    let olympusSavedAmount = 0;

    // ì˜¬ë¦¼í¬ìŠ¤ í• ì¸ ì ìš©
    if (plan.discountType) {
        const olympusLv = this.getArtLevel('olympus'); 
        const amt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(olympusLv, 3)];
        requirements[plan.discountType] = Math.max(0, requirements[plan.discountType] - amt);
        olympusSavedAmount = amt;
    }

    let cardsToPay = [];
    let hand = [...ai.hand];
    
    // 1. ìì› ì§€ë¶ˆ (Resource)
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'resource' && c.type === reqType) {
                needed -= c.val; cardsToPay.push(c); hand.splice(i, 1); ai.metrics.resConsumed += c.val; 
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }
    // 2. ë¡œí‚¤ ìì› ëŒ€ì²´ (Loki Resource Split)
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal; if (needed <= 0) continue;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'loki' && c.extra.type === 'res_split' && c.extra.options.some(opt => opt.type === reqType)) {
                needed -= 4; cardsToPay.push(c); hand.splice(i, 1); ai.metrics.resConsumed += 4;
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }
    // 3. ì¼ˆíŠ¸ ìì› ë³€í™˜ (Celt Swap)
    const activeCeltLv = this.getArtLevel('celt');
    const maxSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(activeCeltLv, 3)];
    let usedSwaps = 0; let currentTotalSwaps = ai.celtConvertCount;
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal; if (needed <= 0) continue;
        if (currentTotalSwaps < maxSwaps) {
            for (let i = hand.length - 1; i >= 0; i--) {
                if (needed <= 0 || currentTotalSwaps >= maxSwaps) break;
                let c = hand[i];
                if (c.cat === 'resource') {
                    needed -= c.val; cardsToPay.push(c); hand.splice(i, 1); usedSwaps++; currentTotalSwaps++; ai.metrics.resConsumed += c.val; 
                }
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }

    // ìì› ë¶€ì¡± ì‹œ ì‹¤íŒ¨ ì²˜ë¦¬
    if (Object.values(requirements).reduce((a,b)=>a+b, 0) > 0) return false;

    // [ë³€ê²½] includes -> >= 
    const isConvert = realCeltCount >= BALANCE_CONFIG.CELT.LVL_CONVERT;
    const isFree = realCeltCount >= BALANCE_CONFIG.CELT.LVL_FREE;
    
    if (!isFree) {
         let blessIdx = hand.findIndex(c => (c.cat === 'blessing' && c.type === art.type) || (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
         if (blessIdx === -1 && isConvert) blessIdx = hand.findIndex(c => c.cat === 'blessing' || (c.cat === 'loki' && c.extra.type === 'bless_split'));
         if (blessIdx !== -1) { cardsToPay.push(hand[blessIdx]); hand.splice(blessIdx, 1); } else return false;
    }

    // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ ë° ì¹´ë“œ ë²„ë¦¼
    if (olympusSavedAmount > 0) ai.metrics.savedRes += olympusSavedAmount;
    if (usedSwaps > 0) { ai.metrics.celtSwaps += usedSwaps; ai.celtConvertCount += usedSwaps; }
    ai.hand = hand;
    cardsToPay.forEach(c => {
        if(c.cat === 'resource') this.deckRes.discard(c);
        else if(c.cat === 'blessing') this.deckBless.discard(c);
        else if(c.cat === 'loki') this.deckLoki.discard(c); 
    });

    // ì ìˆ˜ ë° ìœ ë¬¼ ë“±ë¡
    let scoreBonus = (art.score >= 24) ? 4 : (art.score >= 10 ? 3 : 2);
    const craftedArt = { ...art, isGrace: true, finalScore: art.score + scoreBonus, bonus: scoreBonus };
    ai.artifacts.push(craftedArt);
    ai.score += craftedArt.finalScore;

    const typeCount = ai.artifacts.filter(a => a.type === craftedArt.type).length;
    
    // [Track] ì—”ì§„ ê°€ë™ ì‹œì (3ë‹¨ê³„) ê¸°ë¡
    if (typeCount === 3) {
        if (ai.milestones[craftedArt.type] === undefined) ai.milestones[craftedArt.type] = this.craftOrder++;
        if (ai.lvl3Turn[craftedArt.type] === -1) ai.lvl3Turn[craftedArt.type] = ai.totalTurns;
    }

    // ì‹œì¥/ì˜ˆì•½ ì²˜ë¦¬
    if (fromReserve) ai.reserved.splice(plan.targetIdx, 1);
    else { this.fieldArt.splice(plan.targetIdx, 1); this.fill('artifact', 7); }
    
    // [Track] ë¶€ì„œì§„ íšŒì¤‘ì‹œê³„ ì‚¬ìš© ê¸°ë¡
    const freeCardIdx = cardsToPay.findIndex(c => c.cat === 'loki' && c.extra.type === 'passive_free');
    if (freeCardIdx !== -1) { 
        ai.recordLokiUse(cardsToPay[freeCardIdx]); 
        this.consumeTime(0); 
    }
    else this.consumeTime(this.getCost('ART'));

    return true;
};

// 6. [AI ë©”ì¸] í„´ ì‹¤í–‰ í•¨ìˆ˜
Game.prototype.aiTurn = function() {
    const ai = this.cp;
    // ê²Œì„ ì¢…ë£Œë‚˜ ì‹œê°„ ì´ˆê³¼ ì‹œì—ëŠ” í„´ì„ ì†Œëª¨í•˜ì§€ ì•ŠìŒ
    if (this.isGameEnded || ai.time >= CONFIG.MAX_TIME) return;

    // [Bug Fix] í–‰ë™ì„ ì‹œì‘í•˜ê¸° ì§ì „ì— ì´ í„´ ìˆ˜(Total Turns)ë¥¼ 1 ì¦ê°€ì‹œí‚µë‹ˆë‹¤.
    ai.totalTurns++; 

    // 1. í•¸ë“œ ì •ë¦¬
    if (ai.getHandCount() > CONFIG.HAND_LIMIT) { 
        this.aiSmartDiscard(ai); 
        return; 
    }

    // 2. ë¡œí‚¤ ì „ìˆ 
    if (this.aiPlayLokiTactics()) return;

    // 3. ì „ëµ ìˆ˜ë¦½
    const bestPlan = this.aiFindBestPlan();
    
    if (!bestPlan) { 
        this.aiEmergencyAction(); 
        return; 
    }

    // íƒœì„¸ ì „í™˜
    this.aiAutoSwitchCeltMode(bestPlan);
    ai.aiTargetIdx = bestPlan.targetIdx;

    // 4. í–‰ë™ ì‹¤í–‰
    if (bestPlan.action === 'SWAP_ARTIFACT') {
        const myArt = ai.reserved[bestPlan.reserveIdx];
        const marketArt = this.fieldArt[bestPlan.marketIdx];
        ai.reserved[bestPlan.reserveIdx] = marketArt;
        this.fieldArt[bestPlan.marketIdx] = myArt;
        ai.hand.splice(bestPlan.handIdx, 1);
        this.consumeTime(this.getCost('SWAP'));
    }
    else if (bestPlan.action === 'CRAFT') {
        const success = this.processCraftTransaction(ai, bestPlan);
        if (!success) this.aiActionGather(bestPlan);
    } 
    else if (bestPlan.action === 'RESERVE') {
        if (ai.reserved.length >= 1) {
            this.aiActionGather(bestPlan);
        } else {
            const art = this.fieldArt[bestPlan.targetIdx];
            if (art) {
                ai.reserved.push(art);
                this.fieldArt.splice(bestPlan.targetIdx, 1);
                this.fill('artifact', 7);
                this.consumeTime(this.getCost('RESERVE'));
            } else {
                this.aiEmergencyAction();
            }
        }
    }
    else { 
        this.aiActionGather(bestPlan);
    }
};

// 7. [ìì› ìˆ˜ì§‘] ì´í•˜ ì½”ë“œëŠ” ì›ë³¸ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€
// [Part 3 ì¶”ê°€] Gather Logic Update (ê¸°ì¡´ Game.prototype.aiActionGather ëŒ€ì²´)
Game.prototype.aiActionGather = function(plan) {
        const ai = this.cp;
        
        if (plan.needBless) {
            let blessIdx = this.fieldBless.findIndex(c => c.type === plan.art.type);
            const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
            
            // [ë³€ê²½] includes -> >=
            if (blessIdx === -1 && realCeltCount >= BALANCE_CONFIG.CELT.LVL_CONVERT) {
                blessIdx = this.fieldBless.findIndex(c => true); 
            }

        if (blessIdx !== -1) {
            ai.hand.push(this.fieldBless[blessIdx]);
            this.fieldBless.splice(blessIdx, 1);
            this.fill('blessing', 4);
            this.consumeTime(this.getCost('BLESS'));
        } else {
            // [Track] íŒŒê´´ëœ ì„±ë°° ì‚¬ìš© ì¶”ì 
            const grailIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_reset_bless');
            if (grailIdx !== -1) {
                this.fieldBless.forEach(c => this.deckBless.discard(c));
                this.fieldBless = []; this.fill('blessing', 4);
                
                const card = ai.hand[grailIdx];
                ai.hand.splice(grailIdx, 1);
                ai.recordLokiUse(card); 
                return;
            }
            
            const c = this.deckBless.draw();
            if(c) ai.hand.push(c);
            this.consumeTime(this.getCost('BLESS'));
        }
        return;
    }

    if (this.getArtLevel('nord') > 0 && this.aiTryNordAction(plan.art)) return;

    let neededTypes = [];
    let myRes = {}; 
    ai.hand.forEach(c => { if(c.cat==='resource') myRes[c.type] = (myRes[c.type]||0)+c.val; });
    for(const [t, req] of Object.entries(plan.art.cost)) { if(myRes[t] < req) neededTypes.push(t); }

    let targetIdx = -1;
    for(let i=0; i<this.fieldRes.length; i++) {
        if (neededTypes.includes(this.fieldRes[i].type) && this.fieldRes[i].val >= 3) { targetIdx = i; break; }
    }
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) {
            if (neededTypes.includes(this.fieldRes[i].type)) { targetIdx = i; break; }
        }
    }
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) { if (this.fieldRes[i].val >= 6) { targetIdx = i; break; } }
    }

    if (targetIdx !== -1) {
        const card = this.fieldRes[targetIdx];
        ai.hand.push(card);
        ai.metrics.resAcquired += card.val; 
        this.fieldRes.splice(targetIdx, 1);
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES'));
    } else {
        const c = this.deckRes.draw();
        if(c) {
            ai.hand.push(c);
            ai.metrics.resAcquired += c.val; 
        }
        this.consumeTime(this.getCost('RES'));
    }
};

// [Part 3] AI Logic Update: Nord Multi-Gather Fix (v9.2 Verified)
Game.prototype.aiTryNordAction = function(targetArt) {
    const ai = this.cp;
    const handLimit = CONFIG.HAND_LIMIT; // ë³´í†µ 8
    
    // í•¸ë“œ ê³µê°„ì´ ìµœì†Œ 2ì¹¸ì€ ìˆì–´ì•¼ ëŠ¥ë ¥ ë°œë™ ì‹œë„ (ì•„ë‹ˆë©´ ì¼ë°˜ ìˆ˜ì§‘ìœ¼ë¡œ fallback)
    if (ai.getHandCount() >= handLimit - 1) return false;

    // 1. [Fix] ì¸ë±ìŠ¤ ë³´ì • (Level 1 -> Index 0)
    const nordLv = this.getArtLevel('nord'); 
    if (nordLv <= 0) return false; // ë°©ì–´ ì½”ë“œ

    // ë°°ì—´ ë²”ìœ„ ì•ˆì „ ì ‘ê·¼ (Lv1->0, Lv2->1, Lv3->2)
    const statIdx = Math.min(Math.max(0, nordLv - 1), 2); 
    
    const limitSum = BALANCE_CONFIG.NORD.LIMIT_SUM[statIdx];
    const maxCount = BALANCE_CONFIG.NORD.LIMIT_COUNT[statIdx]; // 2 or 3

    let indices = this.fieldRes.map((_, i) => i);
    let bestCombo = null;
    let bestScore = -1;

    // 2. [2ì¥ ì¡°í•©] íƒìƒ‰
    // ê³µê°„ì´ 2ì¹¸ ì´ìƒ ìˆì„ ë•Œ ìˆ˜í–‰
    if (maxCount >= 2 && ai.getHandCount() <= handLimit - 2) {
        for (let i = 0; i < indices.length; i++) {
            for (let j = i + 1; j < indices.length; j++) {
                const c1 = this.fieldRes[i];
                const c2 = this.fieldRes[j];
                const sumVal = c1.val + c2.val;

                if (sumVal <= limitSum) {
                    let score = sumVal;
                    // ëª©í‘œ ì¬ë£Œ ê°€ì¤‘ì¹˜
                    if (targetArt.cost[c1.type] > 0) score += 15;
                    if (targetArt.cost[c2.type] > 0) score += 15;
                    
                    if (score > bestScore) { 
                        bestScore = score; 
                        bestCombo = [i, j]; 
                    }
                }
            }
        }
    }

    // 3. [3ì¥ ì¡°í•©] íƒìƒ‰ (3ë‹¨ê³„ í™œì„± ì‹œ)
    // ê³µê°„ì´ 3ì¹¸ ì´ìƒ ìˆì„ ë•Œ ìˆ˜í–‰
    if (maxCount >= 3 && ai.getHandCount() <= handLimit - 3) {
        for (let i = 0; i < indices.length; i++) {
            for (let j = i + 1; j < indices.length; j++) {
                for (let k = j + 1; k < indices.length; k++) {
                    const c1 = this.fieldRes[i];
                    const c2 = this.fieldRes[j];
                    const c3 = this.fieldRes[k];
                    const sumVal = c1.val + c2.val + c3.val;

                    if (sumVal <= limitSum) {
                        let score = sumVal;
                        
                        // [Logic Update] 3ì¥ì„ ë¨¹ëŠ” ê²ƒì˜ ì „ëµì  ê°€ì¹˜ë¥¼ ëŒ€í­ ìƒí–¥ (+20)
                        // í•©ê³„ê°€ ë‚®ë”ë¼ë„ 3ì¥ì„ í„¸ì–´ì˜¤ëŠ” ê²ƒì´ ë…¸ë¥´ë“œ ìš´ì˜ì˜ í•µì‹¬
                        score += 20; 
                        
                        if (targetArt.cost[c1.type] > 0) score += 15;
                        if (targetArt.cost[c2.type] > 0) score += 15;
                        if (targetArt.cost[c3.type] > 0) score += 15;

                        if (score > bestScore) { 
                            bestScore = score; 
                            bestCombo = [i, j, k]; 
                        }
                    }
                }
            }
        }
    }

    // 4. ìµœì  ì¡°í•© ì‹¤í–‰
    if (bestCombo) {
        bestCombo.sort((a, b) => b - a); // ì—­ìˆœ ì •ë ¬ (ì¸ë±ìŠ¤ ë°€ë¦¼ ë°©ì§€)
        
        bestCombo.forEach(idx => {
            const card = this.fieldRes[idx];
            ai.hand.push(card);
            ai.metrics.resAcquired += card.val;
            this.fieldRes.splice(idx, 1);
        });
        
        this.fill('resource', 6);
        // ì‹œê°„ ì†Œëª¨ëŠ” ì¼ë°˜ ìˆ˜ì§‘ê³¼ ë™ì¼ (Configì— ë³„ë„ Time Reduceê°€ ì—†ë‹¤ë©´)
        this.consumeTime(this.getCost('RES')); 
        return true;
    }

    return false; // ë…¸ë¥´ë“œ ì¡°ê±´ ë§Œì¡± ì¡°í•© ì—†ìŒ -> ì¼ë°˜ ìˆ˜ì§‘ ìˆ˜í–‰
};

Game.prototype.aiSmartDiscard = function(ai) {
    let worstIdx = -1; let minScore = 999;
    ai.hand.forEach((c, i) => {
        let score = 10; 
        if (c.cat === 'resource') score = c.val; 
        else if (c.cat === 'blessing') score = 5; 
        else if (c.cat === 'loki') score = 20; 
        if (score < minScore) { minScore = score; worstIdx = i; }
    });
    if (worstIdx !== -1) {
        const c = ai.hand[worstIdx];
        ai.hand.splice(worstIdx, 1);
        if (c.cat === 'resource') this.deckRes.discard(c);
        else if (c.cat === 'blessing') this.deckBless.discard(c);
        ai.metrics.wastedCards++;
    }
};

Game.prototype.aiEmergencyAction = function() {
    const c = this.deckRes.draw();
    if(c) this.cp.hand.push(c);
    this.consumeTime(this.getCost('RES'));
};

// ==================================================================================
// [Part 4] Simulation Manager (Revised v9.4: High Score & Elite Meta Added)
// ==================================================================================

// ==================================================================================
// [Part 4] Simulation Manager (Final v9.5: Korean & Full Data Restoration)
// ==================================================================================

// ==================================================================================
// [Part 4] Simulation Manager (Final v9.6: Visual Dashboard & OP Analysis)
// ==================================================================================

// ==================================================================================
// [Part 4] Simulation Manager (Final v9.8: Tier Depth & Top 5 UI)
// ==================================================================================

class SimulationManager {
    constructor() {
        this.isRunning = false;
        this.stats = this.getEmptyStats();
        this.csvData = []; 
    }

    getEmptyStats() {
        return {
            totalGames: 0,
            wins: [0, 0, 0, 0, 0], 
            draws: 0,
            totalScore: 0,
            days: 0,
            
            // [New] ì‹ í™”ë³„ ìƒì„¸ ìŠ¹ë¦¬ ë°ì´í„° (Tier 2 vs Tier 3 ë¶„ë¦¬)
            mythStats: {
                olympus: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                egypt: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                nord: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                celt: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                mix: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 }
            },

            // [New] Top 5 ê¸°ë¡ ê´€ë¦¬
            topScores: [], 

            // ìƒìœ„ 5% ë©”íƒ€ ë¶„ì„ìš©
            winnerRecords: [], 

            // ìˆœìœ„ë³„ í†µê³„
            rankStats: {
                lokiCount: [0, 0, 0, 0], 
                artScoreAvg: [0, 0, 0, 0], 
                count: [0, 0, 0, 0]      
            },
            totalGap1vs2: 0,

            // ê²½ì œ
            totalSaved: 0, totalWasted: 0, totalSwaps: 0,
            totalResAcquired: 0, totalResConsumed: 0,
            
            // ì¼ì¼ í†µê³„
            mythDailyStats: {
                olympus: { sum: [0,0,0,0,0], count: 0 },
                egypt: { sum: [0,0,0,0,0], count: 0 },
                nord: { sum: [0,0,0,0,0], count: 0 },
                celt: { sum: [0,0,0,0,0], count: 0 }
            }
        };
    }

    runOneGame(mythAssignments, gameId) {
        const game = new Game();
        game.init(mythAssignments);

        let safetyCount = 0;
        while (!game.isGameEnded && safetyCount < 1000) {
            game.aiTurn();
            safetyCount++;
        }

        if (game.isGameEnded) {
            this.collectData(game, gameId);
        }
    }

    async startSimulation() {
        if (this.isRunning) return;
        applyUserBalance();
        
        if (this.csvData.length === 0) {
            this.csvData = ["GameID,Day,PlayerID,MainMyth,Rank,Score,OlympusLv,EgyptLv,NordLv,CeltLv,TotalTurns,EngineTurn,HandValue,EffRatio,UsedLoki"];
        }
        
        const countInput = document.getElementById('simCount');
        const count = parseInt(countInput.value);
        const myths = [
            document.getElementById('p1Myth').value,
            document.getElementById('p2Myth').value,
            document.getElementById('p3Myth').value,
            document.getElementById('p4Myth').value
        ];

        this.isRunning = true;
        let startGameId = this.stats.totalGames + 1;
        
        this.updateLog(`[System] ${count}íšŒ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ (v9.8 Final)`);
        
        let chunkSize = 100;
        if (count >= 5000) chunkSize = 500;
        
        for (let i = 0; i < count; i += chunkSize) {
            if (!this.isRunning) break;
            const limit = Math.min(i + chunkSize, count);
            for (let j = i; j < limit; j++) { 
                this.runOneGame(myths, startGameId++); 
            }
            const progress = Math.round(((i + chunkSize) / count) * 100);
            document.getElementById('progressBar').style.width = `${progress}%`;
            await new Promise(r => setTimeout(r, 0));
        }

        this.renderStats();
        this.isRunning = false;
        document.getElementById('progressBar').style.width = `0%`;
    }

    stopSimulation() {
        this.isRunning = false;
        this.updateLog("[System] ì¤‘ì§€ë¨.");
    }

    resetStats() {
        this.stats = this.getEmptyStats();
        this.csvData = [];
        this.updateLog("[System] ì´ˆê¸°í™” ì™„ë£Œ.");
        document.getElementById('mainStats').innerHTML = "";
        document.getElementById('detailStats').innerHTML = "";
    }

    collectData(game, gameId) {
        let rankedPlayers = [...game.players];
        rankedPlayers.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score; 
            return b.artifacts.length - a.artifacts.length;    
        });

        const gap = rankedPlayers[0].score - rankedPlayers[1].score;
        this.stats.totalGap1vs2 += gap;
        
        const winner = rankedPlayers[0];
        const isDraw = rankedPlayers[1].score === winner.score && rankedPlayers[1].artifacts.length === winner.artifacts.length;

        rankedPlayers.forEach((p, index) => {
            let rank = index + 1;
            if (index > 0) {
                const prev = rankedPlayers[index - 1];
                if (p.score === prev.score && p.artifacts.length === prev.artifacts.length) {
                    rank = prev.rank;
                }
            }
            p.rank = rank;

            // ì£¼ë ¥ ì‹ í™” ë° ë± êµ¬ì„± ë¶„ì„
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            const grades = { Gold: 0, Silver: 0, Bronze: 0 };
            p.artifacts.forEach(a => { 
                if(counts[a.type] !== undefined) counts[a.type]++; 
                if(grades[a.grade] !== undefined) grades[a.grade]++;
            });
            
            let mainMyth = 'mix';
            let maxVal = 0;
            for(const c of Object.values(counts)) { if (c > maxVal) maxVal = c; }
            const candidates = Object.keys(counts).filter(m => counts[m] === maxVal);
            
            if (candidates.length === 1) {
                mainMyth = candidates[0];
            } else {
                candidates.sort((a, b) => { 
                    const orderA = p.milestones[a] !== undefined ? p.milestones[a] : 99999;
                    const orderB = p.milestones[b] !== undefined ? p.milestones[b] : 99999;
                    return orderA - orderB;
                });
                mainMyth = (p.milestones[candidates[0]] !== undefined) ? candidates[0] : 'mix';
            }

            // [New] Top 5 Score Update
            this.updateTopScores(p, mainMyth, counts, grades);

            // Myth Stats ëˆ„ì  (ìˆœìœ„)
            if (this.stats.mythStats[mainMyth]) {
                this.stats.mythStats[mainMyth].rankSum += rank;
                this.stats.mythStats[mainMyth].count++;
            }

            // Rank Stats
            if (index < 4) {
                this.stats.rankStats.lokiCount[index] += p.metrics.lokiUsed;
                const artCount = p.artifacts.length;
                let avgScore = 0;
                if (artCount > 0) {
                    const artScoreSum = p.artifacts.reduce((sum, a) => sum + a.score, 0); 
                    avgScore = artScoreSum / artCount;
                }
                this.stats.rankStats.artScoreAvg[index] += avgScore;
                this.stats.rankStats.count[index]++;
            }

            // Daily Stats
            if (mainMyth !== 'mix' && this.stats.mythDailyStats[mainMyth]) {
                this.stats.mythDailyStats[mainMyth].count++;
                let filledDaily = [...p.dailyScore];
                for(let d=0; d<5; d++) {
                    if (filledDaily[d] === -1) {
                        if (d === 0) filledDaily[d] = p.score; 
                        else filledDaily[d] = filledDaily[d-1];
                    }
                    this.stats.mythDailyStats[mainMyth].sum[d] += filledDaily[d];
                }
            }

            const engineTurn = (mainMyth !== 'mix') ? p.lvl3Turn[mainMyth] : -1;
            let handValue = 0; p.hand.forEach(c => { if(c.cat === 'resource') handValue += c.val; });
            const effRatio = p.metrics.resAcquired > 0 ? (p.metrics.resConsumed / p.metrics.resAcquired).toFixed(3) : 0;
            const lokiStr = p.usedLokiIds.length > 0 ? p.usedLokiIds.join('|') : "None";
            const h = p.history[p.history.length - 1]; 
            if (h) {
                 this.csvData.push(`${gameId},${h.day},P${p.id},${mainMyth},${p.rank},${h.score},${h.olympus},${h.egypt},${h.nord},${h.celt},${p.totalTurns},${engineTurn},${handValue},${effRatio},${lokiStr}`);
            }
        });

        this.stats.totalGames++;
        if (isDraw) this.stats.draws++;
        else {
            this.stats.wins[winner.id]++;
            
            // ìŠ¹ì ë°ì´í„° ìˆ˜ì§‘ (Elite Meta & Tier Win)
            const wCounts = { olympus:0, egypt:0, nord:0, celt:0 };
            winner.artifacts.forEach(a => wCounts[a.type]++);
            const wMax = Math.max(...Object.values(wCounts));
            
            // ìŠ¹ìì˜ Main Myth ì¬ê³„ì‚° (Top 5 ë¡œì§ê³¼ ë™ì¼ ê¸°ì¤€)
            let winnerMyth = 'mix';
            const leaders = Object.keys(wCounts).filter(k => wCounts[k] === wMax);
            if (leaders.length === 1) winnerMyth = leaders[0];
            else {
                leaders.sort((a,b) => (winner.milestones[a]||999) - (winner.milestones[b]||999));
                if((winner.milestones[leaders[0]]||999) < 999) winnerMyth = leaders[0];
            }
            
            this.stats.winnerRecords.push({ score: winner.score, myth: winnerMyth });
            
            // [New] ìŠ¹ë¥  ëìŠ¤ ë¶„ë¥˜ (2ë‹¨ê³„ vs 3ë‹¨ê³„)
            // ìŠ¹ë¦¬ ì‹ í™”(winnerMyth)ì— ëŒ€í•´, ì‹¤ì œ ë³´ìœ  ê°œìˆ˜(wMax)ê°€ 2ê°œë©´ t2Win, 3ê°œ ì´ìƒì´ë©´ t3Win ì¦ê°€
            if (this.stats.mythStats[winnerMyth]) {
                if (wMax === 2) this.stats.mythStats[winnerMyth].t2Win++;
                else if (wMax >= 3) this.stats.mythStats[winnerMyth].t3Win++;
                // 1ê°œ ì´í•˜ëŠ” Mix í˜¹ì€ ìŠ¹ë¥  ì§‘ê³„ ì œì™¸ (ì¼ë°˜ì ìœ¼ë¡œ Mixë¡œ ë¶„ë¥˜ë¨)
            }
        }

        this.stats.days += game.day;
        let gameTotalScore = 0;
        game.players.forEach(p => {
            gameTotalScore += p.score;
            this.stats.totalSaved += p.metrics.savedRes;
            this.stats.totalWasted += p.metrics.wastedCards;
            this.stats.totalSwaps += p.metrics.celtSwaps;
            this.stats.totalResAcquired += p.metrics.resAcquired;
            this.stats.totalResConsumed += p.metrics.resConsumed;
        });
        this.stats.totalScore += (gameTotalScore / 4);
    }

    updateTopScores(p, myth, counts, grades) {
        // ë°ì´í„° ê°ì²´ ìƒì„±
        const record = {
            score: p.score,
            myth: myth,
            counts: counts, // {olympus: 2, egypt: 1 ...}
            grades: grades  // {Gold: 1, Silver: 2 ...}
        };

        // Top 5 ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
        this.stats.topScores.push(record);
        this.stats.topScores.sort((a, b) => b.score - a.score);
        if (this.stats.topScores.length > 5) {
            this.stats.topScores = this.stats.topScores.slice(0, 5);
        }
    }

    updateLog(msg) {
        const log = document.getElementById('simLog');
        if(log) log.innerText = msg + "\n" + log.innerText;
    }
    
    downloadRawData() {
        if (this.csvData.length <= 1) { alert("ë°ì´í„° ì—†ìŒ"); return; }
        const csvContent = this.csvData.join("\n");
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `divine_forge_v9_8.csv`;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }


}
/*
 * [v10.2 Update Log: Logic & UI Sync]
 *
 * 1. ë°¸ëŸ°ìŠ¤ ì‚°ì¶œ ê³µì‹(Power Score) ë¦¬ë°¸ëŸ°ì‹±
 * - ë¬¸ì œì  ìˆ˜ì •: ê¸°ì¡´ ë¡œì§ì—ì„œ 'ì•ˆì •ì  2ìœ„ ì „ëµ(ìˆœìœ„ ë°©ì–´)'ì´ ì§€ë‚˜ì¹˜ê²Œ ì €í‰ê°€ë˜ëŠ” í˜„ìƒ ë³´ì •.
 * - ë³€ê²½ ì‚¬í•­:
 * a) ìŠ¹ë¥  ê°€ì¤‘ì¹˜ ì¡°ì • (2.0 -> 1.5): ìŠ¹ë¦¬ ì¤‘ìš”ë„ ìœ ì§€í•˜ë˜, ë…ì  ê°€ì¤‘ì¹˜ ì†Œí­ í•˜í–¥.
 * b) ìˆœìœ„ ê°€ì¤‘ì¹˜ ìƒí–¥ (12 -> 20): í‰ê·  ìˆœìœ„ 2.0 ë‹¬ì„± ì‹œ ìœ ì˜ë¯¸í•œ ì ìˆ˜(40ì ) í™•ë³´í•˜ë„ë¡ ë³€ê²½.
 * c) ë…¸ì´ì¦ˆ í•„í„°ë§: ì‹œë®¬ë ˆì´ì…˜ 1,000íšŒ ë¯¸ë§Œ ì‹œ Elite(ê³ ì ) ê°€ì¤‘ì¹˜ 0.5ë°° ì ìš© (ë°ì´í„° ì™œê³¡ ë°©ì§€).
 *
 * 2. UI/ê°€ì´ë“œ í…ìŠ¤íŠ¸ ë™ê¸°í™”
 * - ì ìˆ˜ ìŠ¤ì¼€ì¼ í™•ì¥(Max ~130ì )ì— ë§ì¶° ë°¸ëŸ°ìŠ¤ ë¶•ê´´(Gap) íŒë… ê¸°ì¤€ ì¬ì„¤ì • (20/40).
 * - ì‚¬ìš©ì ê°€ì´ë“œ(<details>) ë‚´ ê³µì‹ ì„¤ëª…ì„ v10.2 ë¡œì§ìœ¼ë¡œ ê°±ì‹ .
 */
// [SimulationManager.prototype.renderStats ìµœì¢… í™•ì •ë³¸ (v11.3: Robust Standard)]

SimulationManager.prototype.renderStats = function() {
    const total = this.stats.totalGames;
    if (total === 0) return;

    // ---------------------------------------------------------
    // 1. í†µê³„ ì§€í‘œ ê³„ì‚° (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    // ---------------------------------------------------------
    const p = 0.25; 
    const stdError = Math.sqrt((p * (1 - p)) / total);

    // Elite(ìƒìœ„ 5%) ì§‘ê³„
    let eliteCounts = { olympus:0, egypt:0, nord:0, celt:0, mix:0 };
    if (this.stats.winnerRecords.length > 0) {
        this.stats.winnerRecords.sort((a, b) => b.score - a.score);
        const cutoffIndex = Math.floor(this.stats.winnerRecords.length * 0.05);
        const eliteSlice = this.stats.winnerRecords.slice(0, Math.max(1, cutoffIndex));
        eliteSlice.forEach(r => { 
            if(eliteCounts[r.myth] !== undefined) eliteCounts[r.myth]++; 
            else eliteCounts.mix++; 
        });
    }
    const getElitePct = (myth) => this.stats.winnerRecords.length > 0 ? ((eliteCounts[myth] / Math.max(1, Math.floor(this.stats.winnerRecords.length * 0.05))) * 100).toFixed(1) : '0.0';

    const mythList = ['olympus', 'egypt', 'nord', 'celt', 'mix'];
    const mythMeta = mythList.map(key => {
        const data = this.stats.mythStats[key];
        const avgRank = data.count > 0 ? (data.rankSum / data.count).toFixed(2) : '4.00';
        
        // ìŠ¹ë¥  ë° Z-Score
        const winRateVal = total > 0 ? (data.t2Win + data.t3Win) / total : 0;
        const winRatePct = (winRateVal * 100).toFixed(1);
        const zScore = (winRateVal - p) / stdError;
        const sigmaStr = (zScore > 0 ? "+" : "") + zScore.toFixed(2) + "Ïƒ";
        
        // Tier íŒì •
        let tierColor = '#7f8c8d'; 
        let tierLabel = 'Balanced';
        if (zScore >= 5.0) { tierColor = '#e74c3c'; tierLabel = 'OP (Tier 0)'; }
        else if (zScore >= 3.0) { tierColor = '#e67e22'; tierLabel = 'Strong (Tier 1)'; }
        else if (zScore <= -5.0) { tierColor = '#2c3e50'; tierLabel = 'Under (Tier 4)'; }
        else if (zScore <= -3.0) { tierColor = '#34495e'; tierLabel = 'Weak (Tier 3)'; }

        const eliteWinRate = parseFloat(getElitePct(key));
        
        // Power Score ê³„ì‚°
        let baseScore = (winRateVal / 0.25) * 75;
        let rankScore = (4 - parseFloat(avgRank)) * 25;
        const eliteWeight = total >= 1000 ? 0.25 : 0.125;
        let eliteBonus = eliteWinRate * eliteWeight;
        let finalScore = baseScore + rankScore + eliteBonus;
        const powerScore = finalScore.toFixed(0);

        return {
            id: key,
            name: {olympus:'ì˜¬ë¦¼í¬ìŠ¤', egypt:'ì´ì§‘íŠ¸', nord:'ë…¸ë¥´ë“œ', celt:'ì¼ˆíŠ¸', mix:'í˜¼í•©'}[key],
            color: {olympus:'var(--c-olympus)', egypt:'var(--c-egypt)', nord:'var(--c-nord)', celt:'var(--c-celt)', mix:'#95a5a6'}[key],
            avgRank, winRatePct, eliteWinRate, powerScore, 
            sigmaStr, tierColor, tierLabel, zScore,
            t2Rate: total > 0 ? ((data.t2Win/total)*100).toFixed(1) : '0.0',
            t3Rate: total > 0 ? ((data.t3Win/total)*100).toFixed(1) : '0.0',
            count: data.count
        };
    });

    mythMeta.sort((a, b) => parseFloat(b.powerScore) - parseFloat(a.powerScore));
    
    // Gap ë¶„ì„
    const pureMyths = mythMeta.filter(m => m.id !== 'mix');
    const topPure = pureMyths.length > 0 ? pureMyths[0] : { powerScore: 0, name: 'None' };
    const botPure = pureMyths.length > 0 ? pureMyths[pureMyths.length - 1] : { powerScore: 0, name: 'None' };
    const scoreGap = (parseFloat(topPure.powerScore) - parseFloat(botPure.powerScore)).toFixed(0);

    // ---------------------------------------------------------
    // [New] ì¼ì¼ í‰ê·  ì ìˆ˜ í…Œì´ë¸” (Rank ìˆœ ì •ë ¬ & ì„±ì¥í­ í‘œì‹œ)
    // ---------------------------------------------------------
    let dailyRows = '';
    
    mythMeta.forEach(meta => {
        // 'mix'ëŠ” ì¼ì¼ í†µê³„ì—ì„œ ì œì™¸
        if (meta.id === 'mix') return;

        const dData = this.stats.mythDailyStats[meta.id];
        
        let tds = '';
        if (dData && dData.count > 0) {
            for(let d=0; d<5; d++) {
                const avg = (dData.sum[d] / dData.count).toFixed(1);
                // ì „ì¼ ëŒ€ë¹„ ì„±ì¥í­(Delta) ê³„ì‚°
                const prev = d > 0 ? (dData.sum[d-1] / dData.count) : 0;
                const diff = (avg - prev).toFixed(1);
                // ì„±ì¥í­ í‘œê¸° (í­ë°œì  ì„±ì¥ ì‹œ ë¶‰ì€ìƒ‰ ê°•ì¡°)
                const diffStr = d > 0 
                    ? `<span style="font-size:9px; color:${diff > 20 ? '#e74c3c' : '#7f8c8d'}; margin-left:2px;">(+${diff})</span>` 
                    : '';
                
                tds += `<td><span style="font-weight:bold; color:#ecf0f1;">${avg}</span>${diffStr}</td>`;
            }
        } else {
            tds = `<td colspan="5" style="color:#555; font-size:11px;">ë°ì´í„° ë¶€ì¡± (í‘œë³¸ ê³¼ì†Œ)</td>`;
        }
        
        dailyRows += `
            <tr style="border-bottom:1px solid #333;">
                <td style="text-align:left; padding:8px; font-weight:bold; color:${meta.color}; border-right:1px solid #333;">
                    ${meta.name} <span style="font-size:9px; color:#666;">(#${4 - parseFloat(meta.avgRank) + 1}ìœ„)</span>
                </td>
                ${tds}
            </tr>
        `;
    });

    const dailyTableHTML = `
        <div class="panel full-width">
            <div class="panel-header" style="color:#e67e22;">ğŸ“… ì‹ í™”ë³„ ì„±ì¥ ê³¡ì„  (ì¼ì¼ í‰ê·  ì ìˆ˜)</div>
            <table class="mini-table" style="text-align:center; font-size:12px; width:100%; border-collapse:collapse;">
                <thead>
                    <tr style="background:#252525; color:#aaa; font-size:11px;">
                        <th style="text-align:left; padding:8px;">Main Myth</th>
                        <th style="padding:6px;">Day 1</th>
                        <th style="padding:6px;">Day 2</th>
                        <th style="padding:6px;">Day 3</th>
                        <th style="padding:6px;">Day 4</th>
                        <th style="padding:6px;">Day 5 (Final)</th>
                    </tr>
                </thead>
                <tbody>
                    ${dailyRows}
                </tbody>
            </table>
        </div>
    `;

    // ---------------------------------------------------------
    // 2. HTML ë Œë”ë§ (UI í†µí•©)
    // ---------------------------------------------------------
    const drawBar = (val, max, color) => `<div style="flex:1; height:6px; background:#333; border-radius:3px; overflow:hidden; margin:0 5px;"><div style="width:${Math.min(100, (val/max)*100)}%; height:100%; background:${color};"></div></div>`;
    const pct = (val) => ((val / total) * 100).toFixed(1);
    const avgGap = (this.stats.totalGap1vs2 / total).toFixed(1);
    const effVal = this.stats.totalResAcquired > 0 ? ((this.stats.totalResConsumed / this.stats.totalResAcquired) * 100).toFixed(1) : 0;
    const effColor = effVal > 85 ? '#2ecc71' : (effVal > 70 ? '#f1c40f' : '#e74c3c');

    let mythRows = '';
    mythMeta.forEach(m => {
        const isFocus = Math.abs(m.zScore) >= 3.0 ? `border: 1px solid ${m.color}; background: rgba(255,255,255,0.05);` : `border-bottom: 1px solid #333;`;
        mythRows += `
            <div style="display:grid; grid-template-columns: 1.5fr 1fr 1.2fr 1fr 0.8fr; padding:10px 8px; align-items:center; ${isFocus} border-radius:4px; margin-bottom:6px;">
                <div style="color:${m.color}; font-weight:bold; display:flex; flex-direction:column;">
                    <span style="font-size:14px;">${m.name}</span>
                    <span style="font-size:10px; color:${m.tierColor}; opacity:0.9;">${m.tierLabel}</span>
                </div>
                <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
                    <div style="font-weight:bold; color:#ecf0f1; font-size:13px;">${m.winRatePct}%</div>
                    <div style="font-size:10px; color:${m.tierColor}; font-weight:bold;">${m.sigmaStr}</div>
                    <div style="font-size:9px; color:#888; margin-top:2px;">${m.t2Rate}% / ${m.t3Rate}%</div>
                </div>
                <div style="display:flex; flex-direction:column; justify-content:center; padding:0 5px;">
                    <div style="display:flex; align-items:center; font-size:11px; color:#aaa;">
                        <span>Rk</span>${drawBar(4 - parseFloat(m.avgRank), 3, m.color)}<span style="color:#fff;">${m.avgRank}</span>
                    </div>
                </div>
                <div style="text-align:center; font-size:12px;">
                    <div title="Elite Win Rate" style="color:#f1c40f;">${m.eliteWinRate}%</div>
                    <div style="font-size:9px; color:#666;">Top 5%</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:15px; font-weight:bold; color:#fff;">${m.powerScore}</div>
                    <div style="font-size:9px; color:#666;">Score</div>
                </div>
            </div>
        `;
    });

    let top5HTML = `<table class="mini-table" style="text-align:center; font-size:11px;"><thead><tr><th>#</th><th>ì ìˆ˜</th><th>ì£¼ë ¥</th><th>ë± êµ¬ì„±</th><th>ë“±ê¸‰</th></tr></thead><tbody>`;
    const kNames = {olympus:'ì˜¬ë¦¼', egypt:'ì´ì§‘', nord:'ë…¸ë¥´', celt:'ì¼ˆíŠ¸', mix:'í˜¼í•©'};
    this.stats.topScores.forEach((rec, i) => {
         const mColor = {olympus:'var(--c-olympus)', egypt:'var(--c-egypt)', nord:'var(--c-nord)', celt:'var(--c-celt)', mix:'#aaa'}[rec.myth];
         let deckStr = [];
         for(const [key, val] of Object.entries(rec.counts)) { if(val > 0) deckStr.push(`${kNames[key]||key} ${val}`); }
         let gradeStr = [];
         if(rec.grades.Gold > 0) gradeStr.push(`<span style="color:#f1c40f">ğŸ¥‡${rec.grades.Gold}</span>`);
         if(rec.grades.Silver > 0) gradeStr.push(`<span style="color:#bdc3c7">ğŸ¥ˆ${rec.grades.Silver}</span>`);
         if(rec.grades.Bronze > 0) gradeStr.push(`<span style="color:#cd7f32">ğŸ¥‰${rec.grades.Bronze}</span>`);
         top5HTML += `<tr><td>${i+1}</td><td style="color:#e67e22; font-weight:bold;">${rec.score}</td><td style="color:${mColor}; font-weight:bold;">${kNames[rec.myth]||rec.myth}</td><td style="color:#ddd;">${deckStr.join(', ')}</td><td>${gradeStr.length>0?gradeStr.join(' '):'-'}</td></tr>`;
    });
    top5HTML += `</tbody></table>`;

    const html = `
        <div style="margin-bottom: 15px; display:flex; justify-content:space-between; align-items:end;">
            <div><h2 style="margin:0; font-size:20px;">ğŸ“Š ë°¸ëŸ°ìŠ¤ ë¶„ì„ (N=${total})</h2></div>
            <button onclick="simManager.downloadRawData()" class="btn-primary" style="padding:4px 8px; font-size:11px;">ğŸ“¥ Raw CSV</button>
        </div>

        <details style="background:#2c3e50; border:1px solid #34495e; border-radius:4px; padding:8px; margin-bottom:15px; cursor:pointer;">
            <summary style="font-weight:bold; color:#f1c40f; outline:none;">â“ ë°¸ëŸ°ìŠ¤ ì ìˆ˜(Score) ì‚°ì¶œ ì›ë¦¬ (v10.4)</summary>
            <div style="margin-top:10px; font-size:12px; color:#ecf0f1; line-height:1.6; border-top:1px dashed #555; padding-top:8px;">
                <div style="margin-bottom:8px;">
                    <b style="color:#3498db;">ğŸ“ ê³ ì‹ ë¢°ë„(High-N) ì„±ëŠ¥ ì§€ìˆ˜:</b>
                    <div style="background:#222; padding:4px; border-radius:3px; margin-top:4px; font-family:monospace;">
                        (ìŠ¹ë¥  / 25% Ã— 75) + (ìˆœìœ„ì ìˆ˜ Ã— 25) + (ê³ ì ë³´ë„ˆìŠ¤)
                    </div>
                    <div style="font-size:11px; color:#aaa; margin-top:2px;">
                        * <b>Ratio ê¸°ë°˜:</b> 1ë§Œ íšŒ ì´ìƒì˜ ì‹œë®¬ë ˆì´ì…˜ì—ì„œë„ ì ìˆ˜ ì¸í”Œë ˆì´ì…˜ ì—†ì´ ì„±ëŠ¥ ë¹„ìœ¨ì„ ì •í™•íˆ ë°˜ì˜í•©ë‹ˆë‹¤.<br>
                        * <b>ìˆœìœ„ ë³´ì •:</b> ìˆœìœ„ ë°©ì–´(2~3ìœ„) ëŠ¥ë ¥ì„ ì ìˆ˜ì— ë°˜ì˜í•˜ì—¬, ìŠ¹ë¥ ì´ ë‚®ì•„ë„ ì•ˆì •ì ì¸ ë±ì„ ì •ë‹¹í•˜ê²Œ í‰ê°€í•©ë‹ˆë‹¤.<br>
                        * <b>í‰ê· :</b> ì•½ 118ì  / <b>OP:</b> 150ì â†‘ / <b>Under:</b> 80ì â†“
                    </div>
                </div>
                <div>
                    <div style="margin-top:5px; background:#222; padding:4px; text-align:center;">
                        [${topPure.name} vs ${botPure.name}] ì„±ëŠ¥ ê²©ì°¨: <b style="color:${scoreGap > 40 ? '#e74c3c' : (scoreGap > 20 ? '#f1c40f' : '#2ecc71')}">${scoreGap}ì </b>
                    </div>
                </div>
            </div>
        </details>

        <div class="dashboard-grid">
            <div class="panel full-width">
                <div class="panel-header" style="color:#3498db;">âš¡ ì‹ í™”ë³„ ì„±ëŠ¥ ë¶„ì„ (Ratio v2)</div>
                <div style="display:grid; grid-template-columns: 1.5fr 1fr 1.2fr 1fr 0.8fr; padding:0 8px 5px; font-size:10px; color:#666; border-bottom:1px solid #333;">
                    <div>ì‹ í™” (Tier)</div><div>ìŠ¹ë¥  (Ïƒ / Depth)</div><div>í‰ê·  ìˆœìœ„</div><div>ê³ ì (Elite)</div><div>Score</div>
                </div>
                ${mythRows}
            </div>
            
            ${dailyTableHTML}

            <div class="panel full-width" style="background:#222;">
                 <div class="panel-header" style="color:#f39c12;">ğŸ† Top 5 ê³ ë“ì  ë± ë¶„ì„</div>
                 ${top5HTML}
            </div>
            <div class="panel half-width">
                <div class="panel-header">ğŸ“ˆ í”Œë ˆì´ì–´ ìŠ¹ë¥ </div>
                ${['#e74c3c', '#3498db', '#2ecc71', '#f1c40f'].map((c, i) => `<div class="stat-row"><span class="stat-label">P${i+1}</span><div class="bar-wrapper"><div class="bar-fill" style="width:${pct(this.stats.wins[i+1])}%; background:${c};"></div></div><span class="stat-value" style="width:40px;">${pct(this.stats.wins[i+1])}%</span></div>`).join('')}
                <div class="stat-row" style="margin-top:5px;"><span class="stat-label">Draw</span><span class="stat-value">${pct(this.stats.draws)}%</span></div>
            </div>
            <div class="panel half-width">
                <div class="panel-header">ğŸ’° ê²½ì œ íš¨ìœ¨ì„±</div>
                <div style="text-align:center; margin-bottom:10px;">
                    <div style="font-size:11px; color:#aaa;">ìì› ì†Œëª¨ íš¨ìœ¨</div>
                    <div style="font-size:24px; font-weight:bold; color:${effColor};">${effVal}%</div>
                </div>
                <div class="stat-row"><span class="stat-label">í‰ê·  ê²Œì„ ê¸¸ì´</span><span class="stat-value">${(this.stats.days / total).toFixed(1)} ì¼</span></div>
                <div class="stat-row"><span class="stat-label">ì „ì²´ í‰ê·  ì ìˆ˜</span><span class="stat-value">${(this.stats.totalScore / total).toFixed(1)} ì </span></div>
                <div class="stat-row"><span class="stat-label">1-2ìœ„ í‰ê·  ê²©ì°¨</span><span class="stat-value">${avgGap} ì </span></div>
            </div>
            <div class="panel full-width">
                <div class="panel-header">ğŸ› ï¸ íŠ¹ìˆ˜ ëŠ¥ë ¥ í™œìš© (í‰ê· )</div>
                <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; text-align:center;">
                    <div><div style="color:var(--c-olympus); font-weight:bold;">ì˜¬ë¦¼í¬ìŠ¤</div><div style="font-size:16px;">${(this.stats.totalSaved / total).toFixed(1)}</div><div style="font-size:10px; color:#aaa;">ìì› ì ˆì•½</div></div>
                    <div><div style="color:var(--c-egypt); font-weight:bold;">ì´ì§‘íŠ¸</div><div style="font-size:16px;">-</div><div style="font-size:10px; color:#aaa;">(íŒ¨ì‹œë¸Œ)</div></div>
                    <div><div style="color:var(--c-nord); font-weight:bold;">ë…¸ë¥´ë“œ</div><div style="font-size:16px;">${(this.stats.totalWasted / total).toFixed(1)}</div><div style="font-size:10px; color:#aaa;">ë²„ë ¤ì§„ ì¹´ë“œ</div></div>
                    <div><div style="color:var(--c-celt); font-weight:bold;">ì¼ˆíŠ¸</div><div style="font-size:16px;">${(this.stats.totalSwaps / total).toFixed(1)}</div><div style="font-size:10px; color:#aaa;">ë³€í™˜ íšŸìˆ˜</div></div>
                </div>
            </div>
        </div>
    `;

    document.getElementById('mainStats').style.display = 'none';
    document.getElementById('detailStats').innerHTML = html;
};
/*
 ==================================================================================
 [Patch Note: v9.1 Fixed - Celt Logic & UI Sync]
 ==================================================================================

 1. [UI] ì‚¬ìš©ì ì•ˆë‚´ ë¬¸êµ¬ ìˆ˜ì • (HTML)
    - ëŒ€ìƒ: ì¼ˆíŠ¸ ë³€í™˜(Convert) ë° ë©´ì œ(Free) ë ˆë²¨ ì…ë ¥ í•„ë“œ
    - ë³€ê²½: "ì‰¼í‘œ êµ¬ë¶„(ì˜ˆ: 2,3)" â†’ "ìµœì†Œ ë ˆë²¨(ì˜ˆ: 2)" ë¡œ Placeholder ë° ê°€ì´ë“œ í…ìŠ¤íŠ¸ ë³€ê²½.
    - ì´ìœ : ì‚¬ìš©ìê°€ ë‹¨ì¼ ìˆ«ìë¥¼ ì…ë ¥í•˜ë„ë¡ ìœ ë„í•˜ì—¬ ì„¤ì • í˜¼ë€ ë°©ì§€.

 2. [Config] ì„¤ì • ì ìš© ë¡œì§ ë³€ê²½ (applyUserBalance)
    - ëŒ€ìƒ: BALANCE_CONFIG.CELT.LVL_CONVERT, LVL_FREE
    - ë³€ê²½: ë°°ì—´ ì „ì²´ ì €ì¥ ë°©ì‹ â†’ ì²« ë²ˆì§¸ ì…ë ¥ê°’(index 0)ì„ Threshold(ì •ìˆ˜)ë¡œ ì €ì¥.
    - ì½”ë“œ: const convertArr = ...; BALANCE_CONFIG.CELT.LVL_CONVERT = convertArr[0];

 3. [Core] í•µì‹¬ ì—”ì§„ ë¡œì§ ë³€ê²½ (Threshold ì ìš©)
    - ëŒ€ìƒ: 
      a) Game.prototype.aiCalculateTargetValue (ê°€ì¹˜ íŒë‹¨)
      b) Game.prototype.processCraftTransaction (ì œì‘ ì‹¤í–‰)
      c) Game.prototype.aiActionGather (ìì› ìˆ˜ì§‘)
    - ë³€ê²½: .includes(count) â†’ (count >= CONFIG_VAL)
    - íš¨ê³¼: ì¼ˆíŠ¸ ìœ ë¬¼ì´ ì„¤ì •ëœ ë ˆë²¨(ì˜ˆ: 3)ì„ ì´ˆê³¼í•˜ì—¬ 4ê°œ, 5ê°œê°€ ë˜ì–´ë„
           ë³€í™˜ ë° ë©´ì œ ëŠ¥ë ¥ì´ ë¹„í™œì„±í™”ë˜ì§€ ì•Šê³  ì§€ì†ì ìœ¼ë¡œ ìœ ì§€ë¨.
           ('ë©´ì œ'ê°€ 'ë³€í™˜'ë³´ë‹¤ ìƒìœ„ ê°œë…ì´ë¯€ë¡œ ìš°ì„ ìˆœìœ„ ë¡œì§ì— ë”°ë¼ ì¶©ëŒ ì—†ìŒ)

 ì‘ì„±ì: Divine Forge Main Developer
 ==================================================================================
*/
const simManager = new SimulationManager();
</script>
</body>
</html>
