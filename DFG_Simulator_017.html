<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Divine Forge: Balance Simulator (Integrated)</title>
    <style>
        body { font-family: 'Consolas', 'Monaco', monospace; background: #111; color: #eee; padding: 20px; line-height: 1.4; }
        h1, h2 { color: #f1c40f; margin-bottom: 10px; }
        
        .control-panel { background: #222; border: 1px solid #444; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .control-group { margin-bottom: 10px; display: flex; gap: 10px; align-items: center; }
        
        button { padding: 8px 16px; background: #2980b9; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-family: inherit; }
        button:hover { background: #3498db; }
        button:disabled { background: #555; cursor: not-allowed; }
        button.stop-btn { background: #c0392b; }
        
        
        
        select, input { padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        
        .grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        
        .log-area { height: 300px; overflow-y: scroll; background: #000; border: 1px solid #333; padding: 10px; font-size: 12px; color: #aaa; white-space: pre-wrap; }
        .stats-area { background: #1a1a1a; border: 1px solid #444; padding: 15px; border-radius: 8px; }
        
        table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px; }
        th, td { border: 1px solid #444; padding: 6px; text-align: center; }
        th { background: #333; color: #f1c40f; }
        
        .highlight { color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <h1>âš–ï¸ Divine Forge Simulator v9.1 (Fixed)</h1>

    
       <div class="control-panel">
    <div class="control-group">
        <label>ì‹œë®¬ë ˆì´ì…˜ íšŸìˆ˜:</label>
        <select id="simCount">
            <option value="100">100íšŒ</option>
            <option value="1000">1,000íšŒ</option>
            <option value="10000" selected>10,000íšŒ</option>
        </select>
        <button onclick="simManager.startSimulation()">â–¶ ì¶”ê°€ ì‹¤í–‰ (ëˆ„ì )</button>
        <button class="stop-btn" onclick="simManager.stopSimulation()">â¹ ì¤‘ì§€</button>
        
        <div style="width: 20px;"></div> <button onclick="simManager.resetStats()" style="background: #e67e22;">ğŸ”„ í†µê³„ ì´ˆê¸°í™”</button>
    </div>
    
    <div class="control-group">
        <span>ì‹ í™” ë°°ì •(P1~P4):</span>
        <select id="p1Myth">
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p2Myth">
            <option value="egypt" selected>ì´ì§‘íŠ¸</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p3Myth">
            <option value="nord" selected>ë…¸ë¥´ë“œ</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p4Myth">
            <option value="celt" selected>ì¼ˆíŠ¸</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
        </select>
    </div>

    <details style="margin-top: 15px; background: #2c3e50; padding: 10px; border-radius: 4px; border: 1px solid #444;">
        <summary style="cursor: pointer; font-weight: bold; color: #ecf0f1;">âš™ï¸ ë°¸ëŸ°ìŠ¤ íŒŒë¼ë¯¸í„° ë¯¸ì„¸ ì¡°ì • (í´ë¦­í•˜ì—¬ ì—´ê¸°)</summary>
        
        <div class="control-group" style="margin-top: 10px; padding: 10px; border: 1px solid #2ecc71; border-radius: 4px; background: #1a252f; flex-direction: column; align-items: flex-start;">
            <div style="width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <span style="color: #2ecc71; font-weight: bold;">â˜˜ï¸ ì¼ˆíŠ¸ ëŠ¥ë ¥ ì»¤ìŠ¤í…€ (Advanced)</span>
                <label style="font-size: 11px; color: #aaa; cursor: pointer;">
                    <input type="checkbox" id="celtMimicToggle" checked> ë¯¸ë¯¹(3ë‹¨ê³„) í™œì„±
                </label>
            </div>
        
            <div style="width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div>
                    <label style="font-size: 11px; display:block; color: #ddd;">êµí™˜ íšŸìˆ˜ (0~3ë‹¨ê³„):</label>
                    <input type="text" id="conf_celt_swap" value="0,1,2,3" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #555; color: white; padding: 4px;">
                </div>
                <div>
                    <label style="font-size: 11px; display:block; color: #ddd;">ë³€í™˜(Any) ë°œë™ ë ˆë²¨:</label>
                    <input type="text" id="conf_celt_lvl_convert" value="2" placeholder="ì˜ˆ: 1,2,3" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #27ae60; color: white; padding: 4px;">
                </div>
                <div style="grid-column: span 2;">
                    <label style="font-size: 11px; display:block; color: #ddd;">ë©´ì œ(Free) ë°œë™ ë ˆë²¨:</label>
                    <input type="text" id="conf_celt_lvl_free" value="3" placeholder="ì˜ˆ: 3" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #27ae60; color: white; padding: 4px;">
                </div>
            </div>
            <div style="font-size: 10px; color: #7f8c8d; margin-top: 5px;">
                * ì‰¼í‘œ(,)ë¡œ êµ¬ë¶„í•˜ì—¬ ì—¬ëŸ¬ ë ˆë²¨ ì§€ì • ê°€ëŠ¥ (ì˜ˆ: 1,2,3 ì…ë ¥ ì‹œ ëª¨ë“  ë‹¨ê³„ì—ì„œ ë°œë™)
            </div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
            <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #00bfff;">â˜ï¸ ì˜¬ë¦¼í¬ìŠ¤ (ì¬ë£Œ í• ì¸)</h3>
                <label style="font-size: 11px;">ë‹¨ê³„ë³„ í• ì¸ëŸ‰ (0,1,2,3ë‹¨ê³„):</label>
                <input type="text" id="conf_olympus_discount" value="0,2,5,12" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
            </div>

            <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #9b59b6;">â„ï¸ ë…¸ë¥´ë“œ (ìˆ˜ì§‘ ê°•í™”)</h3>
                <label style="font-size: 11px;">í•©ê³„ ì œí•œ (1,2,3ë‹¨ê³„):</label>
                <input type="text" id="conf_nord_sum" value="6,9,14" style="width: 100%; box-sizing: border-box; margin-bottom: 5px; background: #222; border: 1px solid #555; color: white;">
                <label style="font-size: 11px;">ì¥ìˆ˜ ì œí•œ (1,2,3ë‹¨ê³„):</label>
                <input type="text" id="conf_nord_count" value="2,2,3" style="width: 100%; box-sizing: border-box; margin-bottom: 5px; background: #222; border: 1px solid #555; color: white;">
                <label style="font-size: 11px;">ìˆ˜ì§‘ ì†ë„(í„´ìˆ˜ ê³„ì‚°ìš©):</label>
                <input type="text" id="conf_nord_speed" value="3.5,7.0,7.0,10.5" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
            </div>
            
            <div style="background: #34495e; padding: 10px; border-radius: 4px; grid-column: span 2; border: 1px dashed #f1c40f;">
                <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #f1c40f;">ğŸ‘ï¸ ì´ì§‘íŠ¸ (í–‰ë™ ë¹„ìš© ê°ì†Œ ìƒì„¸ ì„¤ì •)</h3>
                <table style="width: 100%; font-size: 11px; border-collapse: collapse; color: #eee;">
                    <tr style="border-bottom: 1px solid #555;">
                        <th style="text-align: left; padding: 4px; color: #aaa;">Level</th>
                        <th style="padding: 4px;">ì˜ˆì•½(Reserve)</th>
                        <th style="padding: 4px;">ìì›(Res)</th>
                        <th style="padding: 4px;">ì¶•ë³µ(Bless)</th>
                        <th style="padding: 4px;">ì œì‘(Craft)</th>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV1</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_r" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV2</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_res" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV3</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_bls" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_art" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                </table>
                <div style="font-size: 11px; color: #aaa; margin-top: 5px; text-align: right;">* ê° ë ˆë²¨ ë„ë‹¬ ì‹œ í•´ë‹¹ ìˆ˜ì¹˜ë§Œí¼ ë¹„ìš©ì´ <b>ì¶”ê°€ë¡œ</b> ê°ì†Œí•©ë‹ˆë‹¤.</div>
            </div>
        </div>
        
        <div style="margin-top: 10px; text-align: right; font-size: 11px; color: #95a5a6;">
        </div>
    </details>
    <div id="progressBar" style="width:0%; height:4px; background:#2ecc71; transition:width 0.2s; margin-top: 10px;"></div>
</div>
<div class="log-area" id="simLog" style="margin-bottom: 20px;">
        [System] ì¤€ë¹„ ì™„ë£Œ. ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•˜ë ¤ë©´ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.
    </div>

    <div id="mainStats" style="font-size: 24px; font-weight: bold; color: #f1c40f; margin-bottom: 10px;"></div>
    <div id="detailStats"></div>
<script>
// ==================================================================================
// [Part 1] Configuration & Databases (002 Ver. Integrated)
// ==================================================================================

const CONFIG = {
    MAX_TIME: 12,
    MAX_DAYS: 5,
    HAND_LIMIT: 8,
    COST: { RES: 3, BLESS: 2, ART: 2, RESERVE: 1, SWAP: 1 }
};

// 002 ë²„ì „ì˜ ë°¸ëŸ°ìŠ¤ ì»¨í”¼ê·¸ ì ìš©
// [Part 1] Config & Apply Function (ê¸°ì¡´ BALANCE_CONFIG, applyUserBalance ì§€ìš°ê³  ëŒ€ì²´)
const BALANCE_CONFIG = {
    EGYPT: [
        { RESERVE: 1, RES: 0, BLESS: 0, ART: 0 },
        { RESERVE: 0, RES: 1, BLESS: 0, ART: 0 },
        { RESERVE: 0, RES: 0, BLESS: 1, ART: 1 }
    ],
    NORD: { LIMIT_SUM: [6, 9, 14], LIMIT_COUNT: [2, 2, 3], GATHER_SPEED: [3.5, 7.0, 7.0, 10.5] },
    OLYMPUS: { DISCOUNT: [0, 2, 5, 12] },
    CELT: { 
        SWAP_LIMIT: [0, 1, 2, 3],
        LVL_CONVERT: [2], 
        LVL_FREE: [3]
    }
};

function applyUserBalance() {
    try {
        const getElVal = (id) => { const el = document.getElementById(id); return el && el.value.trim() !== "" ? (parseInt(el.value) || 0) : 0; };
        const getArrVal = (id) => { const el = document.getElementById(id); return el && el.value.trim() !== "" ? el.value.split(',').map(v => Number(v.trim())).filter(n => !isNaN(n)) : []; };

        // [Safe Cache] DOM ìƒíƒœë¥¼ ì „ì—­ ì„¤ì •ì— ì €ì¥ (ë£¨í”„ ë‚´ ì ‘ê·¼ ì œê±°)
        const mimicToggle = document.getElementById('celtMimicToggle');
        // ì²´í¬ë°•ìŠ¤ê°€ ì—†ê±°ë‚˜(null) ì²´í¬ëœ ê²½ìš° true
        BALANCE_CONFIG.CELT.MIMIC_ENABLED = mimicToggle ? mimicToggle.checked : true;

        const olympusVal = getArrVal('conf_olympus_discount');
        if (olympusVal.length > 0) BALANCE_CONFIG.OLYMPUS.DISCOUNT = olympusVal;
        
        BALANCE_CONFIG.EGYPT = [
            { RESERVE: getElVal('conf_egypt_l1_r'), RES: getElVal('conf_egypt_l1_res'), BLESS: getElVal('conf_egypt_l1_bls'), ART: getElVal('conf_egypt_l1_art') },
            { RESERVE: getElVal('conf_egypt_l2_r'), RES: getElVal('conf_egypt_l2_res'), BLESS: getElVal('conf_egypt_l2_bls'), ART: getElVal('conf_egypt_l2_art') },
            { RESERVE: getElVal('conf_egypt_l3_r'), RES: getElVal('conf_egypt_l3_res'), BLESS: getElVal('conf_egypt_l3_bls'), ART: getElVal('conf_egypt_l3_art') }
        ];

        const nordSum = getArrVal('conf_nord_sum'); if (nordSum.length > 0) BALANCE_CONFIG.NORD.LIMIT_SUM = nordSum;
        const nordCount = getArrVal('conf_nord_count'); if (nordCount.length > 0) BALANCE_CONFIG.NORD.LIMIT_COUNT = nordCount;
        const nordSpeed = getArrVal('conf_nord_speed'); if (nordSpeed.length > 0) BALANCE_CONFIG.NORD.GATHER_SPEED = nordSpeed;

        const celtSwap = getArrVal('conf_celt_swap'); if (celtSwap.length > 0) BALANCE_CONFIG.CELT.SWAP_LIMIT = celtSwap;
        BALANCE_CONFIG.CELT.LVL_CONVERT = getArrVal('conf_celt_lvl_convert');
        BALANCE_CONFIG.CELT.LVL_FREE = getArrVal('conf_celt_lvl_free');

        console.log("[System] Balance & Cache Applied. Mimic:", BALANCE_CONFIG.CELT.MIMIC_ENABLED);
    } catch (e) { console.error("Balance Apply Error:", e); }
}
const START_RULE = [
    { res: 0, bless: 0, loki: 0, score: 0 }, // P1
    { res: 0, bless: 0, loki: 0, score: 0 }, // P2
    { res: 0, bless: 0, loki: 0, score: 0 }, // P3
    { res: 0, bless: 0, loki: 0, score: 0 }  // P4
];

const RES_NAMES = { adamantite: "ì•„ë‹¤ë§Œíƒ€ì´íŠ¸", mithril: "ë¯¸ìŠ¤ë¦´", dragonBone: "ìš©ì˜ ë¼ˆ", starFragment: "ë³„ì˜ íŒŒí¸" };
const TYPE_NAMES = { nord: "ë…¸ë¥´ë“œ", egypt: "ì´ì§‘íŠ¸", olympus: "ì˜¬ë¦¼í¬ìŠ¤", celt: "ì¼ˆíŠ¸" };

// 002 ë²„ì „ì˜ ìœ ë¬¼ ë°ì´í„°ë² ì´ìŠ¤ (ê·¸ëŒ€ë¡œ ìœ ì§€)
const ARTIFACT_DB = [
    {name:"ê·€ê²ŒìŠ¤ì˜ ë°˜ì§€", type:"olympus", score:4, grade:"Bronze", cost:{adamantite:3, starFragment:3}},
    {name:"í—¤ë¥´ë©”ìŠ¤ì˜ ì‹ ë°œ", type:"olympus", score:5, grade:"Bronze", cost:{dragonBone:3, mithril:4}},
    {name:"í¬ë¦¬ì…€ë¼ì¹´í† ìŠ¤", type:"olympus", score:6, grade:"Bronze", cost:{mithril:3, starFragment:5}},
    {name:"í€´ë„¤ì—", type:"olympus", score:10, grade:"Silver", cost:{dragonBone:2, mithril:4, starFragment:5}},
    {name:"ì¼€ìŠ¤í† ìŠ¤ íˆë§ˆìŠ¤", type:"olympus", score:12, grade:"Silver", cost:{adamantite:4, starFragment:9}},
    {name:"íŠ¸ë¼ì•„ì´ë‚˜", type:"olympus", score:12, grade:"Silver", cost:{adamantite:2, dragonBone:7, mithril:3}},
    {name:"ì•„í´ë¡ ì˜ ë¦¬ë¼", type:"olympus", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:3, starFragment:6}},
    {name:"ì•„ì´ê¸°ìŠ¤", type:"olympus", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:8}},
    {name:"íí”¼ë“œì˜ í™”ì‚´", type:"olympus", score:16, grade:"Silver", cost:{adamantite:5, dragonBone:3, mithril:7, starFragment:2}},
    {name:"ì•„ë‹¤ë§ŒíŠ¸", type:"olympus", score:16, grade:"Silver", cost:{adamantite:12, dragonBone:2, starFragment:3}},
    {name:"ì•„ìŠ¤íŠ¸ë¼í˜", type:"olympus", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:5, mithril:5, starFragment:12}},
    {name:"ë§ˆì•„íŠ¸ì˜ ê¹ƒí„¸", type:"egypt", score:4, grade:"Bronze", cost:{dragonBone:3, mithril:3}},
    {name:"ì˜¤ì‹œë¦¬ìŠ¤ì˜ ì™•í™€", type:"egypt", score:5, grade:"Bronze", cost:{adamantite:2, mithril:6}},
    {name:"ì•„ëˆ„ë¹„ìŠ¤ì˜ ì €ìš¸", type:"egypt", score:6, grade:"Bronze", cost:{adamantite:2, dragonBone:6}},
    {name:"ì„¸íŠ¸ì˜ ì „ìŸ ë„ë¼", type:"egypt", score:10, grade:"Silver", cost:{adamantite:6, dragonBone:2, mithril:2}},
    {name:"ì„¸í¬ë©”íŠ¸ì˜ ì—­ë³‘", type:"egypt", score:12, grade:"Silver", cost:{adamantite:3, dragonBone:6, mithril:3}},
    {name:"í† íŠ¸ì˜ ì„œ", type:"egypt", score:12, grade:"Silver", cost:{dragonBone:2, mithril:6, starFragment:5}},
    {name:"ì•„í©ì˜ ì´ë¹¨", type:"egypt", score:14, grade:"Silver", cost:{dragonBone:7, mithril:6, starFragment:2}},
    {name:"í˜¸ë£¨ìŠ¤ì˜ ëˆˆ", type:"egypt", score:14, grade:"Silver", cost:{adamantite:4, mithril:6, starFragment:5}},
    {name:"í¬ëˆ”ì˜ ë¬¼ë ˆ", type:"egypt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:2, starFragment:5}},
    {name:"ë§Œì•¼ë¥´íŠ¸", type:"egypt", score:16, grade:"Silver", cost:{dragonBone:5, mithril:4, starFragment:8}},
    {name:"ëˆ„ì˜ í•­ì•„ë¦¬", type:"egypt", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:14, mithril:2, starFragment:6}},
    {name:"ë“œë¼ìš°í”„ë‹ˆë¥´", type:"nord", score:4, grade:"Bronze", cost:{dragonBone:4, mithril:2}},
    {name:"ë¸Œë¦¬ì‹±ê°€ë©˜", type:"nord", score:5, grade:"Bronze", cost:{mithril:3, starFragment:4}},
    {name:"ë©”ê¸´ìš”ë¥´ë“œ", type:"nord", score:6, grade:"Bronze", cost:{adamantite:9}},
    {name:"ê·¸ëŒ", type:"nord", score:10, grade:"Silver", cost:{dragonBone:3, mithril:5, starFragment:3}},
    {name:"ìŠ¤ë°œë¦°", type:"nord", score:12, grade:"Silver", cost:{adamantite:5, mithril:8}},
    {name:"ê²”ë¼ë¥´ í˜¸ë¥¸", type:"nord", score:12, grade:"Silver", cost:{dragonBone:5, mithril:5, starFragment:3}},
    {name:"ë‹¤ì¸ìŠ¬ë ˆì´í”„", type:"nord", score:14, grade:"Silver", cost:{adamantite:5, mithril:3, starFragment:7}},
    {name:"ê¶ë‹ˆë¥´", type:"nord", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:2, starFragment:6}},
    {name:"ê¸€ë ˆì´í”„ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:3, dragonBone:5, starFragment:8}},
    {name:"ë¬ ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:6, mithril:7, starFragment:4}},
    {name:"ë ˆë°”í…Œì¸", type:"nord", score:24, grade:"Gold", cost:{adamantite:11, dragonBone:4, mithril:5, starFragment:6}},
    {name:"ì˜¤í•œ", type:"celt", score:4, grade:"Bronze", cost:{adamantite:2, starFragment:4}},
    {name:"ëˆ„ì•„ë‹¤ì˜ ì€íŒ”", type:"celt", score:5, grade:"Bronze", cost:{dragonBone:4, starFragment:2}},
    {name:"ë‹¤ê·¸ë‹¤ì˜ ì†¥", type:"celt", score:6, grade:"Bronze", cost:{dragonBone:4, starFragment:4}},
    {name:"ë§ˆë‚˜ë‚œì˜ í™©ê¸ˆ ê°‘ì˜·", type:"celt", score:10, grade:"Silver", cost:{adamantite:7, starFragment:4}},
    {name:"ì¹¼ë¼ë“œë³¼ê·¸", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, mithril:5, starFragment:2}},
    {name:"í˜ë¥´ë””ì•„ì˜ ë¿”ê°€ì£½", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, dragonBone:6, mithril:2}},
    {name:"ê²Œ ë³¼ê·¸", type:"celt", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:4, mithril:4}},
    {name:"ê²Œ ë‹¤ëŸ¬ê·¸", type:"celt", score:14, grade:"Silver", cost:{dragonBone:8, starFragment:7}},
    {name:"í”„ë¼ê°€ë¼í", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:4, mithril:8}},
    {name:"ê²Œ ë¹„ì–´", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:4, starFragment:2}},
    {name:"ë¸Œë¥˜ë‚˜í¬", type:"celt", score:24, grade:"Gold", cost:{dragonBone:5, mithril:17, starFragment:3}}
];

// 002 ë²„ì „ì˜ ë¡œí‚¤ DB (32ì¥ í’€ ì„¸íŠ¸)
const LOKI_DB = [
    {id:1,name:"êµ¬ë¶€ëŸ¬ì§„ ì‹œê³—ë°”ëŠ˜",desc:"ì‚¬ìš© ì‹œ ì‹œê°„ -1H",type:"active_time", count:4},
    {id:2,name:"ë§ê°ì˜ ì£¼íŒ",desc:"êµí™˜",type:"active_swap", count:1},
    {id:3,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì¼ˆíŠ¸",type:"bless_split",tags:['nord','celt'], count:1},
    {id:4,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì´ì§‘íŠ¸",type:"bless_split",tags:['nord','egypt'], count:1},
    {id:5,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì˜¬ë¦¼í¬ìŠ¤",type:"bless_split",tags:['nord','olympus'], count:1},
    {id:6,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì´ì§‘íŠ¸",type:"bless_split",tags:['olympus','egypt'], count:1},
    {id:7,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì´ì§‘íŠ¸ / ì¼ˆíŠ¸",type:"bless_split",tags:['egypt','celt'], count:1},
    {id:8,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì¼ˆíŠ¸",type:"bless_split",tags:['olympus','celt'], count:1},
    {id:9,name:"í˜¼ëˆì˜ ì±„ì„ë§ì¹˜",desc:"ì‹œì¥ êµì²´",type:"active_reset", count:1},
    {id:10,name:"ë¶€ì„œì§„ íšŒì¤‘ì‹œê³„",desc:"ë¬´ë£Œ ì œì‘",type:"passive_free", count:1},
    {id:11,name:"ê³„ìŠ¹ìì˜ ë¬¸ì¥",desc:"+2ì ",type:"instant_score", count:4},
    {id:12,name:"ë¯¸ë˜ ì¼ê¸°",desc:"ë¯¸ë˜ ì—¿ë³´ê¸°",type:"active_peek", count:1},
    {id:13,name:"ê²€ì€ ì£¼ì‚¬ìœ„",desc:"ë“œë¡œìš°",type:"active_draw", count:1},
    {id:14,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'dragonBone',val:4}], count:1},
    {id:15,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'mithril',val:4}], count:1},
    {id:16,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'adamantite',val:4}], count:1},
    {id:17,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'dragonBone',val:4}], count:1},
    {id:18,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'mithril',val:4}], count:1},
    {id:19,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'dragonBone',val:4},{type:'mithril',val:4}], count:1},
    {id:20,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'dragonBone',val:2}], count:1},
    {id:21,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'mithril',val:2}], count:1},
    {id:22,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'mithril',val:2}], count:1},
    {id:23,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'starFragment',val:2}], count:1},
    {id:24,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'starFragment',val:2},{type:'mithril',val:2}], count:1},
    {id:25,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'starFragment',val:2}], count:1},
    {id:26,name:"íŒŒê´´ëœ ì„±ë°°",desc:"ì¶•ë³µ êµì²´",type:"active_reset_bless", count:1}
];

class Card {
    constructor(cat, type, val = null, extra = null) {
        this.cat = cat;
        this.type = type; 
        this.val = val; 
        this.extra = extra;
        this.id = Math.random().toString(36).substr(2, 9);
    }
}

class Deck {
    constructor(cat) {
        this.cat = cat;
        this.cards = [];
        this.discardPile = [];
        this.init();
    }

    init() {
        if (this.cat === 'resource') {
            const types = Object.keys(RES_NAMES);
            const vals = [2, 3, 4, 5, 6, 7];
            types.forEach(t => vals.forEach(v => {
                for (let i = 0; i < 3; i++) this.cards.push(new Card('resource', t, v));
            }));
        } else if (this.cat === 'blessing') {
            const types = Object.keys(TYPE_NAMES);
            types.forEach(t => {
                for (let i = 0; i < 8; i++) this.cards.push(new Card('blessing', t));
            });
        } else if (this.cat === 'artifact') {
            ARTIFACT_DB.forEach(art => this.cards.push({ ...art })); 
        } else if (this.cat === 'loki') {
            LOKI_DB.forEach(def => {
                for(let i=0; i<def.count; i++) {
                    this.cards.push(new Card('loki', 'loki', null, def));
                }
            });
        }
        this.shuffle();
    }

    shuffle() { this.cards.sort(() => Math.random() - 0.5); }

    draw() {
        if (this.cards.length === 0) {
            if (this.cat === 'loki' || this.discardPile.length === 0) return null;
            this.cards = [...this.discardPile];
            this.discardPile = [];
            this.shuffle();
        }
        return this.cards.pop();
    }

    peek(count) { return this.cards.slice(-count).reverse(); } // ë¯¸ë˜ì¼ê¸°ìš©

    discard(card) { this.discardPile.push(card); }
    getCount() { return this.cards.length; }
}

class Player {
    constructor(id) {
        this.id = id;
        this.hand = [];
        this.reserved = [];
        this.artifacts = [];
        this.score = 0;
        this.time = 0;
        this.stackOrder = 0;
        this.targetMyth = null; 
        this.celtConvertCount = 0;
        this.celtMimicMode = null;
        this.aiTargetIdx = null;
        this.olympusDiscount = { type: null, amount: 0 };
        
        // [ìˆ˜ì •ë¨] í†µê³„ ë° ì—‘ì…€ ë¶„ì„ìš© ë°ì´í„° ì¶”ê°€
        this.dailyScore = [-1, -1, -1, -1, -1]; 
        this.metrics = { 
            savedRes: 0, wastedCards: 0, celtSwaps: 0,
            resAcquired: 0, resConsumed: 0, lokiUsed: 0      
        };
        this.milestones = {}; 
        this.history = []; // ë§¤ì¼ ë°¤ ìœ ë¬¼ ìƒíƒœ ê¸°ë¡
    }

    getHandCount() {
        return this.hand.filter(c => c.cat !== 'loki').length;
    }
}

// ==========================================
// [Part 2] Game Engine (Core Logic - UI Free)
// ==========================================

class Game {
    constructor() {
        this.isInitialized = false;
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        this.players = [];
        this.pIdx = 0;
    }

    init(mythAssignments) {
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        
        this.players = [new Player(1), new Player(2), new Player(3), new Player(4)];
        this.players.forEach((p, i) => {
            p.targetMyth = mythAssignments ? mythAssignments[i] : ['olympus', 'egypt', 'nord', 'celt'][i];
            const rule = START_RULE[i];
            p.score = rule.score;
            p.stackOrder = 3 - i; 
        });

        this.deckRes = new Deck('resource');
        this.deckBless = new Deck('blessing');
        this.deckArt = new Deck('artifact');
        this.deckLoki = new Deck('loki');

        this.fieldRes = [];
        this.fieldBless = [];
        this.fieldArt = [];

        this.fill('resource', 6);
        this.fill('blessing', 4);
        this.fill('artifact', 7);

        this.players.forEach((p, i) => {
            const rule = START_RULE[i];
            for(let k=0; k<rule.res; k++) { const c = this.deckRes.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.bless; k++) { const c = this.deckBless.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.loki; k++) { const c = this.deckLoki.draw(); if(c) p.hand.push(c); }
        });

        this.pIdx = 0;
        this.isInitialized = true;
    }

    get cp() { return this.players[this.pIdx]; }

    fill(cat, max) {
        const field = cat === 'resource' ? this.fieldRes : (cat === 'blessing' ? this.fieldBless : this.fieldArt);
        const deck = cat === 'resource' ? this.deckRes : (cat === 'blessing' ? this.deckBless : this.deckArt);
        while(field.length < max) {
            const c = deck.draw();
            if(c) field.push(c);
            else break;
        }
    }

    getArtLevel(type) {
        const p = this.cp;
        let count = p.artifacts.filter(a => a.type === type).length;
        const celtCount = p.artifacts.filter(a => a.type === 'celt').length;
        // ì¼ˆíŠ¸ 3ë‹¨ê³„ ë¯¸ë¯¹ ì ìš©
        if (type !== 'celt' && celtCount >= 3 && p.celtMimicMode === type) count += 1;
        // ì¼ˆíŠ¸ ìì‹ ì€ ë¯¸ë¯¹ íš¨ê³¼ ëª» ë°›ìŒ (ì´ë¯¸ 3ì¥ì´ë¯€ë¡œ ì˜ë¯¸ ì—†ê¸°ë„ í•¨)
        if (type === 'celt' && celtCount >= 3 && p.celtMimicMode !== null) return 0;
        return count;
    }

    getCost(action) {
        let cost = CONFIG.COST[action];
        const egyptLv = this.getArtLevel('egypt');
        
        // ì´ì§‘íŠ¸ í• ì¸ ì ìš© (ëˆ„ì  ë°©ì‹)
        let discount = 0;
        const maxLevel = Math.min(egyptLv, 3);
        
        for (let i = 0; i < maxLevel; i++) {
            // BALANCE_CONFIGê°€ ë°°ì—´ì¸ì§€ í™•ì¸í•˜ê³  ì•ˆì „í•˜ê²Œ ì ‘ê·¼
            if (Array.isArray(BALANCE_CONFIG.EGYPT)) {
                const levelConfig = BALANCE_CONFIG.EGYPT[i];
                if (levelConfig) {
                    if (action === 'RESERVE') discount += levelConfig.RESERVE;
                    else if (action === 'RES') discount += levelConfig.RES;
                    else if (action === 'BLESS') discount += levelConfig.BLESS;
                    else if (action === 'ART') discount += levelConfig.ART;
                }
            } else {
                // êµ¬ë²„ì „ í˜¸í™˜ìš© (í˜¹ì‹œ ëª¨ë¥¼ ì—ëŸ¬ ë°©ì§€)
                if (action === 'RESERVE' && i === 0) discount += 1;
                if (action === 'RES' && i === 1) discount += 1;
                if ((action === 'BLESS' || action === 'ART') && i === 2) discount += 1;
            }
        }
        
        cost -= discount;
        return Math.max(0, cost);
    }

    consumeTime(amount) {
        const p = this.cp;
        const targetTime = p.time + amount;
        let maxStack = -1;
        this.players.forEach(other => {
            if (other.id !== p.id && other.time === targetTime) {
                if (other.stackOrder > maxStack) maxStack = other.stackOrder;
            }
        });
        p.time = targetTime;
        p.stackOrder = maxStack + 1;
        this.determineNextTurn();
    }

    determineNextTurn() {
        if (this.isGameEnded) return;
        if (this.players.every(p => p.time >= CONFIG.MAX_TIME)) { this.processDayEnd(); return; }
        
        let candidates = this.players.filter(p => p.time < CONFIG.MAX_TIME);
        if (candidates.length === 0) { this.processDayEnd(); return; }

        candidates.sort((a, b) => {
            if (a.time !== b.time) return a.time - b.time;
            return b.stackOrder - a.stackOrder;
        });

        const nextPlayer = candidates[0];
        if (this.cp.id !== nextPlayer.id) {
            this.pIdx = this.players.indexOf(nextPlayer);
            this.cp.celtConvertCount = 0; // í„´ ë³€ê²½ ì‹œ ì¼ˆíŠ¸ ì¹´ìš´íŠ¸ ë¦¬ì…‹
        }
    }

   processDayEnd() {
        this.players.forEach(p => {
            // 1. ì ìˆ˜ ê¸°ë¡
            if (this.day <= 5) p.dailyScore[this.day - 1] = p.score;
            
            // 2. [ì¶”ê°€ë¨] ìœ ë¬¼ ìƒíƒœ ìŠ¤ëƒ…ìƒ· ê¸°ë¡ (ì—‘ì…€ ë¶„ì„ìš©)
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(a => { if(counts[a.type] !== undefined) counts[a.type]++; });
            
            p.history.push({
                day: this.day,
                score: p.score,
                olympus: counts.olympus,
                egypt: counts.egypt,
                nord: counts.nord,
                celt: counts.celt
            });
        });

        if (this.day >= CONFIG.MAX_DAYS) { this.endGame(); return; }
        
        this.processNightInstant();
        this.day++;
        
        this.fieldRes.forEach(c => this.deckRes.discard(c)); this.fieldRes = [];
        this.fieldBless.forEach(c => this.deckBless.discard(c)); this.fieldBless = [];
        this.fill('resource', 6); this.fill('blessing', 4);

        this.players.forEach(p => { p.time = Math.max(0, p.time - CONFIG.MAX_TIME); });

        if (this.day > CONFIG.MAX_DAYS) this.endGame();
        else this.determineNextTurn();
    }
    processNightInstant() {
        let offers = [];
        for(let i=0; i<6; i++) offers.push(this.deckLoki.draw());
        let selections = {};
        this.players.forEach(p => { selections[p.id] = Math.floor(Math.random() * 6); });
        let counts = {};
        Object.values(selections).forEach(slot => { counts[slot] = (counts[slot] || 0) + 1; });

        this.players.forEach(p => {
            const choice = selections[p.id];
            if (counts[choice] === 1 && offers[choice]) {
                const item = offers[choice];
                if (item.extra.type === 'instant_score') p.score += 2;
                else p.hand.push(item);
            }
        });
    }

    endGame() {
        if (this.isGameEnded) return;
        this.isGameEnded = true;
        this.players.forEach(p => {
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(art => { if(counts[art.type] !== undefined) counts[art.type]++; });
            
            // 4ì¢… í†µí•© ë³´ë„ˆìŠ¤
            if(counts.olympus > 0 && counts.egypt > 0 && counts.nord > 0 && counts.celt > 0) p.score += 5;
            
            // ì‹ í™” ì „ë¬¸í™” ë³´ë„ˆìŠ¤
            for(const [type, count] of Object.entries(counts)) {
                if(count >= 4) p.score += (count - 3) * 2;
            }
        });
    }
}

// ==========================================
// [Part 3] AI Brain (Cleaned & Integrated)
// ==========================================

// 1. [íƒœì„¸ ì „í™˜] ì¼ˆíŠ¸ 3ë‹¨ê³„ ëŠ¥ë ¥ ìë™ ìŠ¤ìœ„ì¹­
Game.prototype.aiAutoSwitchCeltMode = function(plan) {
    // [Safety Fix] ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ì„ ê²½ìš°(undefined) ê¸°ë³¸ê°’ trueë¥¼ ì‚¬ìš©
    const cachedSetting = BALANCE_CONFIG.CELT.MIMIC_ENABLED;
    const isMimicEnabled = (cachedSetting !== undefined) ? cachedSetting : true;

    if (!isMimicEnabled) {
        if (this.cp.celtMimicMode !== null) this.cp.celtMimicMode = null;
        return;
    }

    const ai = this.cp;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    if (realCeltCount < 3) return;

    let targetMode = null; 

    if (plan && plan.preferredMode) {
        // AIê°€ íŠ¹ì • ëª¨ë“œë¥¼ ì„ í˜¸í•˜ë©´ ê·¸ ëª¨ë“œë¡œ ì „í™˜ (celtëŠ” ë³¸ì²´ì´ë¯€ë¡œ null)
        targetMode = plan.preferredMode === 'celt' ? null : plan.preferredMode;
    } else {
        // ë¹„ìƒ ì‹œ ê¸°ë³¸ ë¡œì§ (Original Logic ìœ ì§€)
        if (plan && plan.action === 'GATHER' && ai.getHandCount() <= 4) targetMode = 'nord';
        else if (ai.time >= 9) targetMode = 'egypt';
    }

    if (ai.celtMimicMode !== targetMode) {
        ai.celtMimicMode = targetMode;
    }
};

// 2. [ê°€ì¹˜ íŒë‹¨] ìœ ë¬¼ ê°€ì¹˜ ë° ë¹„ìš© ê³„ì‚° (Core Logic)
// [Part 3] AI Valuation Logic (ê¸°ì¡´ Game.prototype.aiCalculateTargetValue ëŒ€ì²´)
Game.prototype.aiCalculateTargetValue = function(art, isReserved) {
    const ai = this.cp;
    
    // [Safety Fix] ìºì‹±ëœ ì„¤ì •ê°’ ì‚¬ìš©í•˜ë˜, ë¹„ì–´ìˆìœ¼ë©´ true ì²˜ë¦¬
    const cachedSetting = BALANCE_CONFIG.CELT.MIMIC_ENABLED;
    const mimicEnabled = (cachedSetting !== undefined) ? cachedSetting : true;

    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    const canMimic = (realCeltCount >= 3 && mimicEnabled);

    const myRes = { adamantite:0, mithril:0, dragonBone:0, starFragment:0 };
    let totalHandCount = 0;
    ai.hand.forEach(c => {
        totalHandCount++;
        if (c.cat === 'resource') myRes[c.type] = (myRes[c.type]||0) + c.val;
        else if (c.cat === 'loki' && c.extra.type === 'res_split') {
            myRes[c.extra.options[0].type] = (myRes[c.extra.options[0].type]||0) + 4;
        }
    });

    // ì‹œë‚˜ë¦¬ì˜¤ë³„ ë¹„ìš© ê³„ì‚° í•¨ìˆ˜
    const calculateScenario = (mode) => {
        let simOlympusLv, simCeltLv;
        if (!canMimic) { simOlympusLv = this.getArtLevel('olympus'); simCeltLv = realCeltCount; } 
        else {
            const realOlympus = ai.artifacts.filter(a => a.type === 'olympus').length;
            if (mode === 'olympus') { simOlympusLv = Math.max(realOlympus, 3); simCeltLv = 0; }
            else if (mode === 'celt') { simOlympusLv = realOlympus; simCeltLv = 3; }
            else { simOlympusLv = realOlympus; simCeltLv = realCeltCount; }
        }

        let tempCost = { ...art.cost };
        let discountType = null;
        if (simOlympusLv > 0) {
            const amt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(simOlympusLv, 3)];
            let maxSaved = -1;
            for(let t in tempCost) {
                if(tempCost[t] > 0) {
                    let saved = Math.min(tempCost[t], amt);
                    if(saved > maxSaved) { maxSaved = saved; discountType = t; }
                }
            }
            if(discountType) tempCost[discountType] = Math.max(0, tempCost[discountType] - amt);
        }

        let availableSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(simCeltLv, 3)] - ai.celtConvertCount;
        let needsSwap = false;
        let tempHandCount = totalHandCount;
        let missing = 0;

        for(let t in tempCost) {
            let need = Math.max(0, tempCost[t] - (myRes[t]||0));
            if (need > 0 && availableSwaps > 0) {
                const cardsNeeded = Math.ceil(need / 4);
                if (tempHandCount >= cardsNeeded && availableSwaps >= cardsNeeded) {
                    availableSwaps -= cardsNeeded; tempHandCount -= cardsNeeded; need = 0; needsSwap = true;
                }
            }
            missing += need;
        }
        return { missing, needsSwap, discountType, mode };
    };

    const currentMode = canMimic ? (ai.celtMimicMode || 'celt') : 'celt';
    let bestScenario = calculateScenario(currentMode); 
    
    // ë¯¸ë¯¹ ê°€ëŠ¥ ì‹œ ìµœì ì˜ ëª¨ë“œ íƒìƒ‰
    if (canMimic) {
        const sO = calculateScenario('olympus');
        const sC = calculateScenario('celt');
        if (sO.missing <= 0 && sC.missing > 0) bestScenario = sO;
        else if (sC.missing <= 0 && sO.missing > 0) bestScenario = sC;
        else if (sO.missing <= 0 && sC.missing <= 0) bestScenario = sO; 
        else bestScenario = (sO.missing < sC.missing) ? sO : sC;
    }

    let action = bestScenario.missing <= 0 ? 'CRAFT' : 'GATHER';
    let net = art.score * 10;
    if (ai.targetMyth && art.type === ai.targetMyth) net += 100;

    if (action === 'CRAFT') {
        net += 5000;
        if (isReserved) net += 2000;
        if (bestScenario.needsSwap) net += 50; 
    } else {
        net += Math.max(0, 500 - bestScenario.missing * 5);
        
        // [Logic Fix: ì´ì¤‘ í˜œíƒ ë°©ì§€] 
        // ì˜¬ë¦¼í¬ìŠ¤(í• ì¸) ëª¨ë“œ ì„ íƒ ì‹œ ë…¸ë¥´ë“œ(ì†ë„) í˜œíƒì„ ë™ì‹œì— ë°›ì§€ ëª»í•˜ë„ë¡ ë³´ì •
        let effNord;
        if (!canMimic) {
            effNord = this.getArtLevel('nord');
        } else {
            // íƒœì„¸ê°€ 'nord'ì´ê±°ë‚˜, ì¼ˆíŠ¸(ê¸°ë³¸) ìƒíƒœì—¬ì„œ ìˆ˜ì§‘ í–‰ë™ ì‹œ ë…¸ë¥´ë“œë¡œ ë³€ì‹  ê°€ëŠ¥í•œ ê²½ìš°ë§Œ +1
            const isNordMode = bestScenario.mode === 'nord' || ai.celtMimicMode === 'nord';
            const canSwitchToNord = bestScenario.mode === 'celt' || bestScenario.mode === null;
            
            if (isNordMode || canSwitchToNord) {
                effNord = ai.artifacts.filter(a => a.type === 'nord').length + 1;
            } else {
                effNord = ai.artifacts.filter(a => a.type === 'nord').length;
            }
        }

        let speed = BALANCE_CONFIG.NORD.GATHER_SPEED[Math.min(effNord, 3)];
        net -= (Math.ceil(bestScenario.missing / speed) * 10);
    }

    let timeCost = CONFIG.COST[action];
    let effEgy = !canMimic ? this.getArtLevel('egypt') : (bestScenario.mode==='egypt'||ai.celtMimicMode==='egypt' ? Math.max(ai.artifacts.filter(a=>a.type==='egypt').length,3) : ai.artifacts.filter(a=>a.type==='egypt').length);
    let egyDisc = 0;
    for(let i=0; i<Math.min(effEgy, 3); i++) {
        const c = BALANCE_CONFIG.EGYPT[i];
        if(c) egyDisc += (action==='RESERVE'?c.RESERVE : action==='GATHER'?c.RES : action==='CRAFT'?c.ART : 0);
    }
    timeCost = Math.max(0, timeCost - egyDisc);
    if (timeCost <= 0) net += 150; else if (timeCost < CONFIG.COST[action]) net += 50;

    let hasBless = ai.hand.some(c => (c.cat === 'blessing' && c.type === art.type) || (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
    const allowConvert = BALANCE_CONFIG.CELT.LVL_CONVERT.includes(realCeltCount);
    const allowFree = BALANCE_CONFIG.CELT.LVL_FREE.includes(realCeltCount);

    if (!hasBless && allowConvert) {
        hasBless = ai.hand.some(c => c.cat === 'blessing' || (c.cat === 'loki' && c.extra.type === 'bless_split'));
    }
    let needBless = !hasBless && !allowFree;
    if (needBless) net -= 5000;

    // [Logic Restored] ìƒì„¸ ì„ í˜¸ íƒœì„¸ ê²°ì • ë¡œì§ (ì™„ì „ ë³µì›)
    let finalPreferredMode = bestScenario.mode;
    if (action === 'GATHER' && canMimic) {
        let nordIdx = Math.max(0, Math.min(this.getArtLevel('nord')+1, 3)-1);
        let nordCap = BALANCE_CONFIG.NORD.LIMIT_COUNT[Math.min(nordIdx, 2)];
        let rawMissing = 0; for(let t in art.cost) if(art.cost[t] > (myRes[t]||0)) rawMissing += (art.cost[t]-(myRes[t]||0));
        
        if (bestScenario.needsSwap) {
             if (ai.getHandCount() <= 4 && rawMissing >= 2 && nordCap >= 2) { finalPreferredMode = 'nord'; net += 150; }
             else { finalPreferredMode = 'celt'; net += 200; }
        } else if (rawMissing >= 1 && nordCap >= 2 && ai.getHandCount() <= 6) { 
            finalPreferredMode = 'nord'; net += 150; 
        } else if (bestScenario.missing === 1 && finalPreferredMode !== 'celt') { 
            finalPreferredMode = 'egypt'; net += 40; 
        }
    }

    return { art, netValue: net, action, fromReserve: isReserved, discountType: bestScenario.discountType, targetIdx: -1, needBless, missingVal: bestScenario.missing, preferredMode: finalPreferredMode };
};

// 3. [ì „ìˆ  ì‹¤í–‰] ë¡œí‚¤ ì¹´ë“œ ì‚¬ìš© (v9.2 Integrated)
Game.prototype.aiPlayLokiTactics = function() {
    const ai = this.cp;
    
    // 1. ê³„ìŠ¹ìì˜ ë¬¸ì¥ (+2ì )
    const crestIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'instant_score');
    if (crestIdx !== -1) { 
        ai.score += 2; 
        ai.hand.splice(crestIdx, 1); 
        ai.metrics.lokiUsed++; 
        return true; 
    }

    // 2. êµ¬ë¶€ëŸ¬ì§„ ì‹œê³—ë°”ëŠ˜ (ì‹œê°„ -1)
    const clockIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_time');
    if (clockIdx !== -1) {
        if (ai.time >= 9 || (ai.score < 10 && ai.time >= 7)) {
            ai.time = Math.max(0, ai.time - 1); 
            ai.hand.splice(clockIdx, 1); 
            ai.metrics.lokiUsed++; 
            return true;
        }
    }

    // 3. ê²€ì€ ì£¼ì‚¬ìœ„ (ìì› êµì²´) - ì¸ë±ìŠ¤ ì˜¤ë¥˜ ë°©ì§€ ì ìš©ë¨
    const diceIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_draw');
    if (diceIdx !== -1) {
        const junkIndices = ai.hand.map((c, i) => (c.cat === 'resource' && c.val <= 3) ? i : -1).filter(i => i !== -1);
        
        if (junkIndices.length >= 2) {
            let targets = [diceIdx, junkIndices[0], junkIndices[1]];
            targets = [...new Set(targets)];
            targets.sort((a, b) => b - a); // ë’¤ì—ì„œë¶€í„° ì‚­ì œí•˜ì—¬ ì¸ë±ìŠ¤ ìœ ì§€

            targets.forEach(idx => ai.hand.splice(idx, 1));
            
            for(let k=0; k<2; k++) { 
                const newCard = this.deckRes.draw(); 
                if(newCard) {
                    ai.hand.push(newCard);
                    ai.metrics.resAcquired += newCard.val;
                }
            }
            ai.metrics.lokiUsed++;
            this.consumeTime(1); 
            return true;
        }
    }

    // 4. ë¯¸ë˜ ì¼ê¸°
    const diaryIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_peek');
    if (diaryIdx !== -1 && ai.getHandCount() < 8) {
        if (this.deckArt.cards.length < 3) {
             this.deckArt.cards = [...this.deckArt.discardPile];
             this.deckArt.discardPile = [];
             this.deckArt.shuffle();
        }
        const candidates = [];
        for(let k=0; k<3; k++) { let c = this.deckArt.draw(); if(c) candidates.push(c); }
        
        if (candidates.length > 0) {
            candidates.sort((a, b) => b.score - a.score);
            const selected = candidates[0];
            
            if (ai.reserved.length < 1) {
                ai.reserved.push(selected);
            } else {
                this.deckArt.discard(selected);
            }
            for(let k=1; k<candidates.length; k++) this.deckArt.discard(candidates[k]);
        }

        ai.hand.splice(diaryIdx, 1);
        ai.metrics.lokiUsed++;
        this.consumeTime(1);
        return true;
    }

    // 5. í˜¼ëˆì˜ ì±„ì„ë§ì¹˜
    const hammerIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_reset');
    if (hammerIdx !== -1) {
        const fieldSum = this.fieldRes.reduce((a, b) => a + b.val, 0);
        const fieldAvg = this.fieldRes.length > 0 ? fieldSum / this.fieldRes.length : 0;
        const hasHighValue = this.fieldRes.some(c => c.val >= 6);

        if (fieldAvg <= 3.5 && !hasHighValue) {
            this.fieldRes.forEach(c => this.deckRes.discard(c));
            this.fieldRes = [];
            this.fill('resource', 6);
            
            ai.hand.splice(hammerIdx, 1);
            ai.metrics.lokiUsed++;
            this.consumeTime(1);
            return true;
        }
    }
    return false;
};

// 4. [ì „ëµ ìˆ˜ë¦½] ìµœì  ê³„íš ì°¾ê¸°
Game.prototype.aiFindBestPlan = function() {
    const ai = this.cp;
    let bestScore = -Infinity;
    let bestPlan = null;

    // ë§ê°ì˜ ì£¼íŒ (ì „ëµì  êµí™˜)
    const abacusIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_swap');
    if (abacusIdx !== -1 && ai.reserved.length > 0 && this.fieldArt.length > 0) {
        let worstRes = { score: 999, idx: -1 };
        ai.reserved.forEach((art, i) => { if(art.score < worstRes.score) worstRes = {score: art.score, idx: i}; });
        let bestMkt = { score: -1, idx: -1 };
        this.fieldArt.forEach((art, i) => { if(art.score > bestMkt.score) bestMkt = {score: art.score, idx: i}; });
        
        if (bestMkt.score - worstRes.score >= 6) {
            return { action: 'SWAP_ARTIFACT', handIdx: abacusIdx, reserveIdx: worstRes.idx, marketIdx: bestMkt.idx };
        }
    }

    // ì˜ˆì•½ ìœ ë¬¼ í‰ê°€
    ai.reserved.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, true);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    // ì‹œì¥ ìœ ë¬¼ í‰ê°€
    this.fieldArt.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, false);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    return bestPlan;
};

// 5. [í–‰ë™ ì‹¤í–‰] ì œì‘ íŠ¸ëœì­ì…˜ (ìì› ì†Œëª¨ ë¡œì§)
// [Part 3] Craft Transaction (ê¸°ì¡´ Game.prototype.processCraftTransaction ëŒ€ì²´)
Game.prototype.processCraftTransaction = function(ai, plan) {
    const art = plan.art;
    const fromReserve = plan.fromReserve;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;

    let requirements = { ...art.cost };
    let olympusSavedAmount = 0;

    if (plan.discountType) {
        const olympusLv = this.getArtLevel('olympus'); 
        const amt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(olympusLv, 3)];
        requirements[plan.discountType] = Math.max(0, requirements[plan.discountType] - amt);
        olympusSavedAmount = amt;
    }

    let cardsToPay = [];
    let hand = [...ai.hand];
    
    // 1. Res
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'resource' && c.type === reqType) {
                needed -= c.val; cardsToPay.push(c); hand.splice(i, 1); ai.metrics.resConsumed += c.val; 
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }
    // 2. Loki
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal; if (needed <= 0) continue;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'loki' && c.extra.type === 'res_split' && c.extra.options.some(opt => opt.type === reqType)) {
                needed -= 4; cardsToPay.push(c); hand.splice(i, 1); ai.metrics.resConsumed += 4;
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }
    // 3. Celt Swap
    const activeCeltLv = this.getArtLevel('celt');
    const maxSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(activeCeltLv, 3)];
    let usedSwaps = 0; let currentTotalSwaps = ai.celtConvertCount;
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal; if (needed <= 0) continue;
        if (currentTotalSwaps < maxSwaps) {
            for (let i = hand.length - 1; i >= 0; i--) {
                if (needed <= 0 || currentTotalSwaps >= maxSwaps) break;
                let c = hand[i];
                if (c.cat === 'resource') {
                    needed -= c.val; cardsToPay.push(c); hand.splice(i, 1); usedSwaps++; currentTotalSwaps++; ai.metrics.resConsumed += c.val; 
                }
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }

    if (Object.values(requirements).reduce((a,b)=>a+b, 0) > 0) return false;

    // Bless
    const isConvert = BALANCE_CONFIG.CELT.LVL_CONVERT.includes(realCeltCount);
    const isFree = BALANCE_CONFIG.CELT.LVL_FREE.includes(realCeltCount);
    if (!isFree) {
         let blessIdx = hand.findIndex(c => (c.cat === 'blessing' && c.type === art.type) || (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
         if (blessIdx === -1 && isConvert) blessIdx = hand.findIndex(c => c.cat === 'blessing' || (c.cat === 'loki' && c.extra.type === 'bless_split'));
         if (blessIdx !== -1) { cardsToPay.push(hand[blessIdx]); hand.splice(blessIdx, 1); } else return false;
    }

    if (olympusSavedAmount > 0) ai.metrics.savedRes += olympusSavedAmount;
    if (usedSwaps > 0) { ai.metrics.celtSwaps += usedSwaps; ai.celtConvertCount += usedSwaps; }
    ai.hand = hand;
    cardsToPay.forEach(c => {
        if(c.cat === 'resource') this.deckRes.discard(c);
        else if(c.cat === 'blessing') this.deckBless.discard(c);
        else if(c.cat === 'loki') this.deckLoki.discard(c); 
    });

    let scoreBonus = (art.score >= 24) ? 4 : (art.score >= 10 ? 3 : 2);
    const craftedArt = { ...art, isGrace: true, finalScore: art.score + scoreBonus, bonus: scoreBonus };
    ai.artifacts.push(craftedArt);
    ai.score += craftedArt.finalScore;

    const typeCount = ai.artifacts.filter(a => a.type === craftedArt.type).length;
    if (typeCount === 3 && ai.milestones[craftedArt.type] === undefined) ai.milestones[craftedArt.type] = this.craftOrder++; 

    if (fromReserve) ai.reserved.splice(plan.targetIdx, 1);
    else { this.fieldArt.splice(plan.targetIdx, 1); this.fill('artifact', 7); }
    
    const freeCardIdx = cardsToPay.findIndex(c => c.cat === 'loki' && c.extra.type === 'passive_free');
    if (freeCardIdx !== -1) { ai.metrics.lokiUsed++; this.consumeTime(0); }
    else this.consumeTime(this.getCost('ART'));

    return true;
};

// 6. [AI ë©”ì¸] í„´ ì‹¤í–‰ í•¨ìˆ˜
Game.prototype.aiTurn = function() {
    const ai = this.cp;
    if (this.isGameEnded || ai.time >= CONFIG.MAX_TIME) return;

    // 1. í•¸ë“œ ì •ë¦¬
    if (ai.getHandCount() > CONFIG.HAND_LIMIT) { 
        this.aiSmartDiscard(ai); 
        return; 
    }

    // 2. ë¡œí‚¤ ì „ìˆ 
    if (this.aiPlayLokiTactics()) return;

    // 3. ì „ëµ ìˆ˜ë¦½
    const bestPlan = this.aiFindBestPlan();
    
    if (!bestPlan) { 
        this.aiEmergencyAction(); 
        return; 
    }

    // íƒœì„¸ ì „í™˜
    this.aiAutoSwitchCeltMode(bestPlan);
    ai.aiTargetIdx = bestPlan.targetIdx;

    // 4. í–‰ë™ ì‹¤í–‰
    if (bestPlan.action === 'SWAP_ARTIFACT') {
        const myArt = ai.reserved[bestPlan.reserveIdx];
        const marketArt = this.fieldArt[bestPlan.marketIdx];
        ai.reserved[bestPlan.reserveIdx] = marketArt;
        this.fieldArt[bestPlan.marketIdx] = myArt;
        ai.hand.splice(bestPlan.handIdx, 1);
        this.consumeTime(this.getCost('SWAP'));
    }
    else if (bestPlan.action === 'CRAFT') {
        const success = this.processCraftTransaction(ai, bestPlan);
        if (!success) this.aiActionGather(bestPlan);
    } 
    else if (bestPlan.action === 'RESERVE') {
        if (ai.reserved.length >= 1) {
            this.aiActionGather(bestPlan);
        } else {
            const art = this.fieldArt[bestPlan.targetIdx];
            if (art) {
                ai.reserved.push(art);
                this.fieldArt.splice(bestPlan.targetIdx, 1);
                this.fill('artifact', 7);
                this.consumeTime(this.getCost('RESERVE'));
            } else {
                this.aiEmergencyAction();
            }
        }
    }
    else { 
        this.aiActionGather(bestPlan);
    }
};

// 7. [ìì› ìˆ˜ì§‘] ì´í•˜ ì½”ë“œëŠ” ì›ë³¸ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€
// [Part 3 ì¶”ê°€] Gather Logic Update (ê¸°ì¡´ Game.prototype.aiActionGather ëŒ€ì²´)
Game.prototype.aiActionGather = function(plan) {
    const ai = this.cp;
    
    // ì¶•ë³µ ì²˜ë¦¬ (ì¼ˆíŠ¸ ë¡œì§ ë³´ê°•ë¨)
    if (plan.needBless) {
        // 1. ë¨¼ì € ì •ì„ëŒ€ë¡œ í•„ìš”í•œ ì¶•ë³µ ì°¾ê¸°
        let blessIdx = this.fieldBless.findIndex(c => c.type === plan.art.type);
        
        // 2. [ì‹ ê·œ ë¡œì§] ì •ì„ ì¶•ë³µì´ ì—†ê³  'ë³€í™˜(Any)' ëŠ¥ë ¥ì´ ìˆë‹¤ë©´, ì•„ë¬´ ì¶•ë³µì´ë‚˜ ì°¾ê¸°
        const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
        if (blessIdx === -1 && BALANCE_CONFIG.CELT.LVL_CONVERT.includes(realCeltCount)) {
            blessIdx = this.fieldBless.findIndex(c => true); // ì•„ë¬´ê±°ë‚˜ ì²« ë²ˆì§¸
        }

        if (blessIdx !== -1) {
            ai.hand.push(this.fieldBless[blessIdx]);
            this.fieldBless.splice(blessIdx, 1);
            this.fill('blessing', 4);
            this.consumeTime(this.getCost('BLESS'));
        } else {
            // ì„±ë°°(ë¦¬ì…‹) ì²´í¬
            const grailIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_reset_bless');
            if (grailIdx !== -1) {
                this.fieldBless.forEach(c => this.deckBless.discard(c));
                this.fieldBless = []; this.fill('blessing', 4);
                ai.hand.splice(grailIdx, 1);
                ai.metrics.lokiUsed++; 
                return;
            }
            // ì—†ìœ¼ë©´ ë“œë¡œìš°
            const c = this.deckBless.draw();
            if(c) ai.hand.push(c);
            this.consumeTime(this.getCost('BLESS'));
        }
        return;
    }

    // ì´í•˜ ìì› ìˆ˜ì§‘ ë¡œì§ì€ ê¸°ì¡´ê³¼ ë™ì¼
    if (this.getArtLevel('nord') > 0 && this.aiTryNordAction(plan.art)) return;

    let neededTypes = [];
    let myRes = {}; 
    ai.hand.forEach(c => { if(c.cat==='resource') myRes[c.type] = (myRes[c.type]||0)+c.val; });
    for(const [t, req] of Object.entries(plan.art.cost)) { if(myRes[t] < req) neededTypes.push(t); }

    let targetIdx = -1;
    // 3ì¥ ì´ìƒì¸ í•„ìš” ìì› ìš°ì„ 
    for(let i=0; i<this.fieldRes.length; i++) {
        if (neededTypes.includes(this.fieldRes[i].type) && this.fieldRes[i].val >= 3) { targetIdx = i; break; }
    }
    // ì—†ìœ¼ë©´ ê·¸ëƒ¥ í•„ìš” ìì›
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) {
            if (neededTypes.includes(this.fieldRes[i].type)) { targetIdx = i; break; }
        }
    }
    // ê·¸ê²ƒë„ ì—†ìœ¼ë©´ ê³ ë°¸ë¥˜(6+) ìì› (ê²¬ì œ ë° êµí™˜ìš©)
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) { if (this.fieldRes[i].val >= 6) { targetIdx = i; break; } }
    }

    if (targetIdx !== -1) {
        const card = this.fieldRes[targetIdx];
        ai.hand.push(card);
        ai.metrics.resAcquired += card.val; 
        this.fieldRes.splice(targetIdx, 1);
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES'));
    } else {
        const c = this.deckRes.draw();
        if(c) {
            ai.hand.push(c);
            ai.metrics.resAcquired += c.val; 
        }
        this.consumeTime(this.getCost('RES'));
    }
};

Game.prototype.aiTryNordAction = function(targetArt) {
    const ai = this.cp;
    if (ai.getHandCount() >= 6) return false;

    const nordLv = this.getArtLevel('nord');
    const limitSum = BALANCE_CONFIG.NORD.LIMIT_SUM[Math.min(nordLv, 3)];
    let indices = this.fieldRes.map((_, i) => i);
    let bestCombo = null;
    let bestScore = -1;

    for (let i = 0; i < indices.length; i++) {
        for (let j = i + 1; j < indices.length; j++) {
            const c1 = this.fieldRes[i];
            const c2 = this.fieldRes[j];
            if (c1.val + c2.val <= limitSum) {
                let score = c1.val + c2.val;
                if (targetArt.cost[c1.type] > 0) score += 10;
                if (targetArt.cost[c2.type] > 0) score += 10;
                if (score > bestScore) { bestScore = score; bestCombo = [i, j]; }
            }
        }
    }

    if (bestCombo) {
        bestCombo.sort((a, b) => b - a);
        bestCombo.forEach(idx => {
            ai.hand.push(this.fieldRes[idx]);
            this.fieldRes.splice(idx, 1);
        });
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES'));
        return true;
    }
    return false;
};

Game.prototype.aiSmartDiscard = function(ai) {
    let worstIdx = -1; let minScore = 999;
    ai.hand.forEach((c, i) => {
        let score = 10; 
        if (c.cat === 'resource') score = c.val; 
        else if (c.cat === 'blessing') score = 5; 
        else if (c.cat === 'loki') score = 20; 
        if (score < minScore) { minScore = score; worstIdx = i; }
    });
    if (worstIdx !== -1) {
        const c = ai.hand[worstIdx];
        ai.hand.splice(worstIdx, 1);
        if (c.cat === 'resource') this.deckRes.discard(c);
        else if (c.cat === 'blessing') this.deckBless.discard(c);
        ai.metrics.wastedCards++;
    }
};

Game.prototype.aiEmergencyAction = function() {
    const c = this.deckRes.draw();
    if(c) this.cp.hand.push(c);
    this.consumeTime(this.getCost('RES'));
};

// ==========================================
// [Part 4] Simulation Manager
// ==========================================

class SimulationManager {
    constructor() {
        this.isRunning = false;
        this.stats = this.getEmptyStats();
        this.csvData = []; 
    }

    getEmptyStats() {
        return {
            totalGames: 0,
            wins: [0, 0, 0, 0, 0],
            totalScore: 0,
            days: 0,
            godWins2: { olympus: 0, egypt: 0, nord: 0, celt: 0, mix: 0 },
            godWins3: { olympus: 0, egypt: 0, nord: 0, celt: 0, mix: 0 },
            totalSaved: 0, totalWasted: 0, totalSwaps: 0,
            dailyScoreSum: [0, 0, 0, 0, 0], 
            winTier: { Bronze: 0, Silver: 0, Gold: 0 }, 
            totalResAcquired: 0, totalResConsumed: 0, 
            winnerLokiSum: 0, loserLokiSum: 0,

            // [ì¶”ê°€ë¨] ì‹ í™”ë³„ ì¼ì¼ ì ìˆ˜ ì§‘ê³„
            mythDailyStats: {
                olympus: { sum: [0,0,0,0,0], count: 0 },
                egypt: { sum: [0,0,0,0,0], count: 0 },
                nord: { sum: [0,0,0,0,0], count: 0 },
                celt: { sum: [0,0,0,0,0], count: 0 }
            }
        };
    }

    async startSimulation() {
        if (this.isRunning) return;
        applyUserBalance();
        // CSV í—¤ë” ì´ˆê¸°í™”
        this.csvData = ["GameID,Day,PlayerID,MainMyth,IsWinner,Score,OlympusLv,EgyptLv,NordLv,CeltLv"];
        
        const countInput = document.getElementById('simCount');
        const count = parseInt(countInput.value);
        const myths = [
            document.getElementById('p1Myth').value,
            document.getElementById('p2Myth').value,
            document.getElementById('p3Myth').value,
            document.getElementById('p4Myth').value
        ];

        this.isRunning = true;
        this.updateLog(`[System] ${count}íšŒ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ (Data Mining Mode)`);
        
        let chunkSize = 100;
        if (count >= 5000) chunkSize = 500;
        const startTime = performance.now();
        
        let gameIdCounter = 1;

        for (let i = 0; i < count; i += chunkSize) {
            if (!this.isRunning) break;
            const limit = Math.min(i + chunkSize, count);
            for (let j = i; j < limit; j++) { 
                this.runOneGame(myths, gameIdCounter++); 
            }
            const progress = Math.round(((i + chunkSize) / count) * 100);
            document.getElementById('progressBar').style.width = `${progress}%`;
            await new Promise(r => setTimeout(r, 0));
        }

        const endTime = performance.now();
        if (this.isRunning) {
            this.updateLog(`[System] ì™„ë£Œ. ì†Œìš”ì‹œê°„: ${((endTime - startTime)/1000).toFixed(2)}ì´ˆ`);
        }
        this.renderStats();
        this.isRunning = false;
        document.getElementById('progressBar').style.width = `0%`;
    }

    resetStats() {
        if (confirm("í†µê³„ ë° CSV ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
            this.stats = this.getEmptyStats();
            this.csvData = [];
            this.renderStats();
            this.updateLog(`[System] ì´ˆê¸°í™” ì™„ë£Œ`);
        }
    }
    
    stopSimulation() { this.isRunning = false; }

    runOneGame(myths, gameId) {
        const game = new Game();
        game.init(myths);
        
        game.players.forEach(p => { 
            p.milestones = {}; 
            if (p.getHandCount() > 8) game.aiSmartDiscard(p); 
        });

        let safetyBreak = 0;
        while (!game.isGameEnded && safetyBreak < 800) { 
            game.aiTurn(); 
            safetyBreak++; 
        }
        if (!game.isGameEnded) game.endGame();
        this.collectData(game, gameId);
    }

    collectData(game, gameId) {
        let winner = game.players[0];
        game.players.forEach(p => {
            if (p.score > winner.score) winner = p;
            else if (p.score === winner.score) {
                if (p.artifacts.length > winner.artifacts.length) winner = p;
            }
        });

        this.stats.totalGames++;
        this.stats.wins[winner.id]++;
        this.stats.days += game.day;
        
        let gameTotalScore = 0;
        
        game.players.forEach(p => {
            gameTotalScore += p.score;
            this.stats.totalSaved += p.metrics.savedRes;
            this.stats.totalWasted += p.metrics.wastedCards;
            this.stats.totalSwaps += p.metrics.celtSwaps;
            this.stats.totalResAcquired += p.metrics.resAcquired;
            this.stats.totalResConsumed += p.metrics.resConsumed;
            
            // ì¼ì¼ ì ìˆ˜ ê¸°ë¡ (ëˆ„ë½ë¶„ ì±„ìš°ê¸°)
            let filledDaily = [...p.dailyScore];
            for(let d=0; d<5; d++) {
                if (filledDaily[d] === -1) {
                    if (d === 0) filledDaily[d] = p.score; 
                    else filledDaily[d] = filledDaily[d-1];
                }
                this.stats.dailyScoreSum[d] += filledDaily[d];
            }

            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(a => { if(counts[a.type] !== undefined) counts[a.type]++; });
            
            // [Logic Update] ë™ì ì ë°œìƒ ì‹œ ë§ˆì¼ìŠ¤í†¤(ì„ ì°©ìˆœ) ê¸°ì¤€ ì£¼ë ¥ ì‹ í™” íŒë³„
            let mainMyth = 'mix';
            let maxVal = 0;
            
            // 1. ìµœë‹¤ ë³´ìœ ëŸ‰ ì°¾ê¸°
            for(const c of Object.values(counts)) {
                if (c > maxVal) maxVal = c;
            }

            // 2. í›„ë³´êµ° ì„ ì •
            const candidates = Object.keys(counts).filter(m => counts[m] === maxVal);

            if (candidates.length === 1) {
                mainMyth = candidates[0];
            } else {
                // 3. ë™ì  ì‹œ ë§ˆì¼ìŠ¤í†¤(3ë‹¨ê³„ ë‹¬ì„± ìˆœì„œ) ë¹„êµ
                candidates.sort((a, b) => {
                    const orderA = p.milestones[a] !== undefined ? p.milestones[a] : 99999;
                    const orderB = p.milestones[b] !== undefined ? p.milestones[b] : 99999;
                    return orderA - orderB;
                });

                if (p.milestones[candidates[0]] !== undefined) {
                    mainMyth = candidates[0];
                } else {
                    mainMyth = 'mix';
                }
            }

            // í†µê³„ ì§‘ê³„
            if (mainMyth !== 'mix' && this.stats.mythDailyStats[mainMyth]) {
                this.stats.mythDailyStats[mainMyth].count++;
                for(let d=0; d<5; d++) {
                    this.stats.mythDailyStats[mainMyth].sum[d] += filledDaily[d];
                }
            }

            // CSV ë°ì´í„° ì ì¬
            const isWinner = (p.id === winner.id) ? 1 : 0;
            p.history.forEach(h => {
                this.csvData.push(
                    `${gameId},${h.day},P${p.id},${mainMyth},${isWinner},${h.score},${h.olympus},${h.egypt},${h.nord},${h.celt}`
                );
            });
        });
        
        this.stats.totalScore += (gameTotalScore / 4);

        winner.artifacts.forEach(a => {
            if(this.stats.winTier[a.grade] !== undefined) this.stats.winTier[a.grade]++;
        });
        this.stats.winnerLokiSum += winner.metrics.lokiUsed;
        let losersLoki = 0;
        game.players.forEach(p => { if(p !== winner) losersLoki += p.metrics.lokiUsed; });
        this.stats.loserLokiSum += (losersLoki / 3);

        const wCounts = { olympus:0, egypt:0, nord:0, celt:0 };
        winner.artifacts.forEach(a => wCounts[a.type]++);
        const wMax = Math.max(...Object.values(wCounts));
        
        // [Logic Update] ìŠ¹ì í†µê³„í‘œìš© íŒë³„ í•¨ìˆ˜
        const determineType = (threshold) => {
            if (wMax < threshold) return 'mix';
            const leaders = Object.keys(wCounts).filter(key => wCounts[key] === wMax);
            if (leaders.length === 1) return leaders[0];
            
            leaders.sort((a, b) => {
                const orderA = winner.milestones[a] !== undefined ? winner.milestones[a] : 99999;
                const orderB = winner.milestones[b] !== undefined ? winner.milestones[b] : 99999;
                return orderA - orderB;
            });
            
            if (winner.milestones[leaders[0]] === undefined && threshold >= 3) return 'mix';
            return leaders[0];
        };
        
        this.stats.godWins2[determineType(2)]++;
        this.stats.godWins3[determineType(3)]++;
    }

    updateLog(msg) {
        const log = document.getElementById('simLog');
        log.innerText = msg + "\n" + log.innerText;
    }
    
    // [ì¶”ê°€ë¨] CSV ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥
    downloadRawData() {
        if (this.csvData.length <= 1) { alert("ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì‹œë®¬ë ˆì´ì…˜ì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”."); return; }
        
        const csvContent = this.csvData.join("\n");
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", `divine_forge_sim_data_${new Date().toISOString().slice(0,10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    renderStats() {
        const total = this.stats.totalGames;
        if (total === 0) return;
        const getPct = (val) => ((val / total) * 100).toFixed(1) + '%';
        
        const dailyAvg = this.stats.dailyScoreSum.map(s => (s / (total * 4)).toFixed(1));
        const tierTotal = this.stats.winTier.Bronze + this.stats.winTier.Silver + this.stats.winTier.Gold;
        const tierPct = {
            Bronze: tierTotal > 0 ? ((this.stats.winTier.Bronze / tierTotal) * 100).toFixed(1) : 0,
            Silver: tierTotal > 0 ? ((this.stats.winTier.Silver / tierTotal) * 100).toFixed(1) : 0,
            Gold: tierTotal > 0 ? ((this.stats.winTier.Gold / tierTotal) * 100).toFixed(1) : 0
        };
        const eff = this.stats.totalResAcquired > 0 ? ((this.stats.totalResConsumed / this.stats.totalResAcquired) * 100).toFixed(1) : 0;
        const winLoki = (this.stats.winnerLokiSum / total).toFixed(2);
        const loseLoki = (this.stats.loserLokiSum / total).toFixed(2);
        
        // [ì¶”ê°€ë¨] ì‹ í™”ë³„ ì¼ì¼ ì„±ì¥ ë°ì´í„° HTML
        let mythGrowthHtml = `<table style="font-size:11px;"><tr><th>ì‹ í™”</th><th>1ì¼</th><th>2ì¼</th><th>3ì¼</th><th>4ì¼</th><th>5ì¼</th></tr>`;
        ['olympus','egypt','nord','celt'].forEach(m => {
            const d = this.stats.mythDailyStats[m];
            const name = {olympus:'ì˜¬ë¦¼', egypt:'ì´ì§‘', nord:'ë…¸ë¥´', celt:'ì¼ˆíŠ¸'}[m];
            const color = {olympus:'#00bfff', egypt:'#f1c40f', nord:'#9b59b6', celt:'#2ecc71'}[m];
            if (d.count > 0) {
                const avgs = d.sum.map(s => (s/d.count).toFixed(1));
                mythGrowthHtml += `<tr><td style="color:${color}">${name}</td><td>${avgs[0]}</td><td>${avgs[1]}</td><td>${avgs[2]}</td><td>${avgs[3]}</td><td>${avgs[4]}</td></tr>`;
            } else {
                mythGrowthHtml += `<tr><td style="color:${color}">${name}</td><td colspan="5" style="color:#555;">ë°ì´í„° ì—†ìŒ</td></tr>`;
            }
        });
        mythGrowthHtml += `</table>`;

        let html = `<div class="grid-container" style="grid-template-columns:1fr 1fr 1fr 1fr; margin-bottom:10px;">`;
        for(let i=1; i<=4; i++) {
            const color = ['#e74c3c','#3498db','#2ecc71','#f1c40f'][i-1];
            html += `<div style="color:${color}; font-weight:bold;">P${i}: ${getPct(this.stats.wins[i])}</div>`;
        }
        html += `</div>`;
        
        // [ì¶”ê°€ë¨] ë‹¤ìš´ë¡œë“œ ë²„íŠ¼
        html += `<button onclick="simManager.downloadRawData()" style="width:100%; background:#27ae60; margin-bottom:15px;">ğŸ“¥ ì¡°í•© ë¶„ì„ìš© ì—‘ì…€ ë°ì´í„° ë‹¤ìš´ë¡œë“œ (.csv)</button>`;

        html += `<table>
            <tr><th colspan="3">ğŸ›ï¸ ì‹ í™”ë³„ ìŠ¹ë¥  (ë©”íƒ€ ë¶„ì„)</th></tr>
            <tr>
                <th style="text-align:left;">ë©”íƒ€(Deck)</th>
                <th>2+ (ìœ ì—°)</th>
                <th>3+ (ì „ë¬¸)</th>
            </tr>
            <tr>
                <td style="text-align:left; color:#00bfff;">â˜ï¸ ì˜¬ë¦¼í¬ìŠ¤</td>
                <td>${getPct(this.stats.godWins2.olympus)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.olympus)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#ffd700;">ğŸ‘ï¸ ì´ì§‘íŠ¸</td>
                <td>${getPct(this.stats.godWins2.egypt)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.egypt)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#9b59b6;">â„ï¸ ë…¸ë¥´ë“œ</td>
                <td>${getPct(this.stats.godWins2.nord)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.nord)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#2ecc71;">â˜˜ï¸ ì¼ˆíŠ¸</td>
                <td>${getPct(this.stats.godWins2.celt)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.celt)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#aaa;">ğŸ¨ ì¡íƒ•(Mix)</td>
                <td>${getPct(this.stats.godWins2.mix)}</td>
                <td>${getPct(this.stats.godWins3.mix)}</td>
            </tr>
        </table>`;

        html += `<div class="grid-container" style="margin-top:20px;">
            <div class="stats-area">
                <h3 style="color:#f1c40f; margin-top:0;">ğŸ“ˆ ì‹ í™”ë³„ ì¼ì¼ í‰ê·  ì ìˆ˜</h3>
                ${mythGrowthHtml}
            </div>
            <div class="stats-area">
                <h3 style="color:#f1c40f; margin-top:0;">ğŸ’ ìŠ¹ì ìœ ë¬¼ ë“±ê¸‰</h3>
                <table>
                    <tr><th style="color:#cd7f32">Bronze</th><th style="color:#c0c0c0">Silver</th><th style="color:#ffd700">Gold</th></tr>
                    <tr>
                        <td>${tierPct.Bronze}%</td><td>${tierPct.Silver}%</td><td>${tierPct.Gold}%</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <table style="margin-top: 15px;">
            <tr><th colspan="3">ğŸ” ì‹¬ì¸µ íš¨ìœ¨ ë¶„ì„</th></tr>
            <tr>
                <td>ğŸ“‰ ìì› íš¨ìœ¨ì„±<br><span style="font-size:10px; color:#888;">(ì†Œëª¨ / íšë“)</span></td>
                <td colspan="2" style="font-size:14px; font-weight:bold; color:${eff > 70 ? '#2ecc71' : '#e74c3c'}">${eff}%</td>
            </tr>
            <tr>
                <td>ğŸƒ ë¡œí‚¤ í™œìš©ë„<br><span style="font-size:10px; color:#888;">(í‰ê·  ì‚¬ìš© íšŸìˆ˜)</span></td>
                <td>ìŠ¹ì: <span style="color:#f1c40f; font-weight:bold;">${winLoki}íšŒ</span></td>
                <td>íŒ¨ì: <span style="color:#aaa;">${loseLoki}íšŒ</span></td>
            </tr>
        </table>`;

        html += `<div style="margin-top:15px; font-size:11px; color:#aaa; line-height:1.6;">
            í‰ê·  ì ìˆ˜: <span style="color:#eee; font-weight:bold;">${(this.stats.totalScore / total).toFixed(1)}ì </span> <br>
            í‰ê·  ê²Œì„ ê¸¸ì´: ${(this.stats.days / total).toFixed(1)}ì¼ <br>
            <span style="color:#00bfff;">ì˜¬ë¦¼í¬ìŠ¤ í• ì¸: ${(this.stats.totalSaved / total).toFixed(1)}ê°œ</span> <br>
            <span style="color:#9b59b6;">ë…¸ë¥´ë“œ ë‚­ë¹„: ${(this.stats.totalWasted / total).toFixed(1)}ì¥</span> <br>
            <span style="color:#2ecc71;">ì¼ˆíŠ¸ ë³€í™˜: ${(this.stats.totalSwaps / total).toFixed(1)}íšŒ</span>
        </div>`;

        document.getElementById('mainStats').innerHTML = `ì´ ${total} ê²Œì„ ì™„ë£Œ`;
        document.getElementById('detailStats').innerHTML = html;
    }
}
const simManager = new SimulationManager();
</script>
</body>
</html>