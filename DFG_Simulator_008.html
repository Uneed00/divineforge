<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Divine Forge: Balance Simulator (Integrated)</title>
    <style>
        body { font-family: 'Consolas', 'Monaco', monospace; background: #111; color: #eee; padding: 20px; line-height: 1.4; }
        h1, h2 { color: #f1c40f; margin-bottom: 10px; }
        
        .control-panel { background: #222; border: 1px solid #444; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .control-group { margin-bottom: 10px; display: flex; gap: 10px; align-items: center; }
        
        button { padding: 8px 16px; background: #2980b9; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-family: inherit; }
        button:hover { background: #3498db; }
        button:disabled { background: #555; cursor: not-allowed; }
        button.stop-btn { background: #c0392b; }
        
        
        
        select, input { padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        
        .grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        
        .log-area { height: 300px; overflow-y: scroll; background: #000; border: 1px solid #333; padding: 10px; font-size: 12px; color: #aaa; white-space: pre-wrap; }
        .stats-area { background: #1a1a1a; border: 1px solid #444; padding: 15px; border-radius: 8px; }
        
        table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px; }
        th, td { border: 1px solid #444; padding: 6px; text-align: center; }
        th { background: #333; color: #f1c40f; }
        
        .highlight { color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <h1>âš–ï¸ Divine Forge Simulator v9.1 (Fixed)</h1>

    
       <div class="control-panel">
        <div class="control-group">
            <label>ì‹œë®¬ë ˆì´ì…˜ íšŸìˆ˜:</label>
            <select id="simCount">
                <option value="100">100íšŒ</option>
                <option value="1000">1,000íšŒ</option>
                <option value="10000" selected>10,000íšŒ</option>
            </select>
            <button onclick="simManager.startSimulation()">â–¶ ì¶”ê°€ ì‹¤í–‰ (ëˆ„ì )</button>
            <button class="stop-btn" onclick="simManager.stopSimulation()">â¹ ì¤‘ì§€</button>
            
            <div style="width: 20px;"></div> <button onclick="simManager.resetStats()" style="background: #e67e22;">ğŸ”„ í†µê³„ ì´ˆê¸°í™”</button>
        </div>
        
        <div class="control-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #444;">
            <label style="background: #333; padding: 5px 10px; border-radius: 4px; border: 1px solid #555; cursor: pointer; display: flex; align-items: center;">
                <input type="checkbox" id="celtMimicToggle" checked style="margin-right: 8px;"> 
                <span style="color: #2ecc71; font-weight: bold;">ì¼ˆíŠ¸ 3ë‹¨ê³„ ëŠ¥ë ¥(Mimic) í™œì„±í™”</span>
            </label>
            <span style="font-size: 12px; color: #888; margin-left: 10px;">* ì²´í¬ í•´ì œ ì‹œ ì¼ˆíŠ¸ëŠ” ê¸°ë³¸ ëŠ¥ë ¥(ë¬¼ì§ˆ ë³€í™˜)ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.</span>
        </div>

        <div class="control-group">
            <span>ì‹ í™” ë°°ì •(P1~P4):</span>
            <select id="p1Myth">
                <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
                <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
                <option value="egypt">ì´ì§‘íŠ¸</option>
                <option value="nord">ë…¸ë¥´ë“œ</option>
                <option value="celt">ì¼ˆíŠ¸</option>
            </select>
            <select id="p2Myth">
                <option value="egypt" selected>ì´ì§‘íŠ¸</option>
                <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
                <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
                <option value="nord">ë…¸ë¥´ë“œ</option>
                <option value="celt">ì¼ˆíŠ¸</option>
            </select>
            <select id="p3Myth">
                <option value="nord" selected>ë…¸ë¥´ë“œ</option>
                <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
                <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
                <option value="egypt">ì´ì§‘íŠ¸</option>
                <option value="celt">ì¼ˆíŠ¸</option>
            </select>
            <select id="p4Myth">
                <option value="celt" selected>ì¼ˆíŠ¸</option>
                <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
                <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
                <option value="egypt">ì´ì§‘íŠ¸</option>
                <option value="nord">ë…¸ë¥´ë“œ</option>
            </select>
        </div>
        <details style="margin-top: 15px; background: #2c3e50; padding: 10px; border-radius: 4px; border: 1px solid #444;">
            <summary style="cursor: pointer; font-weight: bold; color: #ecf0f1;">âš™ï¸ ë°¸ëŸ°ìŠ¤ íŒŒë¼ë¯¸í„° ë¯¸ì„¸ ì¡°ì • (í´ë¦­í•˜ì—¬ ì—´ê¸°)</summary>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                    <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #00bfff;">â˜ï¸ ì˜¬ë¦¼í¬ìŠ¤ (ì¬ë£Œ í• ì¸)</h3>
                    <label style="font-size: 11px;">ë‹¨ê³„ë³„ í• ì¸ëŸ‰ (0,1,2,3ë‹¨ê³„):</label>
                    <input type="text" id="conf_olympus_discount" value="0,2,5,12" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
                </div>

                <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                    <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #9b59b6;">â„ï¸ ë…¸ë¥´ë“œ (ìˆ˜ì§‘ ê°•í™”)</h3>
                    <label style="font-size: 11px;">í•©ê³„ ì œí•œ (1,2,3ë‹¨ê³„):</label>
                    <input type="text" id="conf_nord_sum" value="6,9,14" style="width: 100%; box-sizing: border-box; margin-bottom: 5px; background: #222; border: 1px solid #555; color: white;">
                    <label style="font-size: 11px;">ì¥ìˆ˜ ì œí•œ (1,2,3ë‹¨ê³„):</label>
                    <input type="text" id="conf_nord_count" value="2,2,3" style="width: 100%; box-sizing: border-box; margin-bottom: 5px; background: #222; border: 1px solid #555; color: white;">
                    <label style="font-size: 11px;">ìˆ˜ì§‘ ì†ë„(í„´ìˆ˜ ê³„ì‚°ìš©):</label>
                    <input type="text" id="conf_nord_speed" value="3.5,7.0,7.0,10.5" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
                </div>
                
                <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                    <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #2ecc71;">â˜˜ï¸ ì¼ˆíŠ¸ (ë³€í™˜)</h3>
                    <label style="font-size: 11px;">êµí™˜ íšŸìˆ˜ (0,1,2,3ë‹¨ê³„):</label>
                    <input type="text" id="conf_celt_swap" value="0,1,2,3" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
                </div>

                <div style="background: #34495e; padding: 10px; border-radius: 4px; grid-column: span 2; border: 1px dashed #f1c40f;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #f1c40f;">ğŸ‘ï¸ ì´ì§‘íŠ¸ (í–‰ë™ ë¹„ìš© ê°ì†Œ ìƒì„¸ ì„¤ì •)</h3>
                    <table style="width: 100%; font-size: 11px; border-collapse: collapse; color: #eee;">
                        <tr style="border-bottom: 1px solid #555;">
                            <th style="text-align: left; padding: 4px; color: #aaa;">Level</th>
                            <th style="padding: 4px;">ì˜ˆì•½(Reserve)</th>
                            <th style="padding: 4px;">ìì›(Res)</th>
                            <th style="padding: 4px;">ì¶•ë³µ(Bless)</th>
                            <th style="padding: 4px;">ì œì‘(Craft)</th>
                        </tr>
                        <tr>
                            <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV1</td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l1_r" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l1_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l1_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l1_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        </tr>
                        <tr>
                            <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV2</td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l2_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l2_res" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l2_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l2_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        </tr>
                        <tr>
                            <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV3</td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l3_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l3_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l3_bls" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                            <td style="text-align: center;"><input type="number" id="conf_egypt_l3_art" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        </tr>
                    </table>
                    <div style="font-size: 11px; color: #aaa; margin-top: 5px; text-align: right;">* ê° ë ˆë²¨ ë„ë‹¬ ì‹œ í•´ë‹¹ ìˆ˜ì¹˜ë§Œí¼ ë¹„ìš©ì´ <b>ì¶”ê°€ë¡œ</b> ê°ì†Œí•©ë‹ˆë‹¤.</div>
                </div>
            </div>
            
            <div style="margin-top: 10px; text-align: right; font-size: 11px; color: #95a5a6;">
                
            </div>
        </details>
        <div id="progressBar" style="width:0%; height:4px; background:#2ecc71; transition:width 0.2s; margin-top: 10px;"></div>
    </div>
    <div class="grid-container">
        <div class="stats-area">
            <h2>ğŸ“Š í†µê³„ ê²°ê³¼</h2>
            <div id="mainStats">ëŒ€ê¸° ì¤‘...</div>
            <div id="detailStats"></div>
        </div>
        <div class="log-area" id="simLog">
            [System] ì¤€ë¹„ ì™„ë£Œ. ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•˜ì„¸ìš”.
        </div>
    </div>

<script>
// ==================================================================================
// [Part 1] Configuration & Databases (002 Ver. Integrated)
// ==================================================================================

const CONFIG = {
    MAX_TIME: 12,
    MAX_DAYS: 5,
    HAND_LIMIT: 8,
    COST: { RES: 3, BLESS: 2, ART: 2, RESERVE: 1, SWAP: 1 }
};

// 002 ë²„ì „ì˜ ë°¸ëŸ°ìŠ¤ ì»¨í”¼ê·¸ ì ìš©
const BALANCE_CONFIG = {
    // ì´ì§‘íŠ¸: ë ˆë²¨ë³„(0~2 ì¸ë±ìŠ¤) ê° í–‰ë™ì˜ ë¹„ìš© ê°ì†ŒëŸ‰ (ëˆ„ì  ì ìš©)
    EGYPT: [
        { RESERVE: 1, RES: 0, BLESS: 0, ART: 0 }, // Lv1 íš¨ê³¼
        { RESERVE: 0, RES: 1, BLESS: 0, ART: 0 }, // Lv2 íš¨ê³¼
        { RESERVE: 0, RES: 0, BLESS: 1, ART: 1 }  // Lv3 íš¨ê³¼
    ],
    NORD: { LIMIT_SUM: [6, 9, 14], LIMIT_COUNT: [2, 2, 3], GATHER_SPEED: [3.5, 7.0, 7.0, 10.5] },
    OLYMPUS: { DISCOUNT: [0, 2, 5, 12] },
    CELT: { SWAP_LIMIT: [0, 1, 2, 3] }
};
// [Added] UI ê°’ì„ ì½ì–´ì™€ ë°¸ëŸ°ìŠ¤ ì„¤ì •ì— ì ìš©í•˜ëŠ” í•¨ìˆ˜
// [ìˆ˜ì •] UI ì„¤ì • ì ìš© í•¨ìˆ˜ (ì•ˆì „ì¥ì¹˜ ì¶”ê°€)
function applyUserBalance() {
    try {
        // ìš”ì†Œê°€ ì—†ì–´ë„ ì—ëŸ¬ë‚˜ì§€ ì•Šê²Œ ì²˜ë¦¬í•˜ëŠ” ì•ˆì „ í•¨ìˆ˜
        const getElVal = (id) => {
            const el = document.getElementById(id);
            if (!el) return 0; // ìš”ì†Œê°€ ì—†ìœ¼ë©´ 0 ë°˜í™˜
            return parseInt(el.value) || 0; 
        };
        const getArrVal = (id) => {
            const el = document.getElementById(id);
            if (!el) return [];
            return el.value.split(',').map(Number);
        };

        // Olympus
        const olympusVal = getArrVal('conf_olympus_discount');
        if (olympusVal.length > 0) BALANCE_CONFIG.OLYMPUS.DISCOUNT = olympusVal;
        
        // Egypt (ìƒì„¸ ë§¤í•‘ - ìš”ì†Œê°€ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì²˜ë¦¬ë¨)
        BALANCE_CONFIG.EGYPT = [
            { // LV1
                RESERVE: getElVal('conf_egypt_l1_r'),
                RES: getElVal('conf_egypt_l1_res'),
                BLESS: getElVal('conf_egypt_l1_bls'),
                ART: getElVal('conf_egypt_l1_art')
            },
            { // LV2
                RESERVE: getElVal('conf_egypt_l2_r'), // LV2 ì˜ˆì•½ í™œì„±í™”
                RES: getElVal('conf_egypt_l2_res'),
                BLESS: getElVal('conf_egypt_l2_bls'),
                ART: getElVal('conf_egypt_l2_art')
            },
            { // LV3
                RESERVE: getElVal('conf_egypt_l3_r'), // LV3 ì˜ˆì•½ í™œì„±í™”
                RES: getElVal('conf_egypt_l3_res'),
                BLESS: getElVal('conf_egypt_l3_bls'),
                ART: getElVal('conf_egypt_l3_art')
            }
        ];

        // Nord
        const nordSum = getArrVal('conf_nord_sum');
        if (nordSum.length > 0) BALANCE_CONFIG.NORD.LIMIT_SUM = nordSum;
        
        const nordCount = getArrVal('conf_nord_count');
        if (nordCount.length > 0) BALANCE_CONFIG.NORD.LIMIT_COUNT = nordCount;
        
        const nordSpeed = getArrVal('conf_nord_speed');
        if (nordSpeed.length > 0) BALANCE_CONFIG.NORD.GATHER_SPEED = nordSpeed;

        // Celt
        const celtSwap = getArrVal('conf_celt_swap');
        if (celtSwap.length > 0) BALANCE_CONFIG.CELT.SWAP_LIMIT = celtSwap;

        console.log("[System] Custom Balance Applied Successfully.");
    } catch (e) {
        console.error("ë°¸ëŸ°ìŠ¤ ì„¤ì • ì ìš© ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", e);
        // ì—ëŸ¬ê°€ ë‚˜ë„ ì‹¤í–‰ì€ ë˜ë„ë¡ alertëŠ” ì œê±°
    }
}
const START_RULE = [
    { res: 0, bless: 0, loki: 0, score: 0 }, // P1
    { res: 0, bless: 0, loki: 0, score: 0 }, // P2
    { res: 0, bless: 0, loki: 0, score: 0 }, // P3
    { res: 0, bless: 0, loki: 0, score: 0 }  // P4
];

const RES_NAMES = { adamantite: "ì•„ë‹¤ë§Œíƒ€ì´íŠ¸", mithril: "ë¯¸ìŠ¤ë¦´", dragonBone: "ìš©ì˜ ë¼ˆ", starFragment: "ë³„ì˜ íŒŒí¸" };
const TYPE_NAMES = { nord: "ë…¸ë¥´ë“œ", egypt: "ì´ì§‘íŠ¸", olympus: "ì˜¬ë¦¼í¬ìŠ¤", celt: "ì¼ˆíŠ¸" };

// 002 ë²„ì „ì˜ ìœ ë¬¼ ë°ì´í„°ë² ì´ìŠ¤ (ê·¸ëŒ€ë¡œ ìœ ì§€)
const ARTIFACT_DB = [
    {name:"ê·€ê²ŒìŠ¤ì˜ ë°˜ì§€", type:"olympus", score:4, grade:"Bronze", cost:{adamantite:3, starFragment:3}},
    {name:"í—¤ë¥´ë©”ìŠ¤ì˜ ì‹ ë°œ", type:"olympus", score:5, grade:"Bronze", cost:{dragonBone:3, mithril:4}},
    {name:"í¬ë¦¬ì…€ë¼ì¹´í† ìŠ¤", type:"olympus", score:6, grade:"Bronze", cost:{mithril:3, starFragment:5}},
    {name:"í€´ë„¤ì—", type:"olympus", score:10, grade:"Silver", cost:{dragonBone:2, mithril:4, starFragment:5}},
    {name:"ì¼€ìŠ¤í† ìŠ¤ íˆë§ˆìŠ¤", type:"olympus", score:12, grade:"Silver", cost:{adamantite:4, starFragment:9}},
    {name:"íŠ¸ë¼ì•„ì´ë‚˜", type:"olympus", score:12, grade:"Silver", cost:{adamantite:2, dragonBone:7, mithril:3}},
    {name:"ì•„í´ë¡ ì˜ ë¦¬ë¼", type:"olympus", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:3, starFragment:6}},
    {name:"ì•„ì´ê¸°ìŠ¤", type:"olympus", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:8}},
    {name:"íí”¼ë“œì˜ í™”ì‚´", type:"olympus", score:16, grade:"Silver", cost:{adamantite:5, dragonBone:3, mithril:7, starFragment:2}},
    {name:"ì•„ë‹¤ë§ŒíŠ¸", type:"olympus", score:16, grade:"Silver", cost:{adamantite:12, dragonBone:2, starFragment:3}},
    {name:"ì•„ìŠ¤íŠ¸ë¼í˜", type:"olympus", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:5, mithril:5, starFragment:12}},
    {name:"ë§ˆì•„íŠ¸ì˜ ê¹ƒí„¸", type:"egypt", score:4, grade:"Bronze", cost:{dragonBone:3, mithril:3}},
    {name:"ì˜¤ì‹œë¦¬ìŠ¤ì˜ ì™•í™€", type:"egypt", score:5, grade:"Bronze", cost:{adamantite:2, mithril:6}},
    {name:"ì•„ëˆ„ë¹„ìŠ¤ì˜ ì €ìš¸", type:"egypt", score:6, grade:"Bronze", cost:{adamantite:2, dragonBone:6}},
    {name:"ì„¸íŠ¸ì˜ ì „ìŸ ë„ë¼", type:"egypt", score:10, grade:"Silver", cost:{adamantite:6, dragonBone:2, mithril:2}},
    {name:"ì„¸í¬ë©”íŠ¸ì˜ ì—­ë³‘", type:"egypt", score:12, grade:"Silver", cost:{adamantite:3, dragonBone:6, mithril:3}},
    {name:"í† íŠ¸ì˜ ì„œ", type:"egypt", score:12, grade:"Silver", cost:{dragonBone:2, mithril:6, starFragment:5}},
    {name:"ì•„í©ì˜ ì´ë¹¨", type:"egypt", score:14, grade:"Silver", cost:{dragonBone:7, mithril:6, starFragment:2}},
    {name:"í˜¸ë£¨ìŠ¤ì˜ ëˆˆ", type:"egypt", score:14, grade:"Silver", cost:{adamantite:4, mithril:6, starFragment:5}},
    {name:"í¬ëˆ”ì˜ ë¬¼ë ˆ", type:"egypt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:2, starFragment:5}},
    {name:"ë§Œì•¼ë¥´íŠ¸", type:"egypt", score:16, grade:"Silver", cost:{dragonBone:5, mithril:4, starFragment:8}},
    {name:"ëˆ„ì˜ í•­ì•„ë¦¬", type:"egypt", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:14, mithril:2, starFragment:6}},
    {name:"ë“œë¼ìš°í”„ë‹ˆë¥´", type:"nord", score:4, grade:"Bronze", cost:{dragonBone:4, mithril:2}},
    {name:"ë¸Œë¦¬ì‹±ê°€ë©˜", type:"nord", score:5, grade:"Bronze", cost:{mithril:3, starFragment:4}},
    {name:"ë©”ê¸´ìš”ë¥´ë“œ", type:"nord", score:6, grade:"Bronze", cost:{adamantite:9}},
    {name:"ê·¸ëŒ", type:"nord", score:10, grade:"Silver", cost:{dragonBone:3, mithril:5, starFragment:3}},
    {name:"ìŠ¤ë°œë¦°", type:"nord", score:12, grade:"Silver", cost:{adamantite:5, mithril:8}},
    {name:"ê²”ë¼ë¥´ í˜¸ë¥¸", type:"nord", score:12, grade:"Silver", cost:{dragonBone:5, mithril:5, starFragment:3}},
    {name:"ë‹¤ì¸ìŠ¬ë ˆì´í”„", type:"nord", score:14, grade:"Silver", cost:{adamantite:5, mithril:3, starFragment:7}},
    {name:"ê¶ë‹ˆë¥´", type:"nord", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:2, starFragment:6}},
    {name:"ê¸€ë ˆì´í”„ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:3, dragonBone:5, starFragment:8}},
    {name:"ë¬ ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:6, mithril:7, starFragment:4}},
    {name:"ë ˆë°”í…Œì¸", type:"nord", score:24, grade:"Gold", cost:{adamantite:11, dragonBone:4, mithril:5, starFragment:6}},
    {name:"ì˜¤í•œ", type:"celt", score:4, grade:"Bronze", cost:{adamantite:2, starFragment:4}},
    {name:"ëˆ„ì•„ë‹¤ì˜ ì€íŒ”", type:"celt", score:5, grade:"Bronze", cost:{dragonBone:4, starFragment:2}},
    {name:"ë‹¤ê·¸ë‹¤ì˜ ì†¥", type:"celt", score:6, grade:"Bronze", cost:{dragonBone:4, starFragment:4}},
    {name:"ë§ˆë‚˜ë‚œì˜ í™©ê¸ˆ ê°‘ì˜·", type:"celt", score:10, grade:"Silver", cost:{adamantite:7, starFragment:4}},
    {name:"ì¹¼ë¼ë“œë³¼ê·¸", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, mithril:5, starFragment:2}},
    {name:"í˜ë¥´ë””ì•„ì˜ ë¿”ê°€ì£½", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, dragonBone:6, mithril:2}},
    {name:"ê²Œ ë³¼ê·¸", type:"celt", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:4, mithril:4}},
    {name:"ê²Œ ë‹¤ëŸ¬ê·¸", type:"celt", score:14, grade:"Silver", cost:{dragonBone:8, starFragment:7}},
    {name:"í”„ë¼ê°€ë¼í", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:4, mithril:8}},
    {name:"ê²Œ ë¹„ì–´", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:4, starFragment:2}},
    {name:"ë¸Œë¥˜ë‚˜í¬", type:"celt", score:24, grade:"Gold", cost:{dragonBone:5, mithril:17, starFragment:3}}
];

// 002 ë²„ì „ì˜ ë¡œí‚¤ DB (32ì¥ í’€ ì„¸íŠ¸)
const LOKI_DB = [
    {id:1,name:"êµ¬ë¶€ëŸ¬ì§„ ì‹œê³—ë°”ëŠ˜",desc:"ì‚¬ìš© ì‹œ ì‹œê°„ -1H",type:"active_time", count:4},
    {id:2,name:"ë§ê°ì˜ ì£¼íŒ",desc:"êµí™˜",type:"active_swap", count:1},
    {id:3,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì¼ˆíŠ¸",type:"bless_split",tags:['nord','celt'], count:1},
    {id:4,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì´ì§‘íŠ¸",type:"bless_split",tags:['nord','egypt'], count:1},
    {id:5,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì˜¬ë¦¼í¬ìŠ¤",type:"bless_split",tags:['nord','olympus'], count:1},
    {id:6,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì´ì§‘íŠ¸",type:"bless_split",tags:['olympus','egypt'], count:1},
    {id:7,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì´ì§‘íŠ¸ / ì¼ˆíŠ¸",type:"bless_split",tags:['egypt','celt'], count:1},
    {id:8,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì¼ˆíŠ¸",type:"bless_split",tags:['olympus','celt'], count:1},
    {id:9,name:"í˜¼ëˆì˜ ì±„ì„ë§ì¹˜",desc:"ì‹œì¥ êµì²´",type:"active_reset", count:1},
    {id:10,name:"ë¶€ì„œì§„ íšŒì¤‘ì‹œê³„",desc:"ë¬´ë£Œ ì œì‘",type:"passive_free", count:1},
    {id:11,name:"ê³„ìŠ¹ìì˜ ë¬¸ì¥",desc:"+2ì ",type:"instant_score", count:4},
    {id:12,name:"ë¯¸ë˜ ì¼ê¸°",desc:"ë¯¸ë˜ ì—¿ë³´ê¸°",type:"active_peek", count:1},
    {id:13,name:"ê²€ì€ ì£¼ì‚¬ìœ„",desc:"ë“œë¡œìš°",type:"active_draw", count:1},
    {id:14,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'dragonBone',val:4}], count:1},
    {id:15,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'mithril',val:4}], count:1},
    {id:16,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'adamantite',val:4}], count:1},
    {id:17,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'dragonBone',val:4}], count:1},
    {id:18,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'mithril',val:4}], count:1},
    {id:19,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'dragonBone',val:4},{type:'mithril',val:4}], count:1},
    {id:20,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'dragonBone',val:2}], count:1},
    {id:21,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'mithril',val:2}], count:1},
    {id:22,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'mithril',val:2}], count:1},
    {id:23,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'starFragment',val:2}], count:1},
    {id:24,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'starFragment',val:2},{type:'mithril',val:2}], count:1},
    {id:25,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'starFragment',val:2}], count:1},
    {id:26,name:"íŒŒê´´ëœ ì„±ë°°",desc:"ì¶•ë³µ êµì²´",type:"active_reset_bless", count:1}
];

class Card {
    constructor(cat, type, val = null, extra = null) {
        this.cat = cat;
        this.type = type; 
        this.val = val; 
        this.extra = extra;
        this.id = Math.random().toString(36).substr(2, 9);
    }
}

class Deck {
    constructor(cat) {
        this.cat = cat;
        this.cards = [];
        this.discardPile = [];
        this.init();
    }

    init() {
        if (this.cat === 'resource') {
            const types = Object.keys(RES_NAMES);
            const vals = [2, 3, 4, 5, 6, 7];
            types.forEach(t => vals.forEach(v => {
                for (let i = 0; i < 3; i++) this.cards.push(new Card('resource', t, v));
            }));
        } else if (this.cat === 'blessing') {
            const types = Object.keys(TYPE_NAMES);
            types.forEach(t => {
                for (let i = 0; i < 8; i++) this.cards.push(new Card('blessing', t));
            });
        } else if (this.cat === 'artifact') {
            ARTIFACT_DB.forEach(art => this.cards.push({ ...art })); 
        } else if (this.cat === 'loki') {
            LOKI_DB.forEach(def => {
                for(let i=0; i<def.count; i++) {
                    this.cards.push(new Card('loki', 'loki', null, def));
                }
            });
        }
        this.shuffle();
    }

    shuffle() { this.cards.sort(() => Math.random() - 0.5); }

    draw() {
        if (this.cards.length === 0) {
            if (this.cat === 'loki' || this.discardPile.length === 0) return null;
            this.cards = [...this.discardPile];
            this.discardPile = [];
            this.shuffle();
        }
        return this.cards.pop();
    }

    peek(count) { return this.cards.slice(-count).reverse(); } // ë¯¸ë˜ì¼ê¸°ìš©

    discard(card) { this.discardPile.push(card); }
    getCount() { return this.cards.length; }
}

class Player {
    constructor(id) {
        this.id = id;
        this.hand = [];
        this.reserved = [];
        this.artifacts = [];
        this.score = 0;
        this.time = 0;
        this.stackOrder = 0;
        this.targetMyth = null; 
        this.celtConvertCount = 0;
        this.celtMimicMode = null;
        this.aiTargetIdx = null;
        this.olympusDiscount = { type: null, amount: 0 };
        
        // [ìˆ˜ì •ë¨] í†µê³„ ë° ì—‘ì…€ ë¶„ì„ìš© ë°ì´í„° ì¶”ê°€
        this.dailyScore = [-1, -1, -1, -1, -1]; 
        this.metrics = { 
            savedRes: 0, wastedCards: 0, celtSwaps: 0,
            resAcquired: 0, resConsumed: 0, lokiUsed: 0      
        };
        this.milestones = {}; 
        this.history = []; // ë§¤ì¼ ë°¤ ìœ ë¬¼ ìƒíƒœ ê¸°ë¡
    }

    getHandCount() {
        return this.hand.filter(c => c.cat !== 'loki').length;
    }
}

// ==========================================
// [Part 2] Game Engine (Core Logic - UI Free)
// ==========================================

class Game {
    constructor() {
        this.isInitialized = false;
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        this.players = [];
        this.pIdx = 0;
    }

    init(mythAssignments) {
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        
        this.players = [new Player(1), new Player(2), new Player(3), new Player(4)];
        this.players.forEach((p, i) => {
            p.targetMyth = mythAssignments ? mythAssignments[i] : ['olympus', 'egypt', 'nord', 'celt'][i];
            const rule = START_RULE[i];
            p.score = rule.score;
            p.stackOrder = 3 - i; 
        });

        this.deckRes = new Deck('resource');
        this.deckBless = new Deck('blessing');
        this.deckArt = new Deck('artifact');
        this.deckLoki = new Deck('loki');

        this.fieldRes = [];
        this.fieldBless = [];
        this.fieldArt = [];

        this.fill('resource', 6);
        this.fill('blessing', 4);
        this.fill('artifact', 7);

        this.players.forEach((p, i) => {
            const rule = START_RULE[i];
            for(let k=0; k<rule.res; k++) { const c = this.deckRes.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.bless; k++) { const c = this.deckBless.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.loki; k++) { const c = this.deckLoki.draw(); if(c) p.hand.push(c); }
        });

        this.pIdx = 0;
        this.isInitialized = true;
    }

    get cp() { return this.players[this.pIdx]; }

    fill(cat, max) {
        const field = cat === 'resource' ? this.fieldRes : (cat === 'blessing' ? this.fieldBless : this.fieldArt);
        const deck = cat === 'resource' ? this.deckRes : (cat === 'blessing' ? this.deckBless : this.deckArt);
        while(field.length < max) {
            const c = deck.draw();
            if(c) field.push(c);
            else break;
        }
    }

    getArtLevel(type) {
        const p = this.cp;
        let count = p.artifacts.filter(a => a.type === type).length;
        const celtCount = p.artifacts.filter(a => a.type === 'celt').length;
        // ì¼ˆíŠ¸ 3ë‹¨ê³„ ë¯¸ë¯¹ ì ìš©
        if (type !== 'celt' && celtCount >= 3 && p.celtMimicMode === type) count += 1;
        // ì¼ˆíŠ¸ ìì‹ ì€ ë¯¸ë¯¹ íš¨ê³¼ ëª» ë°›ìŒ (ì´ë¯¸ 3ì¥ì´ë¯€ë¡œ ì˜ë¯¸ ì—†ê¸°ë„ í•¨)
        if (type === 'celt' && celtCount >= 3 && p.celtMimicMode !== null) return 0;
        return count;
    }

    getCost(action) {
        let cost = CONFIG.COST[action];
        const egyptLv = this.getArtLevel('egypt');
        
        // ì´ì§‘íŠ¸ í• ì¸ ì ìš© (ëˆ„ì  ë°©ì‹)
        let discount = 0;
        const maxLevel = Math.min(egyptLv, 3);
        
        for (let i = 0; i < maxLevel; i++) {
            // BALANCE_CONFIGê°€ ë°°ì—´ì¸ì§€ í™•ì¸í•˜ê³  ì•ˆì „í•˜ê²Œ ì ‘ê·¼
            if (Array.isArray(BALANCE_CONFIG.EGYPT)) {
                const levelConfig = BALANCE_CONFIG.EGYPT[i];
                if (levelConfig) {
                    if (action === 'RESERVE') discount += levelConfig.RESERVE;
                    else if (action === 'RES') discount += levelConfig.RES;
                    else if (action === 'BLESS') discount += levelConfig.BLESS;
                    else if (action === 'ART') discount += levelConfig.ART;
                }
            } else {
                // êµ¬ë²„ì „ í˜¸í™˜ìš© (í˜¹ì‹œ ëª¨ë¥¼ ì—ëŸ¬ ë°©ì§€)
                if (action === 'RESERVE' && i === 0) discount += 1;
                if (action === 'RES' && i === 1) discount += 1;
                if ((action === 'BLESS' || action === 'ART') && i === 2) discount += 1;
            }
        }
        
        cost -= discount;
        return Math.max(0, cost);
    }

    consumeTime(amount) {
        const p = this.cp;
        const targetTime = p.time + amount;
        let maxStack = -1;
        this.players.forEach(other => {
            if (other.id !== p.id && other.time === targetTime) {
                if (other.stackOrder > maxStack) maxStack = other.stackOrder;
            }
        });
        p.time = targetTime;
        p.stackOrder = maxStack + 1;
        this.determineNextTurn();
    }

    determineNextTurn() {
        if (this.isGameEnded) return;
        if (this.players.every(p => p.time >= CONFIG.MAX_TIME)) { this.processDayEnd(); return; }
        
        let candidates = this.players.filter(p => p.time < CONFIG.MAX_TIME);
        if (candidates.length === 0) { this.processDayEnd(); return; }

        candidates.sort((a, b) => {
            if (a.time !== b.time) return a.time - b.time;
            return b.stackOrder - a.stackOrder;
        });

        const nextPlayer = candidates[0];
        if (this.cp.id !== nextPlayer.id) {
            this.pIdx = this.players.indexOf(nextPlayer);
            this.cp.celtConvertCount = 0; // í„´ ë³€ê²½ ì‹œ ì¼ˆíŠ¸ ì¹´ìš´íŠ¸ ë¦¬ì…‹
        }
    }

   processDayEnd() {
        this.players.forEach(p => {
            // 1. ì ìˆ˜ ê¸°ë¡
            if (this.day <= 5) p.dailyScore[this.day - 1] = p.score;
            
            // 2. [ì¶”ê°€ë¨] ìœ ë¬¼ ìƒíƒœ ìŠ¤ëƒ…ìƒ· ê¸°ë¡ (ì—‘ì…€ ë¶„ì„ìš©)
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(a => { if(counts[a.type] !== undefined) counts[a.type]++; });
            
            p.history.push({
                day: this.day,
                score: p.score,
                olympus: counts.olympus,
                egypt: counts.egypt,
                nord: counts.nord,
                celt: counts.celt
            });
        });

        if (this.day >= CONFIG.MAX_DAYS) { this.endGame(); return; }
        
        this.processNightInstant();
        this.day++;
        
        this.fieldRes.forEach(c => this.deckRes.discard(c)); this.fieldRes = [];
        this.fieldBless.forEach(c => this.deckBless.discard(c)); this.fieldBless = [];
        this.fill('resource', 6); this.fill('blessing', 4);

        this.players.forEach(p => { p.time = Math.max(0, p.time - CONFIG.MAX_TIME); });

        if (this.day > CONFIG.MAX_DAYS) this.endGame();
        else this.determineNextTurn();
    }
    processNightInstant() {
        let offers = [];
        for(let i=0; i<6; i++) offers.push(this.deckLoki.draw());
        let selections = {};
        this.players.forEach(p => { selections[p.id] = Math.floor(Math.random() * 6); });
        let counts = {};
        Object.values(selections).forEach(slot => { counts[slot] = (counts[slot] || 0) + 1; });

        this.players.forEach(p => {
            const choice = selections[p.id];
            if (counts[choice] === 1 && offers[choice]) {
                const item = offers[choice];
                if (item.extra.type === 'instant_score') p.score += 2;
                else p.hand.push(item);
            }
        });
    }

    endGame() {
        if (this.isGameEnded) return;
        this.isGameEnded = true;
        this.players.forEach(p => {
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(art => { if(counts[art.type] !== undefined) counts[art.type]++; });
            
            // 4ì¢… í†µí•© ë³´ë„ˆìŠ¤
            if(counts.olympus > 0 && counts.egypt > 0 && counts.nord > 0 && counts.celt > 0) p.score += 5;
            
            // ì‹ í™” ì „ë¬¸í™” ë³´ë„ˆìŠ¤
            for(const [type, count] of Object.entries(counts)) {
                if(count >= 4) p.score += (count - 3) * 2;
            }
        });
    }
}

// ==========================================
// [Part 3] AI Brain (Transplanted from 002)
// ==========================================

// 1. [íƒœì„¸ ì „í™˜] ì¼ˆíŠ¸ 3ë‹¨ê³„ ëŠ¥ë ¥ ìë™ ìŠ¤ìœ„ì¹­
Game.prototype.aiAutoSwitchCeltMode = function(plan) {
    const isMimicEnabled = document.getElementById('celtMimicToggle') ? document.getElementById('celtMimicToggle').checked : true;
    if (!isMimicEnabled) return;

    const ai = this.cp;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    if (realCeltCount < 3) return;

    let targetMode = null; // ê¸°ë³¸ê°’ null (ì¼ˆíŠ¸ ë³¸ì²´)

    if (plan.preferredMode) {
        // ê³„ì‚°ëœ ìµœì  ëª¨ë“œê°€ ìˆë‹¤ë©´ ê·¸ê²ƒì„ ë”°ë¦„
        targetMode = plan.preferredMode === 'celt' ? null : plan.preferredMode;
    } else {
        // planì— ì •ë³´ê°€ ì—†ì„ ê²½ìš°(ë¹„ìƒì‹œ) ê¸°ì¡´ ë¡œì§ ì¼ë¶€ ì°¨ìš©
        if (plan.action === 'GATHER' && ai.getHandCount() <= 4) targetMode = 'nord';
        else if (ai.time >= 9) targetMode = 'egypt';
    }

    // ëª¨ë“œ ë³€ê²½ ì‹¤í–‰
    if (ai.celtMimicMode !== targetMode) {
        ai.celtMimicMode = targetMode;
        // console.log(`[AI] ì¼ˆíŠ¸ íƒœì„¸ ì „í™˜: ${ai.celtMimicMode || 'ì¼ˆíŠ¸(ë³¸ì²´)'}`); // ë””ë²„ê¹…ìš©
    }
};

// ==================================================================================
// [Final Patch] ì¼ˆíŠ¸/ë…¸ë¥´ë“œ/ì´ì§‘íŠ¸ AI ë…¼ë¦¬ ì™„ì „ ë¬´ê²°ì„± íŒ¨ì¹˜
// ==================================================================================

// 1. [ê°€ì¹˜ íŒë‹¨] ì ì¬ë ¥(Potential)ì„ í¬í•¨í•œ ìµœì  ê²½ë¡œ ê³„ì‚°
Game.prototype.aiCalculateTargetValue = function(art, isReserved) {
    const ai = this.cp;
    
    // [í•µì‹¬] ì‹¤ì œ ì¼ˆíŠ¸ ìœ ë¬¼ ì¥ìˆ˜ í™•ì¸ (ë¯¸ë¯¹ ì¤‘ì´ì–´ë„ ë³¸ì²´ ìŠ¤í™ ìœ ì§€)
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    const canMimic = realCeltCount >= 3; 
    const baseCeltLv = canMimic ? 3 : this.getArtLevel('celt');

    // í•¸ë“œ ìì› íŒŒì•…
    const myRes = { adamantite:0, mithril:0, dragonBone:0, starFragment:0 };
    let totalHandCount = 0;
    ai.hand.forEach(c => {
        totalHandCount++;
        if (c.cat === 'resource') myRes[c.type] = (myRes[c.type]||0) + c.val;
        else if (c.cat === 'loki' && c.extra.type === 'res_split') {
            let type = c.extra.options[0].type; 
            myRes[type] = (myRes[type]||0) + 4;
        }
    });

    // ì‹œë‚˜ë¦¬ì˜¤(íƒœì„¸)ë³„ íš¨ìœ¨ ê³„ì‚°
    const calculateScenario = (mode) => {
        let simOlympusLv = this.getArtLevel('olympus');
        let simCeltLv = this.getArtLevel('celt');

        // ë¯¸ë¯¹ ì‹œë®¬ë ˆì´ì…˜: í•´ë‹¹ ëª¨ë“œë¡œ ë³€ì‹ í–ˆì„ ë•Œì˜ ë ˆë²¨ ì ìš©
        if (canMimic) {
            if (mode === 'olympus') { simOlympusLv = Math.max(simOlympusLv, 3); simCeltLv = 0; }
            else if (mode === 'celt') { simCeltLv = 3; } 
            else if (mode === 'nord') { simCeltLv = 0; }
            else if (mode === 'egypt') { simCeltLv = 0; }
        }

        // [ì˜¬ë¦¼í¬ìŠ¤] ë‹¨ì¼ ìì› í• ì¸ (ê¸°ì¡´ ë£° ìœ ì§€)
        let tempCost = { ...art.cost };
        let discountAmt = 0;
        let discountType = null;
        if (simOlympusLv > 0) {
            discountAmt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(simOlympusLv, 3)];
            let maxSaved = -1;
            for(let t in tempCost) {
                if(tempCost[t] > 0) {
                    let saved = Math.min(tempCost[t], discountAmt);
                    if(saved > maxSaved) { maxSaved = saved; discountType = t; }
                }
            }
            if(discountType) tempCost[discountType] = Math.max(0, tempCost[discountType] - discountAmt);
        }

        // [ì¼ˆíŠ¸] ìì› ë¶€ì¡±ë¶„ ë° ë³€í™˜ í•„ìš” ì—¬ë¶€
        let missing = 0;
        let availableSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(simCeltLv, 3)] - ai.celtConvertCount;
        let needsSwap = false;
        let tempHandCount = totalHandCount;

        for(let t in tempCost) {
            let need = Math.max(0, tempCost[t] - (myRes[t]||0));
            if (need > 0 && availableSwaps > 0) {
                const cardsNeeded = Math.ceil(need / 4);
                if (tempHandCount >= cardsNeeded && availableSwaps >= cardsNeeded) {
                    availableSwaps -= cardsNeeded;
                    tempHandCount -= cardsNeeded;
                    need = 0;
                    needsSwap = true;
                }
            }
            missing += need;
        }
        return { missing, needsSwap, discountType, mode };
    };

    // ìµœì  ì‹œë‚˜ë¦¬ì˜¤ ì„ íƒ (í• ì¸ vs ë³€í™˜)
    let bestScenario = calculateScenario(ai.celtMimicMode || 'celt'); // ê¸°ë³¸ê°’
    
    if (canMimic) {
        const scenarioOlympus = calculateScenario('olympus');
        const scenarioCelt = calculateScenario('celt');
        
        if (scenarioOlympus.missing <= 0 && scenarioCelt.missing > 0) bestScenario = scenarioOlympus;
        else if (scenarioCelt.missing <= 0 && scenarioOlympus.missing > 0) bestScenario = scenarioCelt;
        else if (scenarioOlympus.missing <= 0 && scenarioCelt.missing <= 0) bestScenario = scenarioOlympus; 
        else {
            // ë‘˜ ë‹¤ ë¶€ì¡±í•˜ë©´ ë¶€ì¡±ë¶„ì´ ì ì€ ìª½ ì„ íƒ
            if (scenarioOlympus.missing < scenarioCelt.missing) bestScenario = scenarioOlympus;
            else bestScenario = scenarioCelt;
        }
    }

    // [ì ìˆ˜ ê³„ì‚°] Net Value
    let action = bestScenario.missing <= 0 ? 'CRAFT' : 'GATHER';
    let net = art.score * 10;
    
    if (ai.targetMyth && art.type === ai.targetMyth) net += 100;

    if (action === 'CRAFT') {
        net += 5000;
        if (isReserved) net += 2000;
        if (bestScenario.needsSwap) net += 50; 
    } else {
        net += Math.max(0, 500 - bestScenario.missing * 5);
        
        // [ìˆ˜ì •ë¨] ìˆ˜ì§‘ ì†ë„ ê³„ì‚° ì‹œ 'ì ì¬ì  ë…¸ë¥´ë“œ ë ˆë²¨' ë°˜ì˜
        let effectiveNordLv = this.getArtLevel('nord');
        if (canMimic) effectiveNordLv = Math.max(effectiveNordLv, 3); // ë¯¸ë¯¹ ê°€ëŠ¥í•˜ë©´ 3ë ˆë²¨ ì†ë„ë¡œ ê°€ì •
        
        let speed = BALANCE_CONFIG.NORD.GATHER_SPEED[Math.min(effectiveNordLv, 3)];
        let turns = Math.ceil(bestScenario.missing / speed);
        net -= (turns * 10);
    }

    // [ì´ì§‘íŠ¸] ì‹œê°„ ê°€ì¹˜ ë°˜ì˜
    let timeCost = CONFIG.COST[action];
    const egyptLv = this.getArtLevel('egypt');
    // ë‹¨ìˆœí™”: ì´ì§‘íŠ¸ ë ˆë²¨ì´ ìˆìœ¼ë©´ ëŒ€ëµì ì¸ í• ì¸ ê¸°ëŒ€ì¹˜ ë°˜ì˜
    if (egyptLv > 0 || (canMimic && action === 'GATHER')) { // ìˆ˜ì§‘ ì‹œì—” ì´ì§‘íŠ¸ í‰ë‚´ ë‚¼ ìˆ˜ë„ ìˆìœ¼ë‹ˆ ê°€ì‚°ì 
         if (egyptLv >= 1 || canMimic) timeCost -= 1; 
    }
    
    if (timeCost <= 0) net += 150; 
    else if (timeCost < CONFIG.COST[action]) net += 50;

    // ì¶•ë³µ ì²´í¬
    const hasBless = ai.hand.some(c => (c.cat === 'blessing' && c.type === art.type) || 
        (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
    
    if (!hasBless && !canMimic && baseCeltLv < 3) net -= 5000;

    return { 
        art, netValue: net, action, fromReserve: isReserved, 
        discountType: bestScenario.discountType, targetIdx: -1, 
        needBless: (!hasBless && !canMimic && baseCeltLv < 3),
        missingVal: bestScenario.missing,
        preferredMode: bestScenario.mode
    };
};

// 2. [íƒœì„¸ ì „í™˜] AI í–‰ë™ ì‹¤í–‰ ì „ ìë™ ë³€ì‹ 
Game.prototype.aiAutoSwitchCeltMode = function(plan) {
    const isMimicEnabled = document.getElementById('celtMimicToggle') ? document.getElementById('celtMimicToggle').checked : true;
    if (!isMimicEnabled) return;

    const ai = this.cp;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    if (realCeltCount < 3) return;

    let targetMode = null; // ê¸°ë³¸: ì¼ˆíŠ¸ ë³¸ì²´

    if (plan.preferredMode) {
        // ê³„ì‚°ëœ ìµœì  ëª¨ë“œë¡œ ì „í™˜
        // 'celt' ëª¨ë“œë¼ë©´ ë¯¸ë¯¹ì„ í•´ì œ(null)í•´ì•¼ í•¨
        targetMode = plan.preferredMode === 'celt' ? null : plan.preferredMode;
    } else {
        // ë¹„ìƒ í”Œëœ
        if (plan.action === 'GATHER' && ai.getHandCount() <= 4) targetMode = 'nord';
        else if (ai.time >= 9) targetMode = 'egypt';
    }

    if (ai.celtMimicMode !== targetMode) {
        ai.celtMimicMode = targetMode;
    }
};

// 3. [ë…¸ë¥´ë“œ ìˆ˜ì§‘] 2ì¥/3ì¥ ì¡°í•© ì™„ì „ íƒìƒ‰
Game.prototype.aiTryNordAction = function(targetArt) {
    const ai = this.cp;
    if (ai.getHandCount() >= 6) return false; 

    const nordLv = this.getArtLevel('nord');
    const limitSum = BALANCE_CONFIG.NORD.LIMIT_SUM[Math.min(nordLv, 3)];
    const limitCount = BALANCE_CONFIG.NORD.LIMIT_COUNT[Math.min(nordLv, 3)];

    let indices = this.fieldRes.map((_, i) => i);
    let bestCombo = null;
    let bestScore = -1;

    // 2ì¥ ì¡°í•©
    if (limitCount >= 2) {
        for (let i = 0; i < indices.length; i++) {
            for (let j = i + 1; j < indices.length; j++) {
                const c1 = this.fieldRes[i];
                const c2 = this.fieldRes[j];
                if (c1.val + c2.val <= limitSum) {
                    let score = c1.val + c2.val;
                    if (targetArt.cost[c1.type] > 0) score += 10;
                    if (targetArt.cost[c2.type] > 0) score += 10;
                    if (score > bestScore) { bestScore = score; bestCombo = [i, j]; }
                }
            }
        }
    }

    // 3ì¥ ì¡°í•© (ëˆ„ë½ë˜ì—ˆë˜ ë¶€ë¶„ ì¶”ê°€)
    if (limitCount >= 3) {
        for (let i = 0; i < indices.length; i++) {
            for (let j = i + 1; j < indices.length; j++) {
                for (let k = j + 1; k < indices.length; k++) {
                    const c1 = this.fieldRes[i];
                    const c2 = this.fieldRes[j];
                    const c3 = this.fieldRes[k];
                    
                    if (c1.val + c2.val + c3.val <= limitSum) {
                        let score = c1.val + c2.val + c3.val;
                        if (targetArt.cost[c1.type] > 0) score += 10;
                        if (targetArt.cost[c2.type] > 0) score += 10;
                        if (targetArt.cost[c3.type] > 0) score += 10;
                        score += 20; // 3ì¥ ìˆ˜ì§‘ì€ íš¨ìœ¨ì´ ì••ë„ì ì´ë¯€ë¡œ ë†’ì€ ê°€ì‚°ì 
                        
                        if (score > bestScore) { bestScore = score; bestCombo = [i, j, k]; }
                    }
                }
            }
        }
    }

    if (bestCombo) {
        bestCombo.sort((a, b) => b - a); // ë’¤ì—ì„œë¶€í„° ì‚­ì œ
        bestCombo.forEach(idx => {
            ai.hand.push(this.fieldRes[idx]);
            ai.metrics.resAcquired += this.fieldRes[idx].val; 
            this.fieldRes.splice(idx, 1);
        });
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES'));
        return true;
    }
    return false;
};

// 3. [ì „ëµ ìˆ˜ë¦½] ìµœì  ê³„íš ì°¾ê¸°
Game.prototype.aiFindBestPlan = function() {
    const ai = this.cp;
    let bestScore = -Infinity;
    let bestPlan = null;

    // ë§ê°ì˜ ì£¼íŒ ê° (002 ì „ìˆ )
    const abacusIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_swap');
    if (abacusIdx !== -1 && ai.reserved.length > 0 && this.fieldArt.length > 0) {
        let worstRes = { score: 999, idx: -1 };
        ai.reserved.forEach((art, i) => { if(art.score < worstRes.score) worstRes = {score: art.score, idx: i}; });
        let bestMkt = { score: -1, idx: -1 };
        this.fieldArt.forEach((art, i) => { if(art.score > bestMkt.score) bestMkt = {score: art.score, idx: i}; });
        
        if (bestMkt.score - worstRes.score >= 6) {
            return { action: 'SWAP_ARTIFACT', handIdx: abacusIdx, reserveIdx: worstRes.idx, marketIdx: bestMkt.idx };
        }
    }

    ai.reserved.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, true);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    this.fieldArt.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, false);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    return bestPlan;
};

// 4. [ì „ìˆ  ì‹¤í–‰] ë¡œí‚¤ ì „ìˆ  (UI ì—†ìŒ)
Game.prototype.aiPlayLokiTactics = function() {
    const ai = this.cp;
    
    // ê³„ìŠ¹ìì˜ ë¬¸ì¥
    const crestIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'instant_score');
    if (crestIdx !== -1) { 
        ai.score += 2; 
        ai.hand.splice(crestIdx, 1); 
        ai.metrics.lokiUsed++; // [Fix]
        return true; 
    }

    // ì‹œê³—ë°”ëŠ˜
    const clockIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_time');
    if (clockIdx !== -1) {
        if (ai.time >= 9 || (ai.score < 10 && ai.time >= 7)) {
            ai.time = Math.max(0, ai.time - 1); 
            ai.hand.splice(clockIdx, 1); 
            ai.metrics.lokiUsed++; // [Fix]
            return true;
        }
    }

    // ê²€ì€ ì£¼ì‚¬ìœ„
    const diceIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_draw');
    if (diceIdx !== -1) {
        const junkIndices = ai.hand.map((c, i) => (c.cat === 'resource' && c.val <= 3) ? i : -1).filter(i => i !== -1);
        if (junkIndices.length >= 2) {
            ai.hand.splice(junkIndices[1], 1); ai.hand.splice(junkIndices[0], 1); ai.hand.splice(diceIdx, 1);
            for(let k=0; k<2; k++) { 
                const newCard = this.deckRes.draw(); 
                if(newCard) {
                    ai.hand.push(newCard);
                    ai.metrics.resAcquired += newCard.val; // [Fix] ì£¼ì‚¬ìœ„ë¡œ ë½‘ì€ ìì›ë„ íšë“ì— í¬í•¨
                }
            }
            ai.metrics.lokiUsed++; // [Fix]
            this.consumeTime(1); return true;
        }
    }

    return false;
};

// 5. [í–‰ë™ ì‹¤í–‰] ì œì‘ íŠ¸ëœì­ì…˜ (UI ì—†ìŒ, ë¡œì§ë§Œ ìˆ˜í–‰)
Game.prototype.processCraftTransaction = function(ai, plan) {
    const art = plan.art;
    const fromReserve = plan.fromReserve;
    let requirements = { ...art.cost };
    let olympusSavedAmount = 0;

    if (plan.discountType) {
        const olympusLv = this.getArtLevel('olympus');
        const amt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(olympusLv, 3)];
        requirements[plan.discountType] = Math.max(0, requirements[plan.discountType] - amt);
        olympusSavedAmount = amt;
    }

    let cardsToPay = [];
    let hand = [...ai.hand];
    
    // ìì› ì°¨ê°
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'resource' && c.type === reqType) {
                needed -= c.val;
                cardsToPay.push(c);
                hand.splice(i, 1);
                ai.metrics.resConsumed += c.val; // [Fix] ì†Œëª¨ëŸ‰ ê¸°ë¡
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }

    // ë¡œí‚¤ ì°¨ê° (ìì› ëŒ€ì²´)
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal;
        if (needed <= 0) continue;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'loki' && c.extra.type === 'res_split') {
                if (c.extra.options.some(opt => opt.type === reqType)) {
                    needed -= 4; cardsToPay.push(c); hand.splice(i, 1);
                }
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }

    // ì¼ˆíŠ¸ ë³€í™˜
    const celtLv = this.getArtLevel('celt');
    const maxSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(celtLv, 3)];
    let usedSwaps = 0;
    let currentTotalSwaps = ai.celtConvertCount;

    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal;
        if (needed <= 0) continue;
        if (currentTotalSwaps < maxSwaps) {
            for (let i = hand.length - 1; i >= 0; i--) {
                if (needed <= 0 || currentTotalSwaps >= maxSwaps) break;
                let c = hand[i];
                if (c.cat === 'resource') {
                    needed -= c.val; cardsToPay.push(c); hand.splice(i, 1);
                    usedSwaps++; currentTotalSwaps++;
                    ai.metrics.resConsumed += c.val; // [Fix] ë³€í™˜ëœ ìì›ë„ ì†Œëª¨ë¡œ ê¸°ë¡
                }
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }

    if (Object.values(requirements).reduce((a,b)=>a+b, 0) > 0) return false;

    // ì¶•ë³µ
    if (celtLv < 3) {
         let blessIdx = hand.findIndex(c => (c.cat === 'blessing' && c.type === art.type) || (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
         if (blessIdx === -1 && celtLv >= 2) blessIdx = hand.findIndex(c => c.cat === 'blessing');
         if (blessIdx !== -1) { cardsToPay.push(hand[blessIdx]); hand.splice(blessIdx, 1); } 
         else return false;
    }

    // ê¸°ë¡ ë° ì»¤ë°‹
    if (olympusSavedAmount > 0) ai.metrics.savedRes += olympusSavedAmount;
    if (usedSwaps > 0) { ai.metrics.celtSwaps += usedSwaps; ai.celtConvertCount += usedSwaps; }

    ai.hand = hand;
    cardsToPay.forEach(c => {
        if(c.cat === 'resource') this.deckRes.discard(c);
        else if(c.cat === 'blessing') this.deckBless.discard(c);
    });

    let scoreBonus = 0;
    if (art.score >= 24) scoreBonus = 4; else if (art.score >= 10) scoreBonus = 3; else scoreBonus = 2;
    
    const craftedArt = { ...art, isGrace: true, finalScore: art.score + scoreBonus, bonus: scoreBonus };
    ai.artifacts.push(craftedArt);
    ai.score += craftedArt.finalScore;

    // ë§ˆì¼ìŠ¤í†¤
    const typeCount = ai.artifacts.filter(a => a.type === craftedArt.type).length;
    if (typeCount === 3 && ai.milestones[craftedArt.type] === undefined) {
        ai.milestones[craftedArt.type] = this.craftOrder++; 
    }

    if (fromReserve) ai.reserved.splice(plan.targetIdx, 1);
    else { this.fieldArt.splice(plan.targetIdx, 1); this.fill('artifact', 7); }
    
    // [Fix] ë¡œí‚¤(íšŒì¤‘ì‹œê³„) ì‚¬ìš© ê¸°ë¡
    const freeCardIdx = cardsToPay.findIndex(c => c.cat === 'loki' && c.extra.type === 'passive_free');
    if (freeCardIdx !== -1) {
        ai.metrics.lokiUsed++; 
        this.consumeTime(0);
    }
    else this.consumeTime(this.getCost('ART'));

    return true;
};

// 6. [AI ë©”ì¸] í„´ ì‹¤í–‰ í•¨ìˆ˜
Game.prototype.aiTurn = function() {
    const ai = this.cp;
    if (this.isGameEnded || ai.time >= CONFIG.MAX_TIME) return;

    // 1. í•¸ë“œ ì •ë¦¬
    if (ai.getHandCount() > CONFIG.HAND_LIMIT) { 
        this.aiSmartDiscard(ai); 
        return; 
    }

    // 2. ë¡œí‚¤ ì „ìˆ 
    if (this.aiPlayLokiTactics()) return;

    // 3. ì „ëµ ìˆ˜ë¦½
    const bestPlan = this.aiFindBestPlan();
    
    if (!bestPlan) { 
        this.aiEmergencyAction(); 
        return; 
    }

    // íƒœì„¸ ì „í™˜
    this.aiAutoSwitchCeltMode(bestPlan);
    ai.aiTargetIdx = bestPlan.targetIdx;

    // 4. í–‰ë™ ì‹¤í–‰
    if (bestPlan.action === 'SWAP_ARTIFACT') {
        // êµí™˜ ì‹¤í–‰ (ë¡œì§ë§Œ)
        const myArt = ai.reserved[bestPlan.reserveIdx];
        const marketArt = this.fieldArt[bestPlan.marketIdx];
        ai.reserved[bestPlan.reserveIdx] = marketArt;
        this.fieldArt[bestPlan.marketIdx] = myArt;
        ai.hand.splice(bestPlan.handIdx, 1);
        this.consumeTime(this.getCost('SWAP'));
    }
    else if (bestPlan.action === 'CRAFT') {
        const success = this.processCraftTransaction(ai, bestPlan);
        if (!success) this.aiActionGather(bestPlan);
    } 
    else if (bestPlan.action === 'RESERVE') {
        if (ai.reserved.length >= 1) {
            this.aiActionGather(bestPlan);
        } else {
            const art = this.fieldArt[bestPlan.targetIdx];
            if (art) {
                ai.reserved.push(art);
                this.fieldArt.splice(bestPlan.targetIdx, 1);
                this.fill('artifact', 7);
                this.consumeTime(this.getCost('RESERVE'));
            } else {
                this.aiEmergencyAction();
            }
        }
    }
    else { 
        this.aiActionGather(bestPlan);
    }
};

// 7. [ìì› ìˆ˜ì§‘] 002 ì§€ëŠ¥í˜• ìˆ˜ì§‘ ë¡œì§
Game.prototype.aiActionGather = function(plan) {
    const ai = this.cp;
    
    // ì¶•ë³µ ì²˜ë¦¬
    if (plan.needBless) {
        const blessIdx = this.fieldBless.findIndex(c => c.type === plan.art.type);
        if (blessIdx !== -1) {
            ai.hand.push(this.fieldBless[blessIdx]);
            this.fieldBless.splice(blessIdx, 1);
            this.fill('blessing', 4);
            this.consumeTime(this.getCost('BLESS'));
        } else {
            // ì„±ë°° ì²´í¬
            const grailIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_reset_bless');
            if (grailIdx !== -1) {
                this.fieldBless.forEach(c => this.deckBless.discard(c));
                this.fieldBless = []; this.fill('blessing', 4);
                ai.hand.splice(grailIdx, 1);
                ai.metrics.lokiUsed++; // [Fix] ë¡œí‚¤ ì‚¬ìš© ê¸°ë¡
                return;
            }
            // ì—†ìœ¼ë©´ ë“œë¡œìš°
            const c = this.deckBless.draw();
            if(c) ai.hand.push(c);
            this.consumeTime(this.getCost('BLESS'));
        }
        return;
    }

    if (this.getArtLevel('nord') > 0 && this.aiTryNordAction(plan.art)) return;

    // í•„ìš”í•œ ìì› íƒìƒ‰
    let neededTypes = [];
    let myRes = {}; 
    ai.hand.forEach(c => { if(c.cat==='resource') myRes[c.type] = (myRes[c.type]||0)+c.val; });
    for(const [t, req] of Object.entries(plan.art.cost)) { if(myRes[t] < req) neededTypes.push(t); }

    let targetIdx = -1;
    // ìš°ì„ ìˆœìœ„ ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
    for(let i=0; i<this.fieldRes.length; i++) {
        if (neededTypes.includes(this.fieldRes[i].type) && this.fieldRes[i].val >= 3) { targetIdx = i; break; }
    }
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) {
            if (neededTypes.includes(this.fieldRes[i].type)) { targetIdx = i; break; }
        }
    }
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) { if (this.fieldRes[i].val >= 6) { targetIdx = i; break; } }
    }

    if (targetIdx !== -1) {
        const card = this.fieldRes[targetIdx];
        ai.hand.push(card);
        ai.metrics.resAcquired += card.val; // [Fix] íšë“ëŸ‰ ê¸°ë¡
        this.fieldRes.splice(targetIdx, 1);
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES'));
    } else {
        const c = this.deckRes.draw();
        if(c) {
            ai.hand.push(c);
            ai.metrics.resAcquired += c.val; // [Fix] íšë“ëŸ‰ ê¸°ë¡
        }
        this.consumeTime(this.getCost('RES'));
    }
};

Game.prototype.aiTryNordAction = function(targetArt) {
    const ai = this.cp;
    if (ai.getHandCount() >= 6) return false; // í•¸ë“œ ê½‰ ì°¨ë©´ ìì œ

    const nordLv = this.getArtLevel('nord');
    const limitSum = BALANCE_CONFIG.NORD.LIMIT_SUM[Math.min(nordLv, 3)];
    let indices = this.fieldRes.map((_, i) => i);
    let bestCombo = null;
    let bestScore = -1;

    for (let i = 0; i < indices.length; i++) {
        for (let j = i + 1; j < indices.length; j++) {
            const c1 = this.fieldRes[i];
            const c2 = this.fieldRes[j];
            if (c1.val + c2.val <= limitSum) {
                let score = c1.val + c2.val;
                if (targetArt.cost[c1.type] > 0) score += 10;
                if (targetArt.cost[c2.type] > 0) score += 10;
                if (score > bestScore) { bestScore = score; bestCombo = [i, j]; }
            }
        }
    }

    if (bestCombo) {
        bestCombo.sort((a, b) => b - a);
        bestCombo.forEach(idx => {
            ai.hand.push(this.fieldRes[idx]);
            this.fieldRes.splice(idx, 1);
        });
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES'));
        return true;
    }
    return false;
};

Game.prototype.aiSmartDiscard = function(ai) {
    let worstIdx = -1; let minScore = 999;
    ai.hand.forEach((c, i) => {
        let score = 10; 
        if (c.cat === 'resource') score = c.val; 
        else if (c.cat === 'blessing') score = 5; 
        else if (c.cat === 'loki') score = 20; 
        if (score < minScore) { minScore = score; worstIdx = i; }
    });
    if (worstIdx !== -1) {
        const c = ai.hand[worstIdx];
        ai.hand.splice(worstIdx, 1);
        if (c.cat === 'resource') this.deckRes.discard(c);
        else if (c.cat === 'blessing') this.deckBless.discard(c);
        ai.metrics.wastedCards++;
    }
};

Game.prototype.aiEmergencyAction = function() {
    const c = this.deckRes.draw();
    if(c) this.cp.hand.push(c);
    this.consumeTime(this.getCost('RES'));
};

// ==========================================
// [Part 4] Simulation Manager
// ==========================================

class SimulationManager {
    constructor() {
        this.isRunning = false;
        this.stats = this.getEmptyStats();
        this.csvData = []; 
    }

    getEmptyStats() {
        return {
            totalGames: 0,
            wins: [0, 0, 0, 0, 0],
            totalScore: 0,
            days: 0,
            godWins2: { olympus: 0, egypt: 0, nord: 0, celt: 0, mix: 0 },
            godWins3: { olympus: 0, egypt: 0, nord: 0, celt: 0, mix: 0 },
            totalSaved: 0, totalWasted: 0, totalSwaps: 0,
            dailyScoreSum: [0, 0, 0, 0, 0], 
            winTier: { Bronze: 0, Silver: 0, Gold: 0 }, 
            totalResAcquired: 0, totalResConsumed: 0, 
            winnerLokiSum: 0, loserLokiSum: 0,

            // [ì¶”ê°€ë¨] ì‹ í™”ë³„ ì¼ì¼ ì ìˆ˜ ì§‘ê³„
            mythDailyStats: {
                olympus: { sum: [0,0,0,0,0], count: 0 },
                egypt: { sum: [0,0,0,0,0], count: 0 },
                nord: { sum: [0,0,0,0,0], count: 0 },
                celt: { sum: [0,0,0,0,0], count: 0 }
            }
        };
    }

    async startSimulation() {
        if (this.isRunning) return;
        applyUserBalance();
        // CSV í—¤ë” ì´ˆê¸°í™”
        this.csvData = ["GameID,Day,PlayerID,MainMyth,IsWinner,Score,OlympusLv,EgyptLv,NordLv,CeltLv"];
        
        const countInput = document.getElementById('simCount');
        const count = parseInt(countInput.value);
        const myths = [
            document.getElementById('p1Myth').value,
            document.getElementById('p2Myth').value,
            document.getElementById('p3Myth').value,
            document.getElementById('p4Myth').value
        ];

        this.isRunning = true;
        this.updateLog(`[System] ${count}íšŒ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ (Data Mining Mode)`);
        
        let chunkSize = 100;
        if (count >= 5000) chunkSize = 500;
        const startTime = performance.now();
        
        let gameIdCounter = 1;

        for (let i = 0; i < count; i += chunkSize) {
            if (!this.isRunning) break;
            const limit = Math.min(i + chunkSize, count);
            for (let j = i; j < limit; j++) { 
                this.runOneGame(myths, gameIdCounter++); 
            }
            const progress = Math.round(((i + chunkSize) / count) * 100);
            document.getElementById('progressBar').style.width = `${progress}%`;
            await new Promise(r => setTimeout(r, 0));
        }

        const endTime = performance.now();
        if (this.isRunning) {
            this.updateLog(`[System] ì™„ë£Œ. ì†Œìš”ì‹œê°„: ${((endTime - startTime)/1000).toFixed(2)}ì´ˆ`);
        }
        this.renderStats();
        this.isRunning = false;
        document.getElementById('progressBar').style.width = `0%`;
    }

    resetStats() {
        if (confirm("í†µê³„ ë° CSV ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
            this.stats = this.getEmptyStats();
            this.csvData = [];
            this.renderStats();
            this.updateLog(`[System] ì´ˆê¸°í™” ì™„ë£Œ`);
        }
    }
    
    stopSimulation() { this.isRunning = false; }

    runOneGame(myths, gameId) {
        const game = new Game();
        game.init(myths);
        
        game.players.forEach(p => { 
            p.milestones = {}; 
            if (p.getHandCount() > 8) game.aiSmartDiscard(p); 
        });

        let safetyBreak = 0;
        while (!game.isGameEnded && safetyBreak < 800) { 
            game.aiTurn(); 
            safetyBreak++; 
        }
        if (!game.isGameEnded) game.endGame();
        this.collectData(game, gameId);
    }

    collectData(game, gameId) {
        let winner = game.players[0];
        game.players.forEach(p => {
            if (p.score > winner.score) winner = p;
            else if (p.score === winner.score) {
                if (p.artifacts.length > winner.artifacts.length) winner = p;
            }
        });

        this.stats.totalGames++;
        this.stats.wins[winner.id]++;
        this.stats.days += game.day;
        
        let gameTotalScore = 0;
        
        game.players.forEach(p => {
            gameTotalScore += p.score;
            this.stats.totalSaved += p.metrics.savedRes;
            this.stats.totalWasted += p.metrics.wastedCards;
            this.stats.totalSwaps += p.metrics.celtSwaps;
            this.stats.totalResAcquired += p.metrics.resAcquired;
            this.stats.totalResConsumed += p.metrics.resConsumed;
            
            let filledDaily = [...p.dailyScore];
            for(let d=0; d<5; d++) {
                if (filledDaily[d] === -1) {
                    if (d === 0) filledDaily[d] = p.score; 
                    else filledDaily[d] = filledDaily[d-1];
                }
                this.stats.dailyScoreSum[d] += filledDaily[d];
            }

            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(a => { if(counts[a.type] !== undefined) counts[a.type]++; });
            
            let mainMyth = 'mix';
            let maxVal = 0;
            for(const [m, c] of Object.entries(counts)) {
                if (c > maxVal) { maxVal = c; mainMyth = m; }
                else if (c === maxVal) mainMyth = 'mix'; 
            }

            if (mainMyth !== 'mix' && this.stats.mythDailyStats[mainMyth]) {
                this.stats.mythDailyStats[mainMyth].count++;
                for(let d=0; d<5; d++) {
                    this.stats.mythDailyStats[mainMyth].sum[d] += filledDaily[d];
                }
            }

            // [ì¶”ê°€ë¨] CSV ë°ì´í„° ìˆ˜ì§‘
            const isWinner = (p.id === winner.id) ? 1 : 0;
            p.history.forEach(h => {
                this.csvData.push(
                    `${gameId},${h.day},P${p.id},${mainMyth},${isWinner},${h.score},${h.olympus},${h.egypt},${h.nord},${h.celt}`
                );
            });
        });
        
        this.stats.totalScore += (gameTotalScore / 4);

        winner.artifacts.forEach(a => {
            if(this.stats.winTier[a.grade] !== undefined) this.stats.winTier[a.grade]++;
        });
        this.stats.winnerLokiSum += winner.metrics.lokiUsed;
        let losersLoki = 0;
        game.players.forEach(p => { if(p !== winner) losersLoki += p.metrics.lokiUsed; });
        this.stats.loserLokiSum += (losersLoki / 3);

        const wCounts = { olympus:0, egypt:0, nord:0, celt:0 };
        winner.artifacts.forEach(a => wCounts[a.type]++);
        const wMax = Math.max(...Object.values(wCounts));
        const determineType = (threshold) => {
            if (wMax < threshold) return 'mix';
            const leaders = Object.keys(wCounts).filter(key => wCounts[key] === wMax);
            if (leaders.length === 1) return leaders[0];
            leaders.sort((a, b) => {
                const orderA = winner.milestones[a] !== undefined ? winner.milestones[a] : 99999;
                const orderB = winner.milestones[b] !== undefined ? winner.milestones[b] : 99999;
                return orderA - orderB;
            });
            if (winner.milestones[leaders[0]] === undefined && threshold >= 3) return 'mix';
            return leaders[0];
        };
        this.stats.godWins2[determineType(2)]++;
        this.stats.godWins3[determineType(3)]++;
    }

    updateLog(msg) {
        const log = document.getElementById('simLog');
        log.innerText = msg + "\n" + log.innerText;
    }
    
    // [ì¶”ê°€ë¨] CSV ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥
    downloadRawData() {
        if (this.csvData.length <= 1) { alert("ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì‹œë®¬ë ˆì´ì…˜ì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”."); return; }
        
        const csvContent = this.csvData.join("\n");
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", `divine_forge_sim_data_${new Date().toISOString().slice(0,10)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    renderStats() {
        const total = this.stats.totalGames;
        if (total === 0) return;
        const getPct = (val) => ((val / total) * 100).toFixed(1) + '%';
        
        const dailyAvg = this.stats.dailyScoreSum.map(s => (s / (total * 4)).toFixed(1));
        const tierTotal = this.stats.winTier.Bronze + this.stats.winTier.Silver + this.stats.winTier.Gold;
        const tierPct = {
            Bronze: tierTotal > 0 ? ((this.stats.winTier.Bronze / tierTotal) * 100).toFixed(1) : 0,
            Silver: tierTotal > 0 ? ((this.stats.winTier.Silver / tierTotal) * 100).toFixed(1) : 0,
            Gold: tierTotal > 0 ? ((this.stats.winTier.Gold / tierTotal) * 100).toFixed(1) : 0
        };
        const eff = this.stats.totalResAcquired > 0 ? ((this.stats.totalResConsumed / this.stats.totalResAcquired) * 100).toFixed(1) : 0;
        const winLoki = (this.stats.winnerLokiSum / total).toFixed(2);
        const loseLoki = (this.stats.loserLokiSum / total).toFixed(2);
        
        // [ì¶”ê°€ë¨] ì‹ í™”ë³„ ì¼ì¼ ì„±ì¥ ë°ì´í„° HTML
        let mythGrowthHtml = `<table style="font-size:11px;"><tr><th>ì‹ í™”</th><th>1ì¼</th><th>2ì¼</th><th>3ì¼</th><th>4ì¼</th><th>5ì¼</th></tr>`;
        ['olympus','egypt','nord','celt'].forEach(m => {
            const d = this.stats.mythDailyStats[m];
            const name = {olympus:'ì˜¬ë¦¼', egypt:'ì´ì§‘', nord:'ë…¸ë¥´', celt:'ì¼ˆíŠ¸'}[m];
            const color = {olympus:'#00bfff', egypt:'#f1c40f', nord:'#9b59b6', celt:'#2ecc71'}[m];
            if (d.count > 0) {
                const avgs = d.sum.map(s => (s/d.count).toFixed(1));
                mythGrowthHtml += `<tr><td style="color:${color}">${name}</td><td>${avgs[0]}</td><td>${avgs[1]}</td><td>${avgs[2]}</td><td>${avgs[3]}</td><td>${avgs[4]}</td></tr>`;
            } else {
                mythGrowthHtml += `<tr><td style="color:${color}">${name}</td><td colspan="5" style="color:#555;">ë°ì´í„° ì—†ìŒ</td></tr>`;
            }
        });
        mythGrowthHtml += `</table>`;

        let html = `<div class="grid-container" style="grid-template-columns:1fr 1fr 1fr 1fr; margin-bottom:10px;">`;
        for(let i=1; i<=4; i++) {
            const color = ['#e74c3c','#3498db','#2ecc71','#f1c40f'][i-1];
            html += `<div style="color:${color}; font-weight:bold;">P${i}: ${getPct(this.stats.wins[i])}</div>`;
        }
        html += `</div>`;
        
        // [ì¶”ê°€ë¨] ë‹¤ìš´ë¡œë“œ ë²„íŠ¼
        html += `<button onclick="simManager.downloadRawData()" style="width:100%; background:#27ae60; margin-bottom:15px;">ğŸ“¥ ì¡°í•© ë¶„ì„ìš© ì—‘ì…€ ë°ì´í„° ë‹¤ìš´ë¡œë“œ (.csv)</button>`;

        html += `<table>
            <tr><th colspan="3">ğŸ›ï¸ ì‹ í™”ë³„ ìŠ¹ë¥  (ë©”íƒ€ ë¶„ì„)</th></tr>
            <tr>
                <th style="text-align:left;">ë©”íƒ€(Deck)</th>
                <th>2+ (ìœ ì—°)</th>
                <th>3+ (ì „ë¬¸)</th>
            </tr>
            <tr>
                <td style="text-align:left; color:#00bfff;">â˜ï¸ ì˜¬ë¦¼í¬ìŠ¤</td>
                <td>${getPct(this.stats.godWins2.olympus)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.olympus)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#ffd700;">ğŸ‘ï¸ ì´ì§‘íŠ¸</td>
                <td>${getPct(this.stats.godWins2.egypt)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.egypt)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#9b59b6;">â„ï¸ ë…¸ë¥´ë“œ</td>
                <td>${getPct(this.stats.godWins2.nord)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.nord)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#2ecc71;">â˜˜ï¸ ì¼ˆíŠ¸</td>
                <td>${getPct(this.stats.godWins2.celt)}</td>
                <td style="font-weight:bold;">${getPct(this.stats.godWins3.celt)}</td>
            </tr>
            <tr>
                <td style="text-align:left; color:#aaa;">ğŸ¨ ì¡íƒ•(Mix)</td>
                <td>${getPct(this.stats.godWins2.mix)}</td>
                <td>${getPct(this.stats.godWins3.mix)}</td>
            </tr>
        </table>`;

        html += `<div class="grid-container" style="margin-top:20px;">
            <div class="stats-area">
                <h3 style="color:#f1c40f; margin-top:0;">ğŸ“ˆ ì‹ í™”ë³„ ì¼ì¼ í‰ê·  ì ìˆ˜</h3>
                ${mythGrowthHtml}
            </div>
            <div class="stats-area">
                <h3 style="color:#f1c40f; margin-top:0;">ğŸ’ ìŠ¹ì ìœ ë¬¼ ë“±ê¸‰</h3>
                <table>
                    <tr><th style="color:#cd7f32">Bronze</th><th style="color:#c0c0c0">Silver</th><th style="color:#ffd700">Gold</th></tr>
                    <tr>
                        <td>${tierPct.Bronze}%</td><td>${tierPct.Silver}%</td><td>${tierPct.Gold}%</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <table style="margin-top: 15px;">
            <tr><th colspan="3">ğŸ” ì‹¬ì¸µ íš¨ìœ¨ ë¶„ì„</th></tr>
            <tr>
                <td>ğŸ“‰ ìì› íš¨ìœ¨ì„±<br><span style="font-size:10px; color:#888;">(ì†Œëª¨ / íšë“)</span></td>
                <td colspan="2" style="font-size:14px; font-weight:bold; color:${eff > 70 ? '#2ecc71' : '#e74c3c'}">${eff}%</td>
            </tr>
            <tr>
                <td>ğŸƒ ë¡œí‚¤ í™œìš©ë„<br><span style="font-size:10px; color:#888;">(í‰ê·  ì‚¬ìš© íšŸìˆ˜)</span></td>
                <td>ìŠ¹ì: <span style="color:#f1c40f; font-weight:bold;">${winLoki}íšŒ</span></td>
                <td>íŒ¨ì: <span style="color:#aaa;">${loseLoki}íšŒ</span></td>
            </tr>
        </table>`;

        html += `<div style="margin-top:15px; font-size:11px; color:#aaa; line-height:1.6;">
            í‰ê·  ì ìˆ˜: <span style="color:#eee; font-weight:bold;">${(this.stats.totalScore / total).toFixed(1)}ì </span> <br>
            í‰ê·  ê²Œì„ ê¸¸ì´: ${(this.stats.days / total).toFixed(1)}ì¼ <br>
            <span style="color:#00bfff;">ì˜¬ë¦¼í¬ìŠ¤ í• ì¸: ${(this.stats.totalSaved / total).toFixed(1)}ê°œ</span> <br>
            <span style="color:#9b59b6;">ë…¸ë¥´ë“œ ë‚­ë¹„: ${(this.stats.totalWasted / total).toFixed(1)}ì¥</span> <br>
            <span style="color:#2ecc71;">ì¼ˆíŠ¸ ë³€í™˜: ${(this.stats.totalSwaps / total).toFixed(1)}íšŒ</span>
        </div>`;

        document.getElementById('mainStats').innerHTML = `ì´ ${total} ê²Œì„ ì™„ë£Œ`;
        document.getElementById('detailStats').innerHTML = html;
    }
}
const simManager = new SimulationManager();
</script>
</body>
</html>