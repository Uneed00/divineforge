<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Divine Forge: Balance Simulator (Integrated)</title>
    <style>
    :root {
        --bg-color: #121212;
        --panel-color: #1e1e1e;
        --border-color: #333;
        --accent-color: #3498db;
        --text-main: #ecf0f1;
        --text-sub: #95a5a6;
        
        --c-olympus: #3498db;
        --c-egypt: #f1c40f;
        --c-nord: #9b59b6;
        --c-celt: #2ecc71;
    }

    body { font-family: 'Segoe UI', 'Roboto', monospace; background: var(--bg-color); color: var(--text-main); padding: 20px; margin: 0; line-height: 1.5; }
    h1, h2, h3 { color: var(--text-main); margin: 0 0 10px 0; font-weight: 600; }
    
    /* Layout */
    .control-panel { background: var(--panel-color); border: 1px solid var(--border-color); padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
    .control-group { margin-bottom: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    
    /* Inputs & Buttons */
    select, input { background: #2c3e50; border: 1px solid #444; color: white; padding: 6px 10px; border-radius: 4px; }
    button { padding: 8px 16px; border-radius: 4px; border: none; cursor: pointer; font-weight: bold; transition: 0.2s; }
    button:hover { opacity: 0.9; transform: translateY(-1px); }
    .btn-primary { background: var(--accent-color); color: white; }
    .btn-danger { background: #e74c3c; color: white; }
    .btn-warning { background: #e67e22; color: white; }

    /* Dashboard Grid */
    .dashboard-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 4ì—´ ê·¸ë¦¬ë“œ */
        gap: 15px;
        margin-top: 20px;
    }
    .panel {
        background: var(--panel-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
    }
    .panel.full-width { grid-column: span 4; }
    .panel.half-width { grid-column: span 2; }
    
    .panel-header {
        font-size: 14px;
        color: var(--text-sub);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
        border-bottom: 1px solid #333;
        padding-bottom: 5px;
        display: flex;
        justify-content: space-between;
    }

    /* Visual Elements */
    .stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 13px; }
    .stat-label { color: var(--text-sub); flex: 1; }
    .stat-value { font-weight: bold; color: var(--text-main); text-align: right; }
    
    .bar-wrapper { flex: 2; height: 8px; background: #333; border-radius: 4px; margin: 0 10px; overflow: hidden; position: relative; }
    .bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s ease; }
    
    .mini-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .mini-table th { text-align: left; color: var(--text-sub); padding: 4px; border-bottom: 1px solid #444; }
    .mini-table td { padding: 4px; border-bottom: 1px solid #333; }
    .mini-table tr:last-child td { border-bottom: none; }

    /* Colors */
    .c-olympus { color: var(--c-olympus); }
    .c-egypt { color: var(--c-egypt); }
    .c-nord { color: var(--c-nord); }
    .c-celt { color: var(--c-celt); }
    
    .log-area { height: 150px; overflow-y: auto; background: #000; border: 1px solid #333; padding: 10px; font-size: 11px; color: #aaa; font-family: monospace; margin-bottom: 10px; }
    
    #progressBar { height: 4px; background: #2ecc71; width: 0%; transition: width 0.2s; }
</style>
</head>
<body>

    <h1>âš–ï¸ Divine Forge Simulator v9.1 (Fixed)</h1>

    
       <div class="control-panel">
    <div class="control-group">
        <label>ì‹œë®¬ë ˆì´ì…˜ íšŸìˆ˜:</label>
        <select id="simCount">
            <option value="100">100íšŒ</option>
            <option value="1000">1,000íšŒ</option>
            <option value="10000" selected>10,000íšŒ</option>
        </select>
        <button onclick="simManager.startSimulation()">â–¶ ì¶”ê°€ ì‹¤í–‰ (ëˆ„ì )</button>
        <button class="stop-btn" onclick="simManager.stopSimulation()">â¹ ì¤‘ì§€</button>
        
        <div style="width: 20px;"></div> <button onclick="simManager.resetStats()" style="background: #e67e22;">ğŸ”„ í†µê³„ ì´ˆê¸°í™”</button>
    </div>
    
    <div class="control-group">
        <span>ì‹ í™” ë°°ì •(P1~P4):</span>
        <select id="p1Myth">
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p2Myth">
            <option value="egypt" selected>ì´ì§‘íŠ¸</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p3Myth">
            <option value="nord" selected>ë…¸ë¥´ë“œ</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="celt">ì¼ˆíŠ¸</option>
        </select>
        <select id="p4Myth">
            <option value="celt" selected>ì¼ˆíŠ¸</option>
            <option value="none">ì—†ìŒ (ë¬´ê°€ì¤‘ì¹˜)</option>
            <option value="olympus">ì˜¬ë¦¼í¬ìŠ¤</option>
            <option value="egypt">ì´ì§‘íŠ¸</option>
            <option value="nord">ë…¸ë¥´ë“œ</option>
        </select>
    </div>

    <details style="margin-top: 15px; background: #2c3e50; padding: 10px; border-radius: 4px; border: 1px solid #444;">
        <summary style="cursor: pointer; font-weight: bold; color: #ecf0f1;">âš™ï¸ ë°¸ëŸ°ìŠ¤ íŒŒë¼ë¯¸í„° ë¯¸ì„¸ ì¡°ì • (í´ë¦­í•˜ì—¬ ì—´ê¸°)</summary>
        
        <div class="control-group" style="margin-top: 10px; padding: 10px; border: 1px solid #2ecc71; border-radius: 4px; background: #1a252f; flex-direction: column; align-items: flex-start;">
    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
        <span style="color: #2ecc71; font-weight: bold;">â˜˜ï¸ ì¼ˆíŠ¸ ëŠ¥ë ¥ ì»¤ìŠ¤í…€ (Advanced)</span>
        <label style="font-size: 11px; color: #aaa; cursor: pointer;">
            <input type="checkbox" id="celtMimicToggle" checked> ë¯¸ë¯¹(3ë‹¨ê³„) í™œì„±
        </label>
    </div>

    <div style="width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <div>
            <label style="font-size: 11px; display:block; color: #ddd;">êµí™˜ íšŸìˆ˜ (0~3ë‹¨ê³„):</label>
            <input type="text" id="conf_celt_swap" value="0,1,2,3" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #555; color: white; padding: 4px;">
        </div>
        <div>
            <label style="font-size: 11px; display:block; color: #ddd;">ë³€í™˜(Any) ë°œë™ ë ˆë²¨:</label>
            <input type="text" id="conf_celt_lvl_convert" value="2" placeholder="ì˜ˆ: 2 (2ë‹¨ê³„ ì´ìƒ ë°œë™)" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #27ae60; color: white; padding: 4px;">
        </div>
        <div style="grid-column: span 2;">
            <label style="font-size: 11px; display:block; color: #ddd;">ë©´ì œ(Free) ë°œë™ ë ˆë²¨:</label>
            <input type="text" id="conf_celt_lvl_free" value="3" placeholder="ì˜ˆ: 3 (3ë‹¨ê³„ ì´ìƒ ë°œë™)" style="width: 100%; box-sizing: border-box; background: #333; border: 1px solid #27ae60; color: white; padding: 4px;">
        </div>
    </div>
    <div style="font-size: 10px; color: #7f8c8d; margin-top: 5px;">
        * ë³€í™˜/ë©´ì œ: ì…ë ¥í•œ <b>ë ˆë²¨ ì´ìƒ(â‰¥)</b>ì¼ ë•Œ ëŠ¥ë ¥ì´ í™œì„±í™”ë©ë‹ˆë‹¤. (ìˆ«ì 1ê°œë§Œ ì…ë ¥)
    </div>
</div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
            <div style="background: #34495e; padding: 10px; border-radius: 4px;">
                <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #00bfff;">â˜ï¸ ì˜¬ë¦¼í¬ìŠ¤ (ì¬ë£Œ í• ì¸)</h3>
                <label style="font-size: 11px;">ë‹¨ê³„ë³„ í• ì¸ëŸ‰ (0,1,2,3ë‹¨ê³„):</label>
                <input type="text" id="conf_olympus_discount" value="0,2,5,12" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #555; color: white;">
            </div>
            <div style="background: #34495e; padding: 10px; border-radius: 4px; margin-top: 10px; border: 1px solid #9b59b6;">
    <h3 style="margin: 0 0 5px 0; font-size: 14px; color: #9b59b6;">â„ï¸ ë…¸ë¥´ë“œ (ìˆ˜ì§‘ ë°¸ëŸ°ìŠ¤)</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px;">
        <div>
            <label style="font-size: 10px; color: #ccc;">í•©ê³„ ì œí•œ(Sum)</label>
            <input type="text" id="conf_nord_sum" value="6,9,14" style="width: 100%; background: #222; border: 1px solid #555; color: white;">
        </div>
        <div>
            <label style="font-size: 10px; color: #ccc;">ì¹´ë“œ ìˆ˜(Count)</label>
            <input type="text" id="conf_nord_count" value="2,2,3" style="width: 100%; background: #222; border: 1px solid #555; color: white;">
        </div>
        <div>
            <label style="font-size: 10px; color: #ccc;">ì†ë„(Speed)</label>
            <input type="text" id="conf_nord_speed" value="3.5,7.0,7.0,10.5" style="width: 100%; background: #222; border: 1px solid #555; color: white;">
        </div>
    </div>
</div>

            <div style="margin-top: 8px; border-top: 1px dashed #555; padding-top: 8px;">
    <div style="font-size: 11px; color: #dcdcdc; margin-bottom: 4px;">âœ‹ ë‹¨ê³„ë³„ í•¸ë“œ ì œí•œ (ê¸°ë³¸: 8ì¥)</div>
    <div style="display: flex; gap: 10px;">
        <div style="flex: 1;">
            <label style="font-size: 10px; color: #9b59b6;">Lv2 (Silver) ì´ìƒ</label>
            <input type="number" id="conf_nord_hand_lv2" value="9" placeholder="ì˜ˆ: 9" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #9b59b6; color: white; text-align: center;">
        </div>
        <div style="flex: 1;">
            <label style="font-size: 10px; color: #e1b12c;">Lv3 (Gold) ì´ìƒ</label>
            <input type="number" id="conf_nord_hand_lv3" value="10" placeholder="ì˜ˆ: 10" style="width: 100%; box-sizing: border-box; background: #222; border: 1px solid #f1c40f; color: white; text-align: center;">
        </div>
    </div>
    <div style="font-size: 9px; color: #7f8c8d; margin-top: 3px;">
        * í•´ë‹¹ ë‹¨ê³„ ë„ë‹¬ ì‹œ ì ìš©í•  <b>ìµœëŒ€ ì¥ìˆ˜</b>ë¥¼ ì…ë ¥í•˜ì„¸ìš”.
    </div>
</div>
            
            <div style="background: #34495e; padding: 10px; border-radius: 4px; grid-column: span 2; border: 1px dashed #f1c40f;">
                <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #f1c40f;">ğŸ‘ï¸ ì´ì§‘íŠ¸ (í–‰ë™ ë¹„ìš© ê°ì†Œ ìƒì„¸ ì„¤ì •)</h3>
                <table style="width: 100%; font-size: 11px; border-collapse: collapse; color: #eee;">
                    <tr style="border-bottom: 1px solid #555;">
                        <th style="text-align: left; padding: 4px; color: #aaa;">Level</th>
                        <th style="padding: 4px;">ì˜ˆì•½(Reserve)</th>
                        <th style="padding: 4px;">ìì›(Res)</th>
                        <th style="padding: 4px;">ì¶•ë³µ(Bless)</th>
                        <th style="padding: 4px;">ì œì‘(Craft)</th>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV1</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_r" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l1_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV2</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_res" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_bls" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l2_art" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; padding: 4px; color: #f1c40f;">LV3</td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_r" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_res" value="0" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_bls" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                        <td style="text-align: center;"><input type="number" id="conf_egypt_l3_art" value="1" style="width: 40px; text-align: center; background:#222; border:1px solid #555; color:white;"></td>
                    </tr>
                </table>
                <div style="font-size: 11px; color: #aaa; margin-top: 5px; text-align: right;">* ê° ë ˆë²¨ ë„ë‹¬ ì‹œ í•´ë‹¹ ìˆ˜ì¹˜ë§Œí¼ ë¹„ìš©ì´ <b>ì¶”ê°€ë¡œ</b> ê°ì†Œí•©ë‹ˆë‹¤.</div>
            </div>
        </div>
        
        <div style="margin-top: 10px; text-align: right; font-size: 11px; color: #95a5a6;">
        </div>
    </details>
    <div id="progressBar" style="width:0%; height:4px; background:#2ecc71; transition:width 0.2s; margin-top: 10px;"></div>
</div>
<div class="log-area" id="simLog" style="margin-bottom: 20px;">
        [System] ì¤€ë¹„ ì™„ë£Œ. ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•˜ë ¤ë©´ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.
    </div>

    <div id="mainStats" style="font-size: 24px; font-weight: bold; color: #f1c40f; margin-bottom: 10px;"></div>
    <div id="detailStats"></div>
<script>
// ==================================================================================
// [Part 1] Configuration & Databases (002 Ver. Integrated)
// ==================================================================================

const CONFIG = {
    MAX_TIME: 12,
    MAX_DAYS: 5,
    HAND_LIMIT: 8,
    COST: { RES: 3, BLESS: 2, ART: 2, RESERVE: 1, SWAP: 1 }
};

// 002 ë²„ì „ì˜ ë°¸ëŸ°ìŠ¤ ì»¨í”¼ê·¸ ì ìš©
// [Part 1] Config & Apply Function (ê¸°ì¡´ BALANCE_CONFIG, applyUserBalance ì§€ìš°ê³  ëŒ€ì²´)
// [Part 1] Config & Apply Function (ìˆ˜ì •ë¨)
const BALANCE_CONFIG = {
    EGYPT: [
        { RESERVE: 1, RES: 0, BLESS: 0, ART: 0 },
        { RESERVE: 0, RES: 1, BLESS: 0, ART: 0 },
        { RESERVE: 0, RES: 0, BLESS: 1, ART: 1 }
    ],
    NORD: { LIMIT_SUM: [6, 9, 14], LIMIT_COUNT: [2, 2, 3], GATHER_SPEED: [3.5, 7.0, 7.0, 10.5] },
    OLYMPUS: { DISCOUNT: [0, 2, 5, 12] },
    CELT: { 
        SWAP_LIMIT: [0, 1, 2, 3],
        LVL_CONVERT: 2, // [ë³€ê²½] ë°°ì—´ ëŒ€ì‹  ìˆ«ì(ìµœì†Œ ë ˆë²¨)ë¡œ ê´€ë¦¬
        LVL_FREE: 3     // [ë³€ê²½] ë°°ì—´ ëŒ€ì‹  ìˆ«ì(ìµœì†Œ ë ˆë²¨)ë¡œ ê´€ë¦¬
    }
};

function applyUserBalance() {
    try {
        const getElVal = (id) => { const el = document.getElementById(id); return el && el.value.trim() !== "" ? (parseInt(el.value) || 0) : 0; };
        const getArrVal = (id) => { const el = document.getElementById(id); return el && el.value.trim() !== "" ? el.value.split(',').map(v => Number(v.trim())).filter(n => !isNaN(n)) : []; };

        const mimicToggle = document.getElementById('celtMimicToggle');
        BALANCE_CONFIG.CELT.MIMIC_ENABLED = mimicToggle ? mimicToggle.checked : true;

        const olympusVal = getArrVal('conf_olympus_discount');
        if (olympusVal.length > 0) BALANCE_CONFIG.OLYMPUS.DISCOUNT = olympusVal;
        
        BALANCE_CONFIG.EGYPT = [
            { RESERVE: getElVal('conf_egypt_l1_r'), RES: getElVal('conf_egypt_l1_res'), BLESS: getElVal('conf_egypt_l1_bls'), ART: getElVal('conf_egypt_l1_art') },
            { RESERVE: getElVal('conf_egypt_l2_r'), RES: getElVal('conf_egypt_l2_res'), BLESS: getElVal('conf_egypt_l2_bls'), ART: getElVal('conf_egypt_l2_art') },
            { RESERVE: getElVal('conf_egypt_l3_r'), RES: getElVal('conf_egypt_l3_res'), BLESS: getElVal('conf_egypt_l3_bls'), ART: getElVal('conf_egypt_l3_art') }
        ];

        const nordSum = getArrVal('conf_nord_sum'); if (nordSum.length > 0) BALANCE_CONFIG.NORD.LIMIT_SUM = nordSum;
        const nordCount = getArrVal('conf_nord_count'); if (nordCount.length > 0) BALANCE_CONFIG.NORD.LIMIT_COUNT = nordCount;
        const nordSpeed = getArrVal('conf_nord_speed'); if (nordSpeed.length > 0) BALANCE_CONFIG.NORD.GATHER_SPEED = nordSpeed;
        const limitLv2 = document.getElementById('conf_nord_hand_lv2');
        const limitLv3 = document.getElementById('conf_nord_hand_lv3');

        // ê°’ì´ ë¹„ì–´ìˆìœ¼ë©´ ê¸°ë³¸ê°’(8) ì ìš©
        BALANCE_CONFIG.NORD.HAND_LIMIT_LV2 = (limitLv2 && limitLv2.value) ? parseInt(limitLv2.value) : 8;
        BALANCE_CONFIG.NORD.HAND_LIMIT_LV3 = (limitLv3 && limitLv3.value) ? parseInt(limitLv3.value) : 8;

        const celtSwap = getArrVal('conf_celt_swap'); if (celtSwap.length > 0) BALANCE_CONFIG.CELT.SWAP_LIMIT = celtSwap;
        
        // [Logic Change] ë°°ì—´ì˜ ì²« ë²ˆì§¸ ê°’ì„ ìµœì†Œ ë ˆë²¨(Threshold)ë¡œ ì‚¬ìš©
        const convertArr = getArrVal('conf_celt_lvl_convert');
        BALANCE_CONFIG.CELT.LVL_CONVERT = convertArr.length > 0 ? convertArr[0] : 999; 
        
        const freeArr = getArrVal('conf_celt_lvl_free');
        BALANCE_CONFIG.CELT.LVL_FREE = freeArr.length > 0 ? freeArr[0] : 999;

        console.log("[System] Balance Applied (Logic: Threshold >=).");
    } catch (e) { console.error("Balance Apply Error:", e); }
}
const START_RULE = [
    { res: 0, bless: 0, loki: 0, score: 0 }, // P1
    { res: 0, bless: 0, loki: 0, score: 0 }, // P2
    { res: 0, bless: 0, loki: 0, score: 0 }, // P3
    { res: 0, bless: 0, loki: 0, score: 0 }  // P4
];

const RES_NAMES = { adamantite: "ì•„ë‹¤ë§Œíƒ€ì´íŠ¸", mithril: "ë¯¸ìŠ¤ë¦´", dragonBone: "ìš©ì˜ ë¼ˆ", starFragment: "ë³„ì˜ íŒŒí¸" };
const TYPE_NAMES = { nord: "ë…¸ë¥´ë“œ", egypt: "ì´ì§‘íŠ¸", olympus: "ì˜¬ë¦¼í¬ìŠ¤", celt: "ì¼ˆíŠ¸" };

// 002 ë²„ì „ì˜ ìœ ë¬¼ ë°ì´í„°ë² ì´ìŠ¤ (ê·¸ëŒ€ë¡œ ìœ ì§€)
const ARTIFACT_DB = [
    // Olympus (Bronze)
    {name:"ê·€ê²ŒìŠ¤ì˜ ë°˜ì§€", type:"olympus", score:4, grade:"Bronze", cost:{adamantite:3, starFragment:3}},
    {name:"í—¤ë¥´ë©”ìŠ¤ì˜ ì‹ ë°œ", type:"olympus", score:5, grade:"Bronze", cost:{dragonBone:3, mithril:4}},
    {name:"í¬ë¦¬ì…€ë¼ì¹´í† ìŠ¤", type:"olympus", score:6, grade:"Bronze", cost:{mithril:3, starFragment:5}},
    // Olympus (Silver)
    {name:"í€´ë„¤ì—", type:"olympus", score:10, grade:"Silver", cost:{dragonBone:2, mithril:4, starFragment:5}},
    {name:"ì¼€ìŠ¤í† ìŠ¤ íˆë§ˆìŠ¤", type:"olympus", score:12, grade:"Silver", cost:{adamantite:4, starFragment:9}},
    {name:"íŠ¸ë¼ì•„ì´ë‚˜", type:"olympus", score:12, grade:"Silver", cost:{adamantite:2, dragonBone:7, mithril:3}},
    {name:"ì•„í´ë¡ ì˜ ë¦¬ë¼", type:"olympus", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:3, starFragment:6}},
    {name:"ì•„ì´ê¸°ìŠ¤", type:"olympus", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:8}},
    {name:"íí”¼ë“œì˜ í™”ì‚´", type:"olympus", score:16, grade:"Silver", cost:{adamantite:5, dragonBone:3, mithril:7, starFragment:2}},
    {name:"ì•„ë‹¤ë§ŒíŠ¸", type:"olympus", score:16, grade:"Silver", cost:{adamantite:12, dragonBone:2, starFragment:3}},
    // Olympus (Gold)
    {name:"ì•„ìŠ¤íŠ¸ë¼í˜", type:"olympus", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:5, mithril:5, starFragment:12}},

    // Egypt (Bronze)
    {name:"ë§ˆì•„íŠ¸ì˜ ê¹ƒí„¸", type:"egypt", score:4, grade:"Bronze", cost:{dragonBone:3, mithril:3}},
    {name:"ì˜¤ì‹œë¦¬ìŠ¤ì˜ ì™•í™€", type:"egypt", score:5, grade:"Bronze", cost:{adamantite:2, mithril:6}},
    {name:"ì•„ëˆ„ë¹„ìŠ¤ì˜ ì €ìš¸", type:"egypt", score:6, grade:"Bronze", cost:{adamantite:2, dragonBone:6}},
    // Egypt (Silver)
    {name:"ì„¸íŠ¸ì˜ ì „ìŸ ë„ë¼", type:"egypt", score:10, grade:"Silver", cost:{adamantite:6, dragonBone:2, mithril:2}},
    {name:"ì„¸í¬ë©”íŠ¸ì˜ ì—­ë³‘", type:"egypt", score:12, grade:"Silver", cost:{adamantite:3, dragonBone:6, mithril:3}},
    {name:"í† íŠ¸ì˜ ì„œ", type:"egypt", score:12, grade:"Silver", cost:{dragonBone:2, mithril:6, starFragment:5}},
    {name:"ì•„í©ì˜ ì´ë¹¨", type:"egypt", score:14, grade:"Silver", cost:{dragonBone:7, mithril:6, starFragment:2}},
    {name:"í˜¸ë£¨ìŠ¤ì˜ ëˆˆ", type:"egypt", score:14, grade:"Silver", cost:{adamantite:4, mithril:6, starFragment:5}},
    {name:"í¬ëˆ”ì˜ ë¬¼ë ˆ", type:"egypt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:2, starFragment:5}},
    {name:"ë§Œì•¼ë¥´íŠ¸", type:"egypt", score:16, grade:"Silver", cost:{dragonBone:5, mithril:4, starFragment:8}},
    // Egypt (Gold)
    {name:"ëˆ„ì˜ í•­ì•„ë¦¬", type:"egypt", score:24, grade:"Gold", cost:{adamantite:3, dragonBone:14, mithril:2, starFragment:6}},

    // Nord (Bronze)
    {name:"ë“œë¼ìš°í”„ë‹ˆë¥´", type:"nord", score:4, grade:"Bronze", cost:{dragonBone:4, mithril:2}},
    {name:"ë¸Œë¦¬ì‹±ê°€ë©˜", type:"nord", score:5, grade:"Bronze", cost:{mithril:3, starFragment:4}},
    {name:"ë©”ê¸´ìš”ë¥´ë“œ", type:"nord", score:6, grade:"Bronze", cost:{adamantite:9}},
    // Nord (Silver)
    {name:"ê·¸ëŒ", type:"nord", score:10, grade:"Silver", cost:{dragonBone:3, mithril:5, starFragment:3}},
    {name:"ìŠ¤ë°œë¦°", type:"nord", score:12, grade:"Silver", cost:{adamantite:5, mithril:8}},
    {name:"ê²”ë¼ë¥´ í˜¸ë¥¸", type:"nord", score:12, grade:"Silver", cost:{dragonBone:5, mithril:5, starFragment:3}},
    {name:"ë‹¤ì¸ìŠ¬ë ˆì´í”„", type:"nord", score:14, grade:"Silver", cost:{adamantite:5, mithril:3, starFragment:7}},
    {name:"ê¶ë‹ˆë¥´", type:"nord", score:14, grade:"Silver", cost:{adamantite:6, dragonBone:2, starFragment:6}},
    {name:"ê¸€ë ˆì´í”„ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:3, dragonBone:5, starFragment:8}},
    {name:"ë¬ ë‹ˆë¥´", type:"nord", score:16, grade:"Silver", cost:{adamantite:6, mithril:7, starFragment:4}},
    // Nord (Gold)
    {name:"ë ˆë°”í…Œì¸", type:"nord", score:24, grade:"Gold", cost:{adamantite:11, dragonBone:4, mithril:5, starFragment:6}},

    // Celt (Bronze)
    {name:"ì˜¤í•œ", type:"celt", score:4, grade:"Bronze", cost:{adamantite:2, starFragment:4}},
    {name:"ëˆ„ì•„ë‹¤ì˜ ì€íŒ”", type:"celt", score:5, grade:"Bronze", cost:{dragonBone:4, starFragment:2}},
    {name:"ë‹¤ê·¸ë‹¤ì˜ ì†¥", type:"celt", score:6, grade:"Bronze", cost:{dragonBone:4, starFragment:4}},
    // Celt (Silver)
    {name:"ë§ˆë‚˜ë‚œì˜ í™©ê¸ˆ ê°‘ì˜·", type:"celt", score:10, grade:"Silver", cost:{adamantite:7, starFragment:4}},
    {name:"ì¹¼ë¼ë“œë³¼ê·¸", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, mithril:5, starFragment:2}},
    {name:"í˜ë¥´ë””ì•„ì˜ ë¿”ê°€ì£½", type:"celt", score:12, grade:"Silver", cost:{adamantite:5, dragonBone:6, mithril:2}},
    {name:"ê²Œ ë³¼ê·¸", type:"celt", score:14, grade:"Silver", cost:{adamantite:7, dragonBone:4, mithril:4}},
    {name:"ê²Œ ë‹¤ëŸ¬ê·¸", type:"celt", score:14, grade:"Silver", cost:{dragonBone:8, starFragment:7}},
    {name:"í”„ë¼ê°€ë¼í", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:4, mithril:8}},
    {name:"ê²Œ ë¹„ì–´", type:"celt", score:16, grade:"Silver", cost:{adamantite:4, dragonBone:6, mithril:4, starFragment:2}},
    // Celt (Gold)
    {name:"ë¸Œë¥˜ë‚˜í¬", type:"celt", score:24, grade:"Gold", cost:{dragonBone:5, mithril:17, starFragment:3}}
];

// [Update] ë¡œí‚¤ DB (Source: ë¡œí‚¤_ë°ì´í„° í…Œì´ë¸” v1.9.xlsx)
const LOKI_DB = [
    {id:1,name:"êµ¬ë¶€ëŸ¬ì§„ ì‹œê³—ë°”ëŠ˜",desc:"ì‹œê°„ -1H",type:"active_time", count:4},
    {id:2,name:"ë§ê°ì˜ ì£¼íŒ",desc:"ìœ ë¬¼ êµí™˜(ë³´ê´€<->ì‹œì¥)",type:"active_swap", count:1},
    {id:3,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì¼ˆíŠ¸",type:"bless_split",tags:['nord','celt'], count:1},
    {id:4,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì´ì§‘íŠ¸",type:"bless_split",tags:['nord','egypt'], count:1},
    {id:5,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ë…¸ë¥´ë“œ / ì˜¬ë¦¼í¬ìŠ¤",type:"bless_split",tags:['nord','olympus'], count:1},
    {id:6,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì´ì§‘íŠ¸",type:"bless_split",tags:['olympus','egypt'], count:1},
    {id:7,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì´ì§‘íŠ¸ / ì¼ˆíŠ¸",type:"bless_split",tags:['egypt','celt'], count:1},
    {id:8,name:"ë¶ˆì™„ì „í•œ ì¶•ë³µ",desc:"ì˜¬ë¦¼í¬ìŠ¤ / ì¼ˆíŠ¸",type:"bless_split",tags:['olympus','celt'], count:1},
    {id:9,name:"í˜¼ëˆì˜ ì±„ì„ë§ì¹˜",desc:"ì‹œì¥ ìì› ë¦¬ì…‹",type:"active_reset", count:1},
    {id:10,name:"ë¶€ì„œì§„ íšŒì¤‘ì‹œê³„",desc:"ìœ ë¬¼ ì œì‘ ì‹œê°„ 0",type:"passive_free", count:1},
    {id:11,name:"ê³„ìŠ¹ìì˜ ë¬¸ì¥",desc:"ì¦‰ì‹œ +2ì ",type:"instant_score", count:4},
    {id:12,name:"ë¯¸ë˜ ì¼ê¸°",desc:"ë± ìœ„ 3ì¥ í™•ì¸, 1ì¥ íšë“",type:"active_peek", count:1},
    {id:13,name:"ê²€ì€ ì£¼ì‚¬ìœ„",desc:"ì†íŒ¨ 2ì¥ ë²„ë¦¬ê³  2ì¥ ë“œë¡œìš°",type:"active_draw", count:1},
    {id:14,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'dragonBone',val:4}], count:1},
    {id:15,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'mithril',val:4}], count:1},
    {id:16,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'starFragment',val:4},{type:'adamantite',val:4}], count:1},
    {id:17,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'dragonBone',val:4}], count:1},
    {id:18,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'adamantite',val:4},{type:'mithril',val:4}], count:1},
    {id:19,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(OR)",type:"res_split",mode:"OR",options:[{type:'dragonBone',val:4},{type:'mithril',val:4}], count:1},
    {id:20,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'dragonBone',val:2}], count:1},
    {id:21,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'mithril',val:2}], count:1},
    {id:22,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'mithril',val:2}], count:1},
    {id:23,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'dragonBone',val:2},{type:'starFragment',val:2}], count:1},
    {id:24,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'starFragment',val:2},{type:'mithril',val:2}], count:1},
    {id:25,name:"ë¶ˆì•ˆì • ìœµí•©ì„",desc:"ì¬ë£Œ(AND)",type:"res_split",mode:"AND",options:[{type:'adamantite',val:2},{type:'starFragment',val:2}], count:1},
    {id:26,name:"íŒŒê´´ëœ ì„±ë°°",desc:"ì‹œì¥ ì¶•ë³µ ë¦¬ì…‹",type:"active_reset_bless", count:1}
];
class Card {
    constructor(cat, type, val = null, extra = null) {
        this.cat = cat;
        this.type = type; 
        this.val = val; 
        this.extra = extra;
        this.id = Math.random().toString(36).substr(2, 9);
    }
}

class Deck {
    constructor(cat) {
        this.cat = cat;
        this.cards = [];
        this.discardPile = [];
        this.init();
    }

    init() {
        if (this.cat === 'resource') {
            const types = Object.keys(RES_NAMES);
            const vals = [2, 3, 4, 5, 6, 7];
            types.forEach(t => vals.forEach(v => {
                for (let i = 0; i < 3; i++) this.cards.push(new Card('resource', t, v));
            }));
        } else if (this.cat === 'blessing') {
            const types = Object.keys(TYPE_NAMES);
            types.forEach(t => {
                for (let i = 0; i < 8; i++) this.cards.push(new Card('blessing', t));
            });
        } else if (this.cat === 'artifact') {
            ARTIFACT_DB.forEach(art => this.cards.push({ ...art })); 
        } else if (this.cat === 'loki') {
            LOKI_DB.forEach(def => {
                for(let i=0; i<def.count; i++) {
                    this.cards.push(new Card('loki', 'loki', null, def));
                }
            });
        }
        this.shuffle();
    }

    shuffle() { this.cards.sort(() => Math.random() - 0.5); }

    draw() {
        if (this.cards.length === 0) {
            if (this.cat === 'loki' || this.discardPile.length === 0) return null;
            this.cards = [...this.discardPile];
            this.discardPile = [];
            this.shuffle();
        }
        return this.cards.pop();
    }

    peek(count) { return this.cards.slice(-count).reverse(); } // ë¯¸ë˜ì¼ê¸°ìš©

    discard(card) { this.discardPile.push(card); }
    getCount() { return this.cards.length; }
}

class Player {
    constructor(id) {
        this.id = id;
        this.hand = [];
        this.reserved = [];
        this.artifacts = [];
        this.score = 0;
        this.time = 0;
        this.stackOrder = 0;
        this.targetMyth = null; 
        this.celtConvertCount = 0;
        this.celtMimicMode = null;
        this.aiTargetIdx = null;
        this.olympusDiscount = { type: null, amount: 0 };
        
        // [Data Mining] ë°ì´í„° ë¶„ì„ìš© í•„ë“œ
        this.dailyScore = [-1, -1, -1, -1, -1]; 
        this.history = []; 
        this.totalTurns = 0; 
        this.lvl3Turn = { olympus: -1, egypt: -1, nord: -1, celt: -1 };
        this.usedLokiIds = []; 

        // [Update] ì€ì´(Grace) ë©”íŠ¸ë¦­ ì¶”ê°€
        this.metrics = { 
            savedRes: 0, wastedCards: 0, celtSwaps: 0,
            resAcquired: 0, resConsumed: 0, lokiUsed: 0,
            graceCount: 0,  // ì€ì´ íšë“ íšŸìˆ˜
            graceScore: 0   // ì€ì´ìœ¼ë¡œ ì–»ì€ ì¶”ê°€ ì ìˆ˜
        };
        this.milestones = {}; 
    }

    getHandCount() {
        return this.hand.filter(c => c.cat !== 'loki').length;
    }

    recordLokiUse(card) {
        this.metrics.lokiUsed++;
        if (card && card.extra && card.extra.id) {
            this.usedLokiIds.push(card.extra.id);
        }
    }
}

// ==========================================
// [Part 2] Game Engine (Core Logic - UI Free)
// ==========================================

class Game {
    constructor() {
        this.isInitialized = false;
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        this.players = [];
        this.pIdx = 0;
    }

    init(mythAssignments) {
        this.day = 1;
        this.isGameEnded = false;
        this.craftOrder = 0;
        
        this.players = [new Player(1), new Player(2), new Player(3), new Player(4)];
        this.players.forEach((p, i) => {
            p.targetMyth = mythAssignments ? mythAssignments[i] : ['olympus', 'egypt', 'nord', 'celt'][i];
            const rule = START_RULE[i];
            p.score = rule.score;
            p.stackOrder = 3 - i; 
        });

        this.deckRes = new Deck('resource');
        this.deckBless = new Deck('blessing');
        this.deckArt = new Deck('artifact');
        this.deckLoki = new Deck('loki');

        this.fieldRes = [];
        this.fieldBless = [];
        this.fieldArt = [];

        this.fill('resource', 6);
        this.fill('blessing', 4);
        this.fill('artifact', 7);

        this.players.forEach((p, i) => {
            const rule = START_RULE[i];
            for(let k=0; k<rule.res; k++) { const c = this.deckRes.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.bless; k++) { const c = this.deckBless.draw(); if(c) p.hand.push(c); }
            for(let k=0; k<rule.loki; k++) { const c = this.deckLoki.draw(); if(c) p.hand.push(c); }
        });

        this.pIdx = 0;
        this.isInitialized = true;
    }

    get cp() { return this.players[this.pIdx]; }

    fill(cat, max) {
        const field = cat === 'resource' ? this.fieldRes : (cat === 'blessing' ? this.fieldBless : this.fieldArt);
        const deck = cat === 'resource' ? this.deckRes : (cat === 'blessing' ? this.deckBless : this.deckArt);
        while(field.length < max) {
            const c = deck.draw();
            if(c) field.push(c);
            else break;
        }
    }

    getArtLevel(type) {
        const p = this.cp;
        let count = p.artifacts.filter(a => a.type === type).length;
        const celtCount = p.artifacts.filter(a => a.type === 'celt').length;
        // ì¼ˆíŠ¸ 3ë‹¨ê³„ ë¯¸ë¯¹ ì ìš©
        if (type !== 'celt' && celtCount >= 3 && p.celtMimicMode === type) count += 1;
        // ì¼ˆíŠ¸ ìì‹ ì€ ë¯¸ë¯¹ íš¨ê³¼ ëª» ë°›ìŒ (ì´ë¯¸ 3ì¥ì´ë¯€ë¡œ ì˜ë¯¸ ì—†ê¸°ë„ í•¨)
        if (type === 'celt' && celtCount >= 3 && p.celtMimicMode !== null) return 0;
        return count;
    }

    getCost(action) {
        let cost = CONFIG.COST[action];
        const egyptLv = this.getArtLevel('egypt');
        
        // ì´ì§‘íŠ¸ í• ì¸ ì ìš© (ëˆ„ì  ë°©ì‹)
        let discount = 0;
        const maxLevel = Math.min(egyptLv, 3);
        
        for (let i = 0; i < maxLevel; i++) {
            // BALANCE_CONFIGê°€ ë°°ì—´ì¸ì§€ í™•ì¸í•˜ê³  ì•ˆì „í•˜ê²Œ ì ‘ê·¼
            if (Array.isArray(BALANCE_CONFIG.EGYPT)) {
                const levelConfig = BALANCE_CONFIG.EGYPT[i];
                if (levelConfig) {
                    if (action === 'RESERVE') discount += levelConfig.RESERVE;
                    else if (action === 'RES') discount += levelConfig.RES;
                    else if (action === 'BLESS') discount += levelConfig.BLESS;
                    else if (action === 'ART') discount += levelConfig.ART;
                }
            } else {
                // êµ¬ë²„ì „ í˜¸í™˜ìš© (í˜¹ì‹œ ëª¨ë¥¼ ì—ëŸ¬ ë°©ì§€)
                if (action === 'RESERVE' && i === 0) discount += 1;
                if (action === 'RES' && i === 1) discount += 1;
                if ((action === 'BLESS' || action === 'ART') && i === 2) discount += 1;
            }
        }
        
        cost -= discount;
        return Math.max(0, cost);
    }

    consumeTime(amount) {
        const p = this.cp;
        const targetTime = p.time + amount;
        let maxStack = -1;
        this.players.forEach(other => {
            if (other.id !== p.id && other.time === targetTime) {
                if (other.stackOrder > maxStack) maxStack = other.stackOrder;
            }
        });
        p.time = targetTime;
        p.stackOrder = maxStack + 1;
        this.determineNextTurn();
    }

    determineNextTurn() {
        if (this.isGameEnded) return;
        if (this.players.every(p => p.time >= CONFIG.MAX_TIME)) { this.processDayEnd(); return; }
        
        let candidates = this.players.filter(p => p.time < CONFIG.MAX_TIME);
        if (candidates.length === 0) { this.processDayEnd(); return; }

        candidates.sort((a, b) => {
            if (a.time !== b.time) return a.time - b.time;
            return b.stackOrder - a.stackOrder;
        });

        const nextPlayer = candidates[0];
        if (this.cp.id !== nextPlayer.id) {
            this.pIdx = this.players.indexOf(nextPlayer);
            this.cp.celtConvertCount = 0; // í„´ ë³€ê²½ ì‹œ ì¼ˆíŠ¸ ì¹´ìš´íŠ¸ ë¦¬ì…‹
        }
    }

   processDayEnd() {
        this.players.forEach(p => {
            // 1. ì ìˆ˜ ê¸°ë¡
            if (this.day <= 5) p.dailyScore[this.day - 1] = p.score;
            
            // 2. [ì¶”ê°€ë¨] ìœ ë¬¼ ìƒíƒœ ìŠ¤ëƒ…ìƒ· ê¸°ë¡ (ì—‘ì…€ ë¶„ì„ìš©)
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(a => { if(counts[a.type] !== undefined) counts[a.type]++; });
            
            p.history.push({
                day: this.day,
                score: p.score,
                olympus: counts.olympus,
                egypt: counts.egypt,
                nord: counts.nord,
                celt: counts.celt
            });
        });

        if (this.day >= CONFIG.MAX_DAYS) { this.endGame(); return; }
        
        this.processNightInstant();
        this.day++;
        
        this.fieldRes.forEach(c => this.deckRes.discard(c)); this.fieldRes = [];
        this.fieldBless.forEach(c => this.deckBless.discard(c)); this.fieldBless = [];
        this.fill('resource', 6); this.fill('blessing', 4);

        this.players.forEach(p => { p.time = Math.max(0, p.time - CONFIG.MAX_TIME); });

        if (this.day > CONFIG.MAX_DAYS) this.endGame();
        else this.determineNextTurn();
    }
    processNightInstant() {
        let offers = [];
        for(let i=0; i<6; i++) offers.push(this.deckLoki.draw());
        let selections = {};
        this.players.forEach(p => { selections[p.id] = Math.floor(Math.random() * 6); });
        let counts = {};
        Object.values(selections).forEach(slot => { counts[slot] = (counts[slot] || 0) + 1; });

        this.players.forEach(p => {
            const choice = selections[p.id];
            if (counts[choice] === 1 && offers[choice]) {
                const item = offers[choice];
                if (item.extra.type === 'instant_score') p.score += 2;
                else p.hand.push(item);
            }
        });
    }

    endGame() {
        if (this.isGameEnded) return;
        this.isGameEnded = true;
        this.players.forEach(p => {
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            p.artifacts.forEach(art => { if(counts[art.type] !== undefined) counts[art.type]++; });
            
            // 4ì¢… í†µí•© ë³´ë„ˆìŠ¤
            if(counts.olympus > 0 && counts.egypt > 0 && counts.nord > 0 && counts.celt > 0) p.score += 5;
            
            // ì‹ í™” ì „ë¬¸í™” ë³´ë„ˆìŠ¤
            for(const [type, count] of Object.entries(counts)) {
                if(count >= 4) p.score += (count - 3) * 2;
            }
        });
    }
}
// [ì‹ ê·œ ì¶”ê°€: Game í´ë˜ìŠ¤ ë©”ì„œë“œ]
// ==================================================================================
// [Part 3] AI Brain (Final Integrated v10.5 - All Fixes Included)
// ==================================================================================
/* í¬í•¨ëœ ìˆ˜ì • ì‚¬í•­:
   1. ì¼ˆíŠ¸: ë ˆë²¨ íŒë‹¨ ë¡œì§ (>=) ìˆ˜ì • ë° ìë™ íƒœì„¸ ì „í™˜
   2. ì€ì´(Grace): ì •í™•í•œ ìì› ì§€ë¶ˆ ì‹œ ì ìˆ˜ ê°€ì‚° (+2/3/4)
   3. ë¡œí‚¤: ë¯¸ë˜ì¼ê¸° ë± ì¡°ì‘ ë²„ê·¸ ìˆ˜ì •, ë§ê°ì˜ ì£¼íŒ ì „ëµì  ì‚¬ìš© ì¶”ê°€
   4. ë…¸ë¥´ë“œ: ìì› ë­‰ì³ ë¨¹ê¸° (2~3ì¥) ë¡œì§ ë³µêµ¬
   5. ì „ëµ: aiFindBestPlan ëˆ„ë½ ë³µêµ¬
*/

// 0. í•¸ë“œ ì œí•œ ìœ ë™ì  ê³„ì‚°
Game.prototype.getCurrentHandLimit = function() {
    const ai = this.cp;
    const nordLv = this.getArtLevel('nord');
    const defaultLimit = CONFIG.HAND_LIMIT;

    if (nordLv >= 3) return BALANCE_CONFIG.NORD.HAND_LIMIT_LV3 || BALANCE_CONFIG.NORD.HAND_LIMIT_LV2 || defaultLimit;
    if (nordLv >= 2) return BALANCE_CONFIG.NORD.HAND_LIMIT_LV2 || defaultLimit;
    return defaultLimit;
};

// 1. [íƒœì„¸ ì „í™˜] ì¼ˆíŠ¸ 3ë‹¨ê³„ ëŠ¥ë ¥ ìë™ ìŠ¤ìœ„ì¹­
Game.prototype.aiAutoSwitchCeltMode = function(plan) {
    const cachedSetting = BALANCE_CONFIG.CELT.MIMIC_ENABLED;
    const isMimicEnabled = (cachedSetting !== undefined) ? cachedSetting : true;

    if (!isMimicEnabled) {
        if (this.cp.celtMimicMode !== null) this.cp.celtMimicMode = null;
        return;
    }

    const ai = this.cp;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    if (realCeltCount < 3) return;

    let targetMode = null; 
    if (plan && plan.preferredMode) {
        targetMode = plan.preferredMode === 'celt' ? null : plan.preferredMode;
    } else {
        if (plan && plan.action === 'GATHER' && ai.getHandCount() <= 4) targetMode = 'nord';
        else if (ai.time >= 9) targetMode = 'egypt';
    }

    if (ai.celtMimicMode !== targetMode) {
        ai.celtMimicMode = targetMode;
    }
};

// 2. [ê°€ì¹˜ íŒë‹¨] ìœ ë¬¼ ê°€ì¹˜ ë° ë¹„ìš© ê³„ì‚° (Core Logic - Fixed)
Game.prototype.aiCalculateTargetValue = function(art, isReserved) {
    const ai = this.cp;
    
    // [Safety] ì„¤ì •ê°’ ë¡œë“œ
    const cachedSetting = BALANCE_CONFIG.CELT.MIMIC_ENABLED;
    const mimicEnabled = (cachedSetting !== undefined) ? cachedSetting : true;

    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
    const canMimic = (realCeltCount >= 3 && mimicEnabled);

    const myRes = { adamantite:0, mithril:0, dragonBone:0, starFragment:0 };
    let totalHandCount = 0;
    ai.hand.forEach(c => {
        totalHandCount++;
        if (c.cat === 'resource') myRes[c.type] = (myRes[c.type]||0) + c.val;
        else if (c.cat === 'loki' && c.extra.type === 'res_split') {
            myRes[c.extra.options[0].type] = (myRes[c.extra.options[0].type]||0) + 4;
        }
    });

    const calculateScenario = (mode) => {
        let simOlympusLv, simCeltLv;
        if (!canMimic) { simOlympusLv = this.getArtLevel('olympus'); simCeltLv = realCeltCount; } 
        else {
            const realOlympus = ai.artifacts.filter(a => a.type === 'olympus').length;
            if (mode === 'olympus') { simOlympusLv = Math.max(realOlympus, 3); simCeltLv = 0; }
            else if (mode === 'celt') { simOlympusLv = realOlympus; simCeltLv = 3; }
            else { simOlympusLv = realOlympus; simCeltLv = realCeltCount; }
        }

        let tempCost = { ...art.cost };
        let discountType = null;
        if (simOlympusLv > 0) {
            const amt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(simOlympusLv, 3)];
            let maxSaved = -1;
            for(let t in tempCost) {
                if(tempCost[t] > 0) {
                    let saved = Math.min(tempCost[t], amt);
                    if(saved > maxSaved) { maxSaved = saved; discountType = t; }
                }
            }
            if(discountType) tempCost[discountType] = Math.max(0, tempCost[discountType] - amt);
        }

        let availableSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(simCeltLv, 3)] - ai.celtConvertCount;
        let needsSwap = false;
        let tempHandCount = totalHandCount;
        let missing = 0;

        for(let t in tempCost) {
            let need = Math.max(0, tempCost[t] - (myRes[t]||0));
            if (need > 0 && availableSwaps > 0) {
                const cardsNeeded = Math.ceil(need / 4);
                if (tempHandCount >= cardsNeeded && availableSwaps >= cardsNeeded) {
                    availableSwaps -= cardsNeeded; tempHandCount -= cardsNeeded; need = 0; needsSwap = true;
                }
            }
            missing += need;
        }
        return { missing, needsSwap, discountType, mode };
    };

    const currentMode = canMimic ? (ai.celtMimicMode || 'celt') : 'celt';
    let bestScenario = calculateScenario(currentMode); 
    
    if (canMimic) {
        const sO = calculateScenario('olympus');
        const sC = calculateScenario('celt');
        if (sO.missing <= 0 && sC.missing > 0) bestScenario = sO;
        else if (sC.missing <= 0 && sO.missing > 0) bestScenario = sC;
        else if (sO.missing <= 0 && sC.missing <= 0) bestScenario = sO; 
        else bestScenario = (sO.missing < sC.missing) ? sO : sC;
    }

    let action = bestScenario.missing <= 0 ? 'CRAFT' : 'GATHER';
    
    // [Update] ì€ì´(Grace) ì ìˆ˜ ê¸°ëŒ€ê°’ ë°˜ì˜
    let graceBonus = 0;
    if (art.grade === 'Gold') graceBonus = 4;
    else if (art.grade === 'Silver') graceBonus = 3;
    else graceBonus = 2; // Bronze

    let net = (art.score + graceBonus) * 10;

    const currentMythCount = ai.artifacts.filter(a => a.type === ai.targetMyth).length;
    if (ai.targetMyth && art.type === ai.targetMyth && currentMythCount < 3) {
        net += 100;
    }

    if (action === 'CRAFT') {
        net += 5000;
        if (isReserved) net += 2000;
        if (bestScenario.needsSwap) net += 50; 
    } else {
        net += Math.max(0, 500 - bestScenario.missing * 5);
        
        let effNord;
        if (!canMimic) {
            effNord = this.getArtLevel('nord');
        } else {
            const isNordMode = bestScenario.mode === 'nord' || ai.celtMimicMode === 'nord';
            const canSwitchToNord = bestScenario.mode === 'celt' || bestScenario.mode === null;
            if (isNordMode || canSwitchToNord) effNord = ai.artifacts.filter(a => a.type === 'nord').length + 1;
            else effNord = ai.artifacts.filter(a => a.type === 'nord').length;
        }

        let speed = BALANCE_CONFIG.NORD.GATHER_SPEED[Math.min(effNord, 3)];
        net -= (Math.ceil(bestScenario.missing / speed) * 10);
    }

    let timeCost = CONFIG.COST[action];
    let effEgy = !canMimic ? this.getArtLevel('egypt') : (bestScenario.mode==='egypt'||ai.celtMimicMode==='egypt' ? Math.max(ai.artifacts.filter(a=>a.type==='egypt').length,3) : ai.artifacts.filter(a=>a.type==='egypt').length);
    let egyDisc = 0;
    for(let i=0; i<Math.min(effEgy, 3); i++) {
        if (Array.isArray(BALANCE_CONFIG.EGYPT) && BALANCE_CONFIG.EGYPT[i]) {
             const c = BALANCE_CONFIG.EGYPT[i];
             egyDisc += (action==='RESERVE'?c.RESERVE : action==='GATHER'?c.RES : action==='CRAFT'?c.ART : 0);
        }
    }
    timeCost = Math.max(0, timeCost - egyDisc);
    if (timeCost <= 0) net += 150; else if (timeCost < CONFIG.COST[action]) net += 50;

    // [Fix] ì¼ˆíŠ¸ ë¡œì§ ìˆ˜ì •: .includes() -> >= ë¹„êµ ì—°ì‚°
    let hasBless = ai.hand.some(c => (c.cat === 'blessing' && c.type === art.type) || (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
    
    const allowConvert = realCeltCount >= BALANCE_CONFIG.CELT.LVL_CONVERT;
    const allowFree = realCeltCount >= BALANCE_CONFIG.CELT.LVL_FREE;

    if (!hasBless && allowConvert) {
        hasBless = ai.hand.some(c => c.cat === 'blessing' || (c.cat === 'loki' && c.extra.type === 'bless_split'));
    }
    let needBless = !hasBless && !allowFree;
    if (needBless) net -= 5000;

    let finalPreferredMode = bestScenario.mode;
    if (action === 'GATHER' && canMimic) {
        let nordIdx = Math.max(0, Math.min(this.getArtLevel('nord')+1, 3)-1);
        let nordCap = BALANCE_CONFIG.NORD.LIMIT_COUNT[Math.min(nordIdx, 2)];
        let rawMissing = 0; for(let t in art.cost) if(art.cost[t] > (myRes[t]||0)) rawMissing += (art.cost[t]-(myRes[t]||0));
        
        if (bestScenario.needsSwap) {
             if (ai.getHandCount() <= 4 && rawMissing >= 2 && nordCap >= 2) { finalPreferredMode = 'nord'; net += 150; }
             else { finalPreferredMode = 'celt'; net += 200; }
        } else if (rawMissing >= 1 && nordCap >= 2 && ai.getHandCount() <= 6) { 
            finalPreferredMode = 'nord'; net += 150; 
        } else if (bestScenario.missing === 1 && finalPreferredMode !== 'celt') { 
            finalPreferredMode = 'egypt'; net += 40; 
        }
    }

    return { art, netValue: net, action, fromReserve: isReserved, discountType: bestScenario.discountType, targetIdx: -1, needBless, missingVal: bestScenario.missing, preferredMode: finalPreferredMode };
};

// 3. [ì „ìˆ  ì‹¤í–‰] ë¡œí‚¤ ì¹´ë“œ ì‚¬ìš© (v10.5 Safe Logic)
Game.prototype.aiPlayLokiTactics = function() {
    const ai = this.cp;
    
    // 1. ê³„ìŠ¹ìì˜ ë¬¸ì¥
    const crestIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'instant_score');
    if (crestIdx !== -1) { 
        ai.score += 2; 
        const card = ai.hand[crestIdx];
        ai.hand.splice(crestIdx, 1); 
        ai.recordLokiUse(card); 
        return true; 
    }

    // 2. êµ¬ë¶€ëŸ¬ì§„ ì‹œê³—ë°”ëŠ˜
    const clockIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_time');
    if (clockIdx !== -1) {
        if (ai.time >= 9 || (ai.score < 10 && ai.time >= 7)) {
            ai.time = Math.max(0, ai.time - 1); 
            const card = ai.hand[clockIdx];
            ai.hand.splice(clockIdx, 1); 
            ai.recordLokiUse(card); 
            return true;
        }
    }

    // 3. ê²€ì€ ì£¼ì‚¬ìœ„
    const diceIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_draw');
    if (diceIdx !== -1) {
        const junkIndices = ai.hand.map((c, i) => (c.cat === 'resource' && c.val <= 3) ? i : -1).filter(i => i !== -1);
        if (junkIndices.length >= 2) {
            let targets = [diceIdx, junkIndices[0], junkIndices[1]];
            targets = [...new Set(targets)];
            targets.sort((a, b) => b - a); 
            const lokiCard = ai.hand[diceIdx]; 
            targets.forEach(idx => ai.hand.splice(idx, 1));
            for(let k=0; k<2; k++) { 
                const newCard = this.deckRes.draw(); 
                if(newCard) { ai.hand.push(newCard); ai.metrics.resAcquired += newCard.val; }
            }
            ai.recordLokiUse(lokiCard); 
            this.consumeTime(1); 
            return true;
        }
    }

    // 4. ë¯¸ë˜ ì¼ê¸° (ìˆ˜ì •ë¨: ì•ˆì „í•œ draw ì‚¬ìš©)
    const diaryIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_peek');
    if (diaryIdx !== -1 && ai.reserved.length < 1) { 
        const candidates = [];
        for(let k=0; k<3; k++) { 
            const c = this.deckArt.draw(); 
            if(c) candidates.push(c); 
        }
        if (candidates.length > 0) {
            candidates.sort((a, b) => b.score - a.score);
            const selected = candidates[0];
            ai.reserved.push(selected);
            for(let k=1; k<candidates.length; k++) this.deckArt.discard(candidates[k]);
            
            const card = ai.hand[diaryIdx];
            ai.hand.splice(diaryIdx, 1);
            ai.recordLokiUse(card); 
            this.consumeTime(1);
            return true;
        }
    }

    // 5. í˜¼ëˆì˜ ì±„ì„ë§ì¹˜
    const hammerIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_reset');
    if (hammerIdx !== -1) {
        const fieldSum = this.fieldRes.reduce((a, b) => a + b.val, 0);
        const fieldAvg = this.fieldRes.length > 0 ? fieldSum / this.fieldRes.length : 0;
        const hasHighValue = this.fieldRes.some(c => c.val >= 6);

        if (fieldAvg <= 3.5 && !hasHighValue) {
            this.fieldRes.forEach(c => this.deckRes.discard(c));
            this.fieldRes = [];
            this.fill('resource', 6);
            const card = ai.hand[hammerIdx];
            ai.hand.splice(hammerIdx, 1);
            ai.recordLokiUse(card); 
            this.consumeTime(1);
            return true;
        }
    }
    return false;
};

// 4. [ì „ëµ ìˆ˜ë¦½] ìµœì  ê³„íš ì°¾ê¸° (ë§ê°ì˜ ì£¼íŒ ë¡œì§ í¬í•¨ - Fixed)
Game.prototype.aiFindBestPlan = function() {
    const ai = this.cp;
    let bestScore = -Infinity;
    let bestPlan = null;

    // 1) ë§ê°ì˜ ì£¼íŒ
    const abacusIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_swap');
    if (abacusIdx !== -1 && ai.reserved.length > 0 && this.fieldArt.length > 0) {
        let worstRes = { score: 999, idx: -1 };
        ai.reserved.forEach((art, i) => { if(art.score < worstRes.score) worstRes = {score: art.score, idx: i}; });
        let bestMkt = { score: -1, idx: -1 };
        this.fieldArt.forEach((art, i) => { if(art.score > bestMkt.score) bestMkt = {score: art.score, idx: i}; });
        
        if (bestMkt.score - worstRes.score >= 6) {
            return { action: 'SWAP_ARTIFACT', handIdx: abacusIdx, reserveIdx: worstRes.idx, marketIdx: bestMkt.idx };
        }
    }

    // 2) ì˜ˆì•½ ìœ ë¬¼
    ai.reserved.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, true);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    // 3) ì‹œì¥ ìœ ë¬¼
    this.fieldArt.forEach((art, idx) => {
        const analysis = this.aiCalculateTargetValue(art, false);
        analysis.targetIdx = idx;
        if (analysis.netValue > bestScore) { bestScore = analysis.netValue; bestPlan = analysis; }
    });

    return bestPlan;
};

// 5. [í–‰ë™ ì‹¤í–‰] ì œì‘ íŠ¸ëœì­ì…˜ (ì¼ˆíŠ¸ ë¡œì§ ìˆ˜ì • & ì€ì´ ì ìš© - Fixed)
Game.prototype.processCraftTransaction = function(ai, plan) {
    const art = plan.art;
    const fromReserve = plan.fromReserve;
    const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;

    let requirements = { ...art.cost };
    let olympusSavedAmount = 0;

    // ì˜¬ë¦¼í¬ìŠ¤ í• ì¸
    if (plan.discountType) {
        const olympusLv = this.getArtLevel('olympus'); 
        const amt = BALANCE_CONFIG.OLYMPUS.DISCOUNT[Math.min(olympusLv, 3)];
        requirements[plan.discountType] = Math.max(0, requirements[plan.discountType] - amt);
        olympusSavedAmount = amt;
    }

    let cardsToPay = [];
    let hand = [...ai.hand];
    let isExactMatch = true; // ì€ì´ ì²´í¬ìš©

    // 1. ìì› ì§€ë¶ˆ
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'resource' && c.type === reqType) {
                if (c.val > needed) isExactMatch = false; 
                needed -= c.val; 
                cardsToPay.push(c); hand.splice(i, 1); ai.metrics.resConsumed += c.val; 
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }
    
    // 2. ë¡œí‚¤ ìì› ëŒ€ì²´
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal; if (needed <= 0) continue;
        for (let i = hand.length - 1; i >= 0; i--) {
            if (needed <= 0) break;
            let c = hand[i];
            if (c.cat === 'loki' && c.extra.type === 'res_split' && c.extra.options.some(opt => opt.type === reqType)) {
                if (4 > needed) isExactMatch = false;
                needed -= 4; cardsToPay.push(c); hand.splice(i, 1); ai.metrics.resConsumed += 4;
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }
    
    // 3. ì¼ˆíŠ¸ ìì› ë³€í™˜
    const activeCeltLv = this.getArtLevel('celt');
    const maxSwaps = BALANCE_CONFIG.CELT.SWAP_LIMIT[Math.min(activeCeltLv, 3)];
    let usedSwaps = 0; let currentTotalSwaps = ai.celtConvertCount;
    
    for (const [reqType, reqVal] of Object.entries(requirements)) {
        let needed = reqVal; if (needed <= 0) continue;
        if (currentTotalSwaps < maxSwaps) {
            for (let i = hand.length - 1; i >= 0; i--) {
                if (needed <= 0 || currentTotalSwaps >= maxSwaps) break;
                let c = hand[i];
                if (c.cat === 'resource') {
                    if (c.val > needed) isExactMatch = false;
                    needed -= c.val; cardsToPay.push(c); hand.splice(i, 1); usedSwaps++; currentTotalSwaps++; ai.metrics.resConsumed += c.val; 
                }
            }
        }
        requirements[reqType] = Math.max(0, needed);
    }

    if (Object.values(requirements).reduce((a,b)=>a+b, 0) > 0) return false;

    const isConvert = realCeltCount >= BALANCE_CONFIG.CELT.LVL_CONVERT;
    const isFree = realCeltCount >= BALANCE_CONFIG.CELT.LVL_FREE;
    
    if (!isFree) {
         let blessIdx = hand.findIndex(c => (c.cat === 'blessing' && c.type === art.type) || (c.cat === 'loki' && c.extra.type === 'bless_split' && c.extra.tags.includes(art.type)));
         if (blessIdx === -1 && isConvert) blessIdx = hand.findIndex(c => c.cat === 'blessing' || (c.cat === 'loki' && c.extra.type === 'bless_split'));
         if (blessIdx !== -1) { cardsToPay.push(hand[blessIdx]); hand.splice(blessIdx, 1); } else return false;
    }

    if (olympusSavedAmount > 0) ai.metrics.savedRes += olympusSavedAmount;
    if (usedSwaps > 0) { ai.metrics.celtSwaps += usedSwaps; ai.celtConvertCount += usedSwaps; }
    ai.hand = hand;
    cardsToPay.forEach(c => {
        if(c.cat === 'resource') this.deckRes.discard(c);
        else if(c.cat === 'blessing') this.deckBless.discard(c);
        else if(c.cat === 'loki') this.deckLoki.discard(c); 
    });

    let graceBonus = 0;
    if (isExactMatch) {
        if (art.grade === 'Gold') graceBonus = 4;
        else if (art.grade === 'Silver') graceBonus = 3;
        else graceBonus = 2; // Bronze
        ai.metrics.graceCount++;
        ai.metrics.graceScore += graceBonus;
    }

    const craftedArt = { ...art, isGrace: isExactMatch, finalScore: art.score + graceBonus, bonus: graceBonus };
    ai.artifacts.push(craftedArt);
    ai.score += craftedArt.finalScore;

    const typeCount = ai.artifacts.filter(a => a.type === craftedArt.type).length;
    if (typeCount === 3) {
        if (ai.milestones[craftedArt.type] === undefined) ai.milestones[craftedArt.type] = this.craftOrder++;
        if (ai.lvl3Turn[craftedArt.type] === -1) ai.lvl3Turn[craftedArt.type] = ai.totalTurns;
    }

    if (fromReserve) ai.reserved.splice(plan.targetIdx, 1);
    else { this.fieldArt.splice(plan.targetIdx, 1); this.fill('artifact', 7); }
    
    const freeCardIdx = cardsToPay.findIndex(c => c.cat === 'loki' && c.extra.type === 'passive_free');
    if (freeCardIdx !== -1) { 
        ai.recordLokiUse(cardsToPay[freeCardIdx]); 
        this.consumeTime(0); 
    }
    else this.consumeTime(this.getCost('ART'));

    return true;
};

// 6. [AI ë©”ì¸] í„´ ì‹¤í–‰ í•¨ìˆ˜ (Final Clean Version)
Game.prototype.aiTurn = function() {
    const ai = this.cp;
    // 1. ê¸°ë³¸ ì¢…ë£Œ ì¡°ê±´ ì²´í¬ (ì‹œê°„ ë‹¤ ì”€ or ê²Œì„ ì¢…ë£Œ í”Œë˜ê·¸)
    if (this.isGameEnded || ai.time >= CONFIG.MAX_TIME) return;

    ai.totalTurns++; 
    
    // [ë³€ê²½ë¨] í•¸ë“œ ì²´í¬ ë¡œì§ ì‚­ì œ (í„´ ì‹œì‘ ì‹œì ì—ëŠ” ì²´í¬í•˜ì§€ ì•ŠìŒ)

    // 2. ë¡œí‚¤ ì „ìˆ  ì‹¤í–‰
    const lokiPlayed = this.aiPlayLokiTactics();

    if (!lokiPlayed) {
        // 3. ì „ëµ ìˆ˜ë¦½ (ë¡œí‚¤ë¥¼ ì“°ì§€ ì•Šì•˜ì„ ë•Œë§Œ ì‹¤í–‰)
        const bestPlan = this.aiFindBestPlan();
        
        if (!bestPlan) { 
            this.aiEmergencyAction(); 
        } else {
            // íƒœì„¸ ì „í™˜
            this.aiAutoSwitchCeltMode(bestPlan);
            ai.aiTargetIdx = bestPlan.targetIdx;

            // 4. í–‰ë™ ë¶„ê¸°
            if (bestPlan.action === 'SWAP_ARTIFACT') {
                const myArt = ai.reserved[bestPlan.reserveIdx];
                const marketArt = this.fieldArt[bestPlan.marketIdx];
                ai.reserved[bestPlan.reserveIdx] = marketArt;
                this.fieldArt[bestPlan.marketIdx] = myArt;
                ai.hand.splice(bestPlan.handIdx, 1);
                this.consumeTime(this.getCost('SWAP'));
            }
            else if (bestPlan.action === 'CRAFT') {
                const success = this.processCraftTransaction(ai, bestPlan);
                if (!success) this.aiActionGather(bestPlan);
            } 
            else if (bestPlan.action === 'RESERVE') {
                if (ai.reserved.length >= 1) {
                    this.aiActionGather(bestPlan);
                } else {
                    const art = this.fieldArt[bestPlan.targetIdx];
                    if (art) {
                        ai.reserved.push(art);
                        this.fieldArt.splice(bestPlan.targetIdx, 1);
                        this.fill('artifact', 7);
                        this.consumeTime(this.getCost('RESERVE'));
                    } else {
                        this.aiEmergencyAction();
                    }
                }
            }
            else { 
                this.aiActionGather(bestPlan);
            }
        }
    }

    // [ìµœì¢… ë¡œì§] í„´ ì¢…ë£Œ ë‹¨ê³„: í•¸ë“œ ì œí•œì„ ë§ì¶œ ë•Œê¹Œì§€ ë°˜ë³µ ë²„ë¦¬ê¸°
    // ê²Œì„ ì¢…ë£Œ ì—¬ë¶€ì™€ ìƒê´€ì—†ì´, í„´ì˜ ëì—ëŠ” í•­ìƒ í•¸ë“œë¥¼ ì •ë¦¬í•´ì•¼ í†µê³„(Wasted Cards, Hand Value)ê°€ ì •í™•í•¨.
    const finalLimit = this.getCurrentHandLimit();
    while (ai.getHandCount() > finalLimit) { 
        this.aiSmartDiscard(ai); 
    }
};

// 7. [ìì› ìˆ˜ì§‘] (Fixed: Celt & Nord Logic)
Game.prototype.aiActionGather = function(plan) {
    const ai = this.cp;
    
    if (plan.needBless) {
        let blessIdx = this.fieldBless.findIndex(c => c.type === plan.art.type);
        const realCeltCount = ai.artifacts.filter(a => a.type === 'celt').length;
        
        if (blessIdx === -1 && realCeltCount >= BALANCE_CONFIG.CELT.LVL_CONVERT) {
            blessIdx = this.fieldBless.findIndex(c => true); 
        }

        if (blessIdx !== -1) {
            ai.hand.push(this.fieldBless[blessIdx]);
            this.fieldBless.splice(blessIdx, 1);
            this.fill('blessing', 4);
            this.consumeTime(this.getCost('BLESS'));
        } else {
            const grailIdx = ai.hand.findIndex(c => c.cat === 'loki' && c.extra.type === 'active_reset_bless');
            if (grailIdx !== -1) {
                this.fieldBless.forEach(c => this.deckBless.discard(c));
                this.fieldBless = []; this.fill('blessing', 4);
                const card = ai.hand[grailIdx];
                ai.hand.splice(grailIdx, 1);
                ai.recordLokiUse(card); 
                return;
            }
            const c = this.deckBless.draw();
            if(c) ai.hand.push(c);
            this.consumeTime(this.getCost('BLESS'));
        }
        return;
    }

    if (this.getArtLevel('nord') > 0 && this.aiTryNordAction(plan.art)) return;

    let neededTypes = [];
    let myRes = {}; 
    ai.hand.forEach(c => { if(c.cat==='resource') myRes[c.type] = (myRes[c.type]||0)+c.val; });
    for(const [t, req] of Object.entries(plan.art.cost)) { if(myRes[t] < req) neededTypes.push(t); }

    let targetIdx = -1;
    for(let i=0; i<this.fieldRes.length; i++) {
        if (neededTypes.includes(this.fieldRes[i].type) && this.fieldRes[i].val >= 3) { targetIdx = i; break; }
    }
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) {
            if (neededTypes.includes(this.fieldRes[i].type)) { targetIdx = i; break; }
        }
    }
    if(targetIdx === -1) {
        for(let i=0; i<this.fieldRes.length; i++) { if (this.fieldRes[i].val >= 6) { targetIdx = i; break; } }
    }

    if (targetIdx !== -1) {
        const card = this.fieldRes[targetIdx];
        ai.hand.push(card);
        ai.metrics.resAcquired += card.val; 
        this.fieldRes.splice(targetIdx, 1);
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES'));
    } else {
        const c = this.deckRes.draw();
        if(c) {
            ai.hand.push(c);
            ai.metrics.resAcquired += c.val; 
        }
        this.consumeTime(this.getCost('RES'));
    }
};

// 8. [ë…¸ë¥´ë“œ íŠ¹ìˆ˜ ì•¡ì…˜] (Fixed: Multi-Gather Logic Restored)
// [Part 3] AI Logic Update: Nord "Perfect Value" (v12.0)
// - 3ì¥ ë³´ë„ˆìŠ¤ ë¡œì§ (ì ìˆ˜í™”) ì ìš©
// - íš¨ìœ¨ì„± ì»¤íŠ¸ë¼ì¸ (ìƒëŒ€ í‰ê°€) ì ìš©
// - í•„ìš” ìì› ìš°ì„ ê¶Œ (ê°€ì¤‘ì¹˜ ë¹„êµ) ì ìš©

Game.prototype.aiTryNordAction = function(targetArt) {
    const ai = this.cp;
    const nordLv = this.getArtLevel('nord'); 
    if (nordLv <= 0) return false; 

    // í•¸ë“œ ì œí•œ ëŒíŒŒ (ì „ëµì  ê³¼ë¶€í•˜ í—ˆìš©)
    const handLimit = this.getCurrentHandLimit(); 
    if (ai.getHandCount() >= handLimit + 2) return false;

    const statIdx = Math.min(Math.max(0, nordLv - 1), 2); 
    const limitSum = BALANCE_CONFIG.NORD.LIMIT_SUM[statIdx];
    const maxCount = BALANCE_CONFIG.NORD.LIMIT_COUNT[statIdx]; 

    // 0. [ë¹„êµ ê¸°ì¤€ ë§ˆë ¨] ì¼ë°˜ ìˆ˜ì§‘(1ì¥)ìœ¼ë¡œ ì–»ì„ ìˆ˜ ìˆëŠ” 'ìµœê³  ì ìˆ˜' ê³„ì‚°
    // ë‹¨ìˆœíˆ ìˆ«ì(val)ë§Œ ë³´ëŠ”ê²Œ ì•„ë‹ˆë¼, 'í•„ìš”í•¨(+5)'ê¹Œì§€ ê³ ë ¤í•œ ì‹¤ì§ˆ ê°€ì¹˜ë¥¼ êµ¬í•¨.
    let maxSingleScore = 0;
    this.fieldRes.forEach(c => { 
        let s = c.val;
        if (targetArt.cost[c.type] > 0) s += 5; // í•„ìš”í•œ ìì›ì€ í„´ ê°€ì¹˜(+5) ì¶”ê°€
        if (s > maxSingleScore) maxSingleScore = s;
    });

    let indices = this.fieldRes.map((_, i) => i);
    let bestCombo = null;
    let bestScore = -999;

    const evaluateCombo = (comboIndices) => {
        let sumVal = 0;
        let containsNeeded = false;
        let neededCount = 0;

        comboIndices.forEach(idx => {
            const c = this.fieldRes[idx];
            sumVal += c.val;
            
            if (targetArt.cost[c.type] > 0) { 
                containsNeeded = true; 
                neededCount++; 
            }
        });

        // 1. ë¬¼ë¦¬ì  í•œê³„ ì²´í¬
        if (sumVal > limitSum) return -999;

        // 2. ì ìˆ˜ ê³„ì‚° (ì‚¬ìš©ì ìš”ì²­ 1ë²ˆ: ë³´ë„ˆìŠ¤ ë¡œì§)
        let score = sumVal;
        // í•„ìš”í•œ ìì› 1ê°œë‹¹ +5ì  (í„´ ì ˆì•½ ê°€ì¹˜)
        if (containsNeeded) score += (neededCount * 5); 

        // 3. [ìƒëŒ€ í‰ê°€] (ì‚¬ìš©ì ìš”ì²­ 2ë²ˆ & 3ë²ˆ í†µí•© í•´ê²°)
        // ë‚´ ì½¤ë³´ ì ìˆ˜ê°€ 'ì¼ë°˜ ìˆ˜ì§‘ ìµœê³  ì ìˆ˜(maxSingleScore)'ë³´ë‹¤ ë†’ì§€ ì•Šë‹¤ë©´
        // êµ³ì´ í•¸ë“œë¥¼ ì—¬ëŸ¬ ì¹¸ ì“°ë©´ì„œ ê°€ì ¸ì˜¬ ì´ìœ ê°€ ì—†ë‹¤.
        // ì˜ˆ: [3,3](6ì ) vs [5+í•„ìš”](10ì ) -> 10ì ì´ ë†’ìœ¼ë‹ˆ ì½¤ë³´ í¬ê¸°(-999)
        // ì˜ˆ: [2,2+í•„ìš”](4+5=9ì ) vs [7](7ì ) -> 9ì ì´ ë†’ìœ¼ë‹ˆ ì½¤ë³´ ì„ íƒ(O)
        if (score <= maxSingleScore) return -999;

        return score;
    };

    // 2ì¥ íƒìƒ‰
    if (maxCount >= 2) {
        for (let i = 0; i < indices.length; i++) {
            for (let j = i + 1; j < indices.length; j++) {
                const combo = [i, j];
                const score = evaluateCombo(combo);
                if (score > bestScore) { bestScore = score; bestCombo = combo; }
            }
        }
    }

    // 3ì¥ íƒìƒ‰
    if (maxCount >= 3) {
        for (let i = 0; i < indices.length; i++) {
            for (let j = i + 1; j < indices.length; j++) {
                for (let k = j + 1; k < indices.length; k++) {
                    const combo = [i, j, k];
                    const score = evaluateCombo(combo);
                    // 3ì¥ ìˆ˜ì§‘ì€ í•¸ë“œ ì••ë°•ì´ ìˆìœ¼ë¯€ë¡œ +3ì ì˜ ì¶”ê°€ ì´ë“ì´ ìˆì–´ì•¼ í•¨
                    if (score > bestScore + 3) { bestScore = score; bestCombo = combo; }
                }
            }
        }
    }

    if (bestCombo && bestScore > 0) {
        bestCombo.sort((a, b) => b - a); 
        bestCombo.forEach(idx => {
            const card = this.fieldRes[idx];
            ai.hand.push(card);
            ai.metrics.resAcquired += card.val;
            this.fieldRes.splice(idx, 1);
        });
        
        this.fill('resource', 6);
        this.consumeTime(this.getCost('RES')); 
        return true;
    }

    return false;
};

// [Part 3] AI Logic Update: Smart Discard v12.2 (Loki Exclusion Fix)
// ë¡œí‚¤ ì¹´ë“œëŠ” í•¸ë“œ ì œí•œ(Hand Limit)ì— í¬í•¨ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ë²„ë¦¬ê¸° ëŒ€ìƒì—ì„œ ì œì™¸í•¨.

Game.prototype.aiSmartDiscard = function(ai) {
    const bestPlan = this.aiFindBestPlan();
    const targetArt = bestPlan ? bestPlan.art : null;
    
    let myRes = {}; 
    ai.hand.forEach(c => { 
        if(c.cat==='resource') myRes[c.type] = (myRes[c.type]||0)+c.val; 
    });

    let myBlessings = {};
    ai.hand.forEach(c => {
        if(c.cat === 'blessing') myBlessings[c.type] = (myBlessings[c.type]||0) + 1;
    });

    let worstIdx = -1; 
    let minScore = 99999;

    ai.hand.forEach((c, i) => {
        // â˜… í•µì‹¬ ìˆ˜ì •: ë¡œí‚¤ ì¹´ë“œëŠ” í•¸ë“œ ì œí•œì— ì˜í–¥ì´ ì—†ìœ¼ë¯€ë¡œ ë²„ë¦¬ê¸° í›„ë³´ì—ì„œ ì œì™¸
        if (c.cat === 'loki') return; 

        let score = 0;

        if (c.cat === 'resource') {
            score = c.val; // ê¸°ë³¸ ì ìˆ˜
            
            if (targetArt && targetArt.cost[c.type] > 0) {
                // Critical Check: ì´ ì¹´ë“œë¥¼ ëºì„ ë•Œ ëª©í‘œ ë‹¬ì„±ì´ ë¶ˆê°€ëŠ¥í•´ì§€ë©´ ë³´í˜¸
                let currentTotal = myRes[c.type] || 0;
                let needed = targetArt.cost[c.type];
                
                if ((currentTotal - c.val) < needed) {
                    score += 50; // ì ˆëŒ€ ë³´í˜¸
                }
            }
            // ê³ ê°€ì¹˜ ìì› ë³´í˜¸ (6,7)
            if (c.val >= 6) score += 10;
        } 
        else if (c.cat === 'blessing') {
            score = 5; 
            if (targetArt && c.type === targetArt.type) {
                // ì¤‘ë³µ ì¶•ë³µ ì²˜ë¦¬
                if (myBlessings[c.type] > 1) {
                    myBlessings[c.type]--; 
                } else {
                    score += 50; // ë§ˆì§€ë§‰ 1ì¥ì€ ë³´í˜¸
                }
            }
        } 

        if (score < minScore) {
            minScore = score;
            worstIdx = i;
        }
    });

    if (worstIdx !== -1) {
        const c = ai.hand[worstIdx];
        ai.hand.splice(worstIdx, 1);
        if (c.cat === 'resource') this.deckRes.discard(c);
        else if (c.cat === 'blessing') this.deckBless.discard(c);
        // ë¡œí‚¤ discard ë¡œì§ ì‚­ì œ (ë²„ë ¤ì§€ì§€ ì•Šìœ¼ë¯€ë¡œ)
        
        ai.metrics.wastedCards++;
    }
};

Game.prototype.aiEmergencyAction = function() {
    const c = this.deckRes.draw();
    if(c) this.cp.hand.push(c);
    this.consumeTime(this.getCost('RES'));
};


Game.prototype.aiEmergencyAction = function() {
    const c = this.deckRes.draw();
    if(c) this.cp.hand.push(c);
    this.consumeTime(this.getCost('RES'));
};



// ==================================================================================
// [Part 4] Simulation Manager (Final v9.8: Tier Depth & Top 5 UI)
// ==================================================================================

class SimulationManager {
    constructor() {
        this.isRunning = false;
        this.stats = this.getEmptyStats();
        this.csvData = []; 
    }

    getEmptyStats() {
        return {
            totalGames: 0,
            wins: [0, 0, 0, 0, 0], 
            draws: 0,
            totalScore: 0,
            days: 0,
            
            mythStats: {
                olympus: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                egypt: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                nord: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                celt: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 },
                mix: { rankSum: 0, count: 0, t2Win: 0, t3Win: 0 }
            },

            topScores: [], 
            winnerRecords: [], 

            rankStats: {
                lokiCount: [0, 0, 0, 0], 
                artScoreAvg: [0, 0, 0, 0], 
                count: [0, 0, 0, 0]      
            },
            totalGap1vs2: 0,

            // ê²½ì œ
            totalSaved: 0, totalWasted: 0, totalSwaps: 0,
            totalResAcquired: 0, totalResConsumed: 0,
            
            // [Fix] UIê°€ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ 'í”Œë ˆì´ì–´ë³„ ë°°ì—´'ë¡œ ì´ˆê¸°í™”í•´ì•¼ í•©ë‹ˆë‹¤.
            graceCounts: [0, 0, 0, 0, 0], // Index 1~4 ì‚¬ìš©
            totalGraceScore: 0,

            mythDailyStats: {
                olympus: { sum: [0,0,0,0,0], count: 0 },
                egypt: { sum: [0,0,0,0,0], count: 0 },
                nord: { sum: [0,0,0,0,0], count: 0 },
                celt: { sum: [0,0,0,0,0], count: 0 }
            }
        };
    }

    runOneGame(mythAssignments, gameId) {
        const game = new Game();
        game.init(mythAssignments);

        let safetyCount = 0;
        while (!game.isGameEnded && safetyCount < 1000) {
            game.aiTurn();
            safetyCount++;
        }

        if (game.isGameEnded) {
            this.collectData(game, gameId);
        }
    }

    async startSimulation() {
        if (this.isRunning) return;
        applyUserBalance();
        
        // [Fix] CSV í—¤ë”ì— ì€ì´(Grace) ê´€ë ¨ ì»¬ëŸ¼ 2ê°œ ì¶”ê°€ (ëˆ„ë½ ë°©ì§€)
        if (this.csvData.length === 0) {
            this.csvData = ["GameID,Day,PlayerID,MainMyth,Rank,Score,OlympusLv,EgyptLv,NordLv,CeltLv,TotalTurns,EngineTurn,HandValue,EffRatio,UsedLoki,GraceCount,GraceScore"];
        }
        
        const countInput = document.getElementById('simCount');
        const count = parseInt(countInput.value);
        const myths = [
            document.getElementById('p1Myth').value,
            document.getElementById('p2Myth').value,
            document.getElementById('p3Myth').value,
            document.getElementById('p4Myth').value
        ];

        this.isRunning = true;
        let startGameId = this.stats.totalGames + 1;
        
        this.updateLog(`[System] ${count}íšŒ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ (v10.5 Grace Added)`);
        
        let chunkSize = 100;
        if (count >= 5000) chunkSize = 500;
        
        for (let i = 0; i < count; i += chunkSize) {
            if (!this.isRunning) break;
            const limit = Math.min(i + chunkSize, count);
            for (let j = i; j < limit; j++) { 
                this.runOneGame(myths, startGameId++); 
            }
            const progress = Math.round(((i + chunkSize) / count) * 100);
            document.getElementById('progressBar').style.width = `${progress}%`;
            await new Promise(r => setTimeout(r, 0));
        }

        this.renderStats();
        this.isRunning = false;
        document.getElementById('progressBar').style.width = `0%`;
    }

    stopSimulation() {
        this.isRunning = false;
        this.updateLog("[System] ì¤‘ì§€ë¨.");
    }

    resetStats() {
        this.stats = this.getEmptyStats();
        this.csvData = [];
        this.updateLog("[System] ì´ˆê¸°í™” ì™„ë£Œ.");
        document.getElementById('mainStats').innerHTML = "";
        document.getElementById('detailStats').innerHTML = "";
    }

    collectData(game, gameId) {
        let rankedPlayers = [...game.players];
        rankedPlayers.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score; 
            return b.artifacts.length - a.artifacts.length;    
        });

        const gap = rankedPlayers[0].score - rankedPlayers[1].score;
        this.stats.totalGap1vs2 += gap;
        
        const winner = rankedPlayers[0];
        const isDraw = rankedPlayers[1].score === winner.score && rankedPlayers[1].artifacts.length === winner.artifacts.length;

        rankedPlayers.forEach((p, index) => {
            let rank = index + 1;
            if (index > 0) {
                const prev = rankedPlayers[index - 1];
                if (p.score === prev.score && p.artifacts.length === prev.artifacts.length) {
                    rank = prev.rank;
                }
            }
            p.rank = rank;

            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            const grades = { Gold: 0, Silver: 0, Bronze: 0 };
            p.artifacts.forEach(a => { 
                if(counts[a.type] !== undefined) counts[a.type]++; 
                if(grades[a.grade] !== undefined) grades[a.grade]++;
            });
            
            // [Modified] ë©”ì¸ ì‹ í™” íŒë³„ ë¡œì§ ìˆ˜ì • (Prioritize First Tier 3)
            let mainMyth = 'mix';
            
            // 1. ë§ˆì¼ìŠ¤í†¤(3ë‹¨ê³„ ë‹¬ì„± ê¸°ë¡)ì´ ìˆëŠ”ì§€ í™•ì¸
            const achievedMilestones = Object.keys(p.milestones);
            
            if (achievedMilestones.length > 0) {
                // 3ë‹¨ê³„ ë‹¬ì„± ìˆœì„œ(craftOrder)ê°€ ê°€ì¥ ë¹ ë¥¸ ê²ƒì„ ë©”ì¸ ì‹ í™”ë¡œ ì„ ì •
                achievedMilestones.sort((a, b) => p.milestones[a] - p.milestones[b]);
                mainMyth = achievedMilestones[0];
            } else {
                // 2. 3ë‹¨ê³„ ë„ë‹¬ ëª»í•¨: ë‹¨ìˆœíˆ ê°€ì¥ ë§ì€ ìœ ë¬¼ì„ ê°€ì§„ ì‹ í™” ì„ ì •
                let maxVal = 0;
                for(const c of Object.values(counts)) { if (c > maxVal) maxVal = c; }
                const candidates = Object.keys(counts).filter(m => counts[m] === maxVal);
                
                if (candidates.length === 1) mainMyth = candidates[0];
                else mainMyth = 'mix';
            }

            this.updateTopScores(p, mainMyth, counts, grades);

            if (this.stats.mythStats[mainMyth]) {
                this.stats.mythStats[mainMyth].rankSum += rank;
                this.stats.mythStats[mainMyth].count++;
            }

            if (index < 4) {
                this.stats.rankStats.lokiCount[index] += p.metrics.lokiUsed;
                const artCount = p.artifacts.length;
                let avgScore = 0;
                if (artCount > 0) {
                    const artScoreSum = p.artifacts.reduce((sum, a) => sum + a.score, 0); 
                    avgScore = artScoreSum / artCount;
                }
                this.stats.rankStats.artScoreAvg[index] += avgScore;
                this.stats.rankStats.count[index]++;
            }

            if (mainMyth !== 'mix' && this.stats.mythDailyStats[mainMyth]) {
                this.stats.mythDailyStats[mainMyth].count++;
                let filledDaily = [...p.dailyScore];
                for(let d=0; d<5; d++) {
                    if (filledDaily[d] === -1) {
                        if (d === 0) filledDaily[d] = p.score; 
                        else filledDaily[d] = filledDaily[d-1];
                    }
                    this.stats.mythDailyStats[mainMyth].sum[d] += filledDaily[d];
                }
            }

            this.stats.totalSaved += p.metrics.savedRes;
            this.stats.totalWasted += p.metrics.wastedCards;
            this.stats.totalSwaps += p.metrics.celtSwaps;
            this.stats.totalResAcquired += p.metrics.resAcquired;
            this.stats.totalResConsumed += p.metrics.resConsumed;
            
            if (this.stats.graceCounts[p.id] !== undefined) {
                this.stats.graceCounts[p.id] += p.metrics.graceCount;
            }
            this.stats.totalGraceScore += p.metrics.graceScore;

            const engineTurn = (mainMyth !== 'mix') ? p.lvl3Turn[mainMyth] : -1;
            let handValue = 0; p.hand.forEach(c => { if(c.cat === 'resource') handValue += c.val; });
            const effRatio = p.metrics.resAcquired > 0 ? (p.metrics.resConsumed / p.metrics.resAcquired).toFixed(3) : 0;
            const lokiStr = p.usedLokiIds.length > 0 ? p.usedLokiIds.join('|') : "None";
            const h = p.history[p.history.length - 1]; 
            
            if (h) {
                 this.csvData.push(`${gameId},${h.day},P${p.id},${mainMyth},${p.rank},${h.score},${h.olympus},${h.egypt},${h.nord},${h.celt},${p.totalTurns},${engineTurn},${handValue},${effRatio},${lokiStr},${p.metrics.graceCount},${p.metrics.graceScore}`);
            }
        });

        this.stats.totalGames++;
        if (isDraw) this.stats.draws++;
        else {
            this.stats.wins[winner.id]++;
            
            // [Modified] ìŠ¹ì í†µê³„ ë¡œì§ë„ ë™ì¼í•˜ê²Œ ìˆ˜ì • (First Tier 3 ìš°ì„ )
            let winnerMyth = 'mix';
            const wMilestones = Object.keys(winner.milestones);
            
            if (wMilestones.length > 0) {
                wMilestones.sort((a, b) => winner.milestones[a] - winner.milestones[b]);
                winnerMyth = wMilestones[0];
            } else {
                // 3ë‹¨ê³„ ë¯¸ë‹¬ì„± ìŠ¹ë¦¬ ì‹œ (í¬ê·€ ì¼€ì´ìŠ¤) ê°œìˆ˜ ìš°ì„ 
                const wCounts = { olympus:0, egypt:0, nord:0, celt:0 };
                winner.artifacts.forEach(a => wCounts[a.type]++);
                const wMax = Math.max(...Object.values(wCounts));
                const leaders = Object.keys(wCounts).filter(k => wCounts[k] === wMax);
                if (leaders.length === 1) winnerMyth = leaders[0];
                else winnerMyth = 'mix';
            }
            
            this.stats.winnerRecords.push({ score: winner.score, myth: winnerMyth });
            
            const counts = { olympus: 0, egypt: 0, nord: 0, celt: 0 };
            winner.artifacts.forEach(a => { if(counts[a.type] !== undefined) counts[a.type]++; });
            const maxCount = Math.max(...Object.values(counts));

            if (this.stats.mythStats[winnerMyth]) {
                if (maxCount === 2) this.stats.mythStats[winnerMyth].t2Win++;
                else if (maxCount >= 3) this.stats.mythStats[winnerMyth].t3Win++;
            }
        }

        this.stats.days += game.day;
        let gameTotalScore = 0;
        game.players.forEach(p => gameTotalScore += p.score);
        this.stats.totalScore += (gameTotalScore / 4);
    }

    updateTopScores(p, myth, counts, grades) {
        // ë°ì´í„° ê°ì²´ ìƒì„±
        const record = {
            score: p.score,
            myth: myth,
            counts: counts, // {olympus: 2, egypt: 1 ...}
            grades: grades  // {Gold: 1, Silver: 2 ...}
        };

        // Top 5 ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
        this.stats.topScores.push(record);
        this.stats.topScores.sort((a, b) => b.score - a.score);
        if (this.stats.topScores.length > 5) {
            this.stats.topScores = this.stats.topScores.slice(0, 5);
        }
    }

    updateLog(msg) {
        const log = document.getElementById('simLog');
        if(log) log.innerText = msg + "\n" + log.innerText;
    }
    
    downloadRawData() {
        if (this.csvData.length <= 1) { alert("ë°ì´í„° ì—†ìŒ"); return; }
        const csvContent = this.csvData.join("\n");
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `divine_forge_v9_8.csv`;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    
}
/*
 * [v10.2 Update Log: Logic & UI Sync]
 *
 * 1. ë°¸ëŸ°ìŠ¤ ì‚°ì¶œ ê³µì‹(Power Score) ë¦¬ë°¸ëŸ°ì‹±
 * - ë¬¸ì œì  ìˆ˜ì •: ê¸°ì¡´ ë¡œì§ì—ì„œ 'ì•ˆì •ì  2ìœ„ ì „ëµ(ìˆœìœ„ ë°©ì–´)'ì´ ì§€ë‚˜ì¹˜ê²Œ ì €í‰ê°€ë˜ëŠ” í˜„ìƒ ë³´ì •.
 * - ë³€ê²½ ì‚¬í•­:
 * a) ìŠ¹ë¥  ê°€ì¤‘ì¹˜ ì¡°ì • (2.0 -> 1.5): ìŠ¹ë¦¬ ì¤‘ìš”ë„ ìœ ì§€í•˜ë˜, ë…ì  ê°€ì¤‘ì¹˜ ì†Œí­ í•˜í–¥.
 * b) ìˆœìœ„ ê°€ì¤‘ì¹˜ ìƒí–¥ (12 -> 20): í‰ê·  ìˆœìœ„ 2.0 ë‹¬ì„± ì‹œ ìœ ì˜ë¯¸í•œ ì ìˆ˜(40ì ) í™•ë³´í•˜ë„ë¡ ë³€ê²½.
 * c) ë…¸ì´ì¦ˆ í•„í„°ë§: ì‹œë®¬ë ˆì´ì…˜ 1,000íšŒ ë¯¸ë§Œ ì‹œ Elite(ê³ ì ) ê°€ì¤‘ì¹˜ 0.5ë°° ì ìš© (ë°ì´í„° ì™œê³¡ ë°©ì§€).
 *
 * 2. UI/ê°€ì´ë“œ í…ìŠ¤íŠ¸ ë™ê¸°í™”
 * - ì ìˆ˜ ìŠ¤ì¼€ì¼ í™•ì¥(Max ~130ì )ì— ë§ì¶° ë°¸ëŸ°ìŠ¤ ë¶•ê´´(Gap) íŒë… ê¸°ì¤€ ì¬ì„¤ì • (20/40).
 * - ì‚¬ìš©ì ê°€ì´ë“œ(<details>) ë‚´ ê³µì‹ ì„¤ëª…ì„ v10.2 ë¡œì§ìœ¼ë¡œ ê°±ì‹ .
 */
// [SimulationManager.prototype.renderStats ìµœì¢… í™•ì •ë³¸ (v11.3: Robust Standard)]

SimulationManager.prototype.renderStats = function() {
        const total = this.stats.totalGames;
        if (total === 0) return;

        const p = 0.25; 
        const stdError = Math.sqrt((p * (1 - p)) / total);

        let eliteCounts = { olympus:0, egypt:0, nord:0, celt:0, mix:0 };
        if (this.stats.winnerRecords.length > 0) {
            this.stats.winnerRecords.sort((a, b) => b.score - a.score);
            const cutoffIndex = Math.floor(this.stats.winnerRecords.length * 0.05);
            const eliteSlice = this.stats.winnerRecords.slice(0, Math.max(1, cutoffIndex));
            eliteSlice.forEach(r => { 
                if(eliteCounts[r.myth] !== undefined) eliteCounts[r.myth]++; 
                else eliteCounts.mix++; 
            });
        }
        const getElitePct = (myth) => this.stats.winnerRecords.length > 0 ? ((eliteCounts[myth] / Math.max(1, Math.floor(this.stats.winnerRecords.length * 0.05))) * 100).toFixed(1) : '0.0';

        const mythList = ['olympus', 'egypt', 'nord', 'celt', 'mix'];
        const mythMeta = mythList.map(key => {
            const data = this.stats.mythStats[key];
            const avgRank = data.count > 0 ? (data.rankSum / data.count).toFixed(2) : '4.00';
            const winRateVal = total > 0 ? (data.t2Win + data.t3Win) / total : 0;
            const winRatePct = (winRateVal * 100).toFixed(1);
            const zScore = (winRateVal - p) / stdError;
            const sigmaStr = (zScore > 0 ? "+" : "") + zScore.toFixed(2) + "Ïƒ";
            let tierColor = '#7f8c8d'; 
            let tierLabel = 'Balanced';
            if (zScore >= 5.0) { tierColor = '#e74c3c'; tierLabel = 'OP (Tier 0)'; }
            else if (zScore >= 3.0) { tierColor = '#e67e22'; tierLabel = 'Strong (Tier 1)'; }
            else if (zScore <= -5.0) { tierColor = '#2c3e50'; tierLabel = 'Under (Tier 4)'; }
            else if (zScore <= -3.0) { tierColor = '#34495e'; tierLabel = 'Weak (Tier 3)'; }
            const eliteWinRate = parseFloat(getElitePct(key));
            let baseScore = (winRateVal / 0.25) * 75;
            let rankScore = (4 - parseFloat(avgRank)) * 25;
            const eliteWeight = total >= 1000 ? 0.25 : 0.125;
            let eliteBonus = eliteWinRate * eliteWeight;
            let finalScore = baseScore + rankScore + eliteBonus;
            const powerScore = finalScore.toFixed(0);
            return {
                id: key, name: {olympus:'ì˜¬ë¦¼í¬ìŠ¤', egypt:'ì´ì§‘íŠ¸', nord:'ë…¸ë¥´ë“œ', celt:'ì¼ˆíŠ¸', mix:'í˜¼í•©'}[key],
                color: {olympus:'var(--c-olympus)', egypt:'var(--c-egypt)', nord:'var(--c-nord)', celt:'var(--c-celt)', mix:'#95a5a6'}[key],
                avgRank, winRatePct, eliteWinRate, powerScore, sigmaStr, tierColor, tierLabel, zScore,
                t2Rate: total > 0 ? ((data.t2Win/total)*100).toFixed(1) : '0.0',
                t3Rate: total > 0 ? ((data.t3Win/total)*100).toFixed(1) : '0.0', count: data.count
            };
        });
        mythMeta.sort((a, b) => parseFloat(b.powerScore) - parseFloat(a.powerScore));
        
        const drawBar = (val, max, color) => `<div style="flex:1; height:6px; background:#333; border-radius:3px; overflow:hidden; margin:0 5px;"><div style="width:${Math.min(100, (val/max)*100)}%; height:100%; background:${color};"></div></div>`;
        const pct = (val) => ((val / total) * 100).toFixed(1);
        const effVal = this.stats.totalResAcquired > 0 ? ((this.stats.totalResConsumed / this.stats.totalResAcquired) * 100).toFixed(1) : 0;
        const effColor = effVal > 85 ? '#2ecc71' : (effVal > 70 ? '#f1c40f' : '#e74c3c');
        const avgGap = (this.stats.totalGap1vs2 / total).toFixed(1);

        let mythRows = '';
        mythMeta.forEach(m => {
            const isFocus = Math.abs(m.zScore) >= 3.0 ? `border: 1px solid ${m.color}; background: rgba(255,255,255,0.05);` : `border-bottom: 1px solid #333;`;
            mythRows += `
                <div style="display:grid; grid-template-columns: 1.5fr 1fr 1.2fr 1fr 0.8fr; padding:10px 8px; align-items:center; ${isFocus} border-radius:4px; margin-bottom:6px;">
                    <div style="color:${m.color}; font-weight:bold; display:flex; flex-direction:column;">
                        <span style="font-size:14px;">${m.name}</span><span style="font-size:10px; color:${m.tierColor}; opacity:0.9;">${m.tierLabel}</span>
                    </div>
                    <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
                        <div style="font-weight:bold; color:#ecf0f1; font-size:13px;">${m.winRatePct}%</div>
                        <div style="font-size:10px; color:${m.tierColor}; font-weight:bold;">${m.sigmaStr}</div>
                        <div style="font-size:9px; color:#888; margin-top:2px;">${m.t2Rate}% / ${m.t3Rate}%</div>
                    </div>
                    <div style="display:flex; flex-direction:column; justify-content:center; padding:0 5px;">
                        <div style="display:flex; align-items:center; font-size:11px; color:#aaa;"><span>Rk</span>${drawBar(4 - parseFloat(m.avgRank), 3, m.color)}<span style="color:#fff;">${m.avgRank}</span></div>
                    </div>
                    <div style="text-align:center; font-size:12px;"><div title="Elite Win Rate" style="color:#f1c40f;">${m.eliteWinRate}%</div><div style="font-size:9px; color:#666;">Top 5%</div></div>
                    <div style="text-align:center;"><div style="font-size:15px; font-weight:bold; color:#fff;">${m.powerScore}</div><div style="font-size:9px; color:#666;">Score</div></div>
                </div>`;
        });

        let dailyRows = '';
        mythMeta.forEach(meta => {
            if (meta.id === 'mix') return;
            const dData = this.stats.mythDailyStats[meta.id];
            let tds = '';
            if (dData && dData.count > 0) {
                for(let d=0; d<5; d++) {
                    const avg = (dData.sum[d] / dData.count).toFixed(1);
                    const prev = d > 0 ? (dData.sum[d-1] / dData.count) : 0;
                    const diff = (avg - prev).toFixed(1);
                    const diffStr = d > 0 ? `<span style="font-size:9px; color:${diff > 20 ? '#e74c3c' : '#7f8c8d'}; margin-left:2px;">(+${diff})</span>` : '';
                    tds += `<td><span style="font-weight:bold; color:#ecf0f1;">${avg}</span>${diffStr}</td>`;
                }
            } else { tds = `<td colspan="5" style="color:#555; font-size:11px;">ë°ì´í„° ë¶€ì¡± (í‘œë³¸ ê³¼ì†Œ)</td>`; }
            dailyRows += `<tr style="border-bottom:1px solid #333;"><td style="text-align:left; padding:8px; font-weight:bold; color:${meta.color}; border-right:1px solid #333;">${meta.name} <span style="font-size:9px; color:#666;">(#${4 - parseFloat(meta.avgRank) + 1}ìœ„)</span></td>${tds}</tr>`;
        });
        const dailyTableHTML = `<div class="panel full-width"><div class="panel-header" style="color:#e67e22;">ğŸ“… ì‹ í™”ë³„ ì„±ì¥ ê³¡ì„  (ì¼ì¼ í‰ê·  ì ìˆ˜)</div><table class="mini-table" style="text-align:center; font-size:12px; width:100%; border-collapse:collapse;"><thead><tr style="background:#252525; color:#aaa; font-size:11px;"><th style="text-align:left; padding:8px;">Main Myth</th><th style="padding:6px;">Day 1</th><th style="padding:6px;">Day 2</th><th style="padding:6px;">Day 3</th><th style="padding:6px;">Day 4</th><th style="padding:6px;">Day 5 (Final)</th></tr></thead><tbody>${dailyRows}</tbody></table></div>`;

        let top5HTML = `<table class="mini-table" style="text-align:center; font-size:11px;"><thead><tr><th>#</th><th>ì ìˆ˜</th><th>ì£¼ë ¥</th><th>ë± êµ¬ì„±</th><th>ë“±ê¸‰</th></tr></thead><tbody>`;
        const kNames = {olympus:'ì˜¬ë¦¼', egypt:'ì´ì§‘', nord:'ë…¸ë¥´', celt:'ì¼ˆíŠ¸', mix:'í˜¼í•©'};
        this.stats.topScores.forEach((rec, i) => {
             const mColor = {olympus:'var(--c-olympus)', egypt:'var(--c-egypt)', nord:'var(--c-nord)', celt:'var(--c-celt)', mix:'#aaa'}[rec.myth];
             let deckStr = []; for(const [key, val] of Object.entries(rec.counts)) { if(val > 0) deckStr.push(`${kNames[key]||key} ${val}`); }
             let gradeStr = [];
             if(rec.grades.Gold > 0) gradeStr.push(`<span style="color:#f1c40f">ğŸ¥‡${rec.grades.Gold}</span>`);
             if(rec.grades.Silver > 0) gradeStr.push(`<span style="color:#bdc3c7">ğŸ¥ˆ${rec.grades.Silver}</span>`);
             if(rec.grades.Bronze > 0) gradeStr.push(`<span style="color:#cd7f32">ğŸ¥‰${rec.grades.Bronze}</span>`);
             top5HTML += `<tr><td>${i+1}</td><td style="color:#e67e22; font-weight:bold;">${rec.score}</td><td style="color:${mColor}; font-weight:bold;">${kNames[rec.myth]||rec.myth}</td><td style="color:#ddd;">${deckStr.join(', ')}</td><td>${gradeStr.length>0?gradeStr.join(' '):'-'}</td></tr>`;
        });
        top5HTML += `</tbody></table>`;

        const html = `
            <div style="margin-bottom: 15px; display:flex; justify-content:space-between; align-items:end;">
                <div><h2 style="margin:0; font-size:20px;">ğŸ“Š ë°¸ëŸ°ìŠ¤ ë¶„ì„ (N=${total})</h2></div>
                <button onclick="simManager.downloadRawData()" class="btn-primary" style="padding:4px 8px; font-size:11px;">ğŸ“¥ Raw CSV</button>
            </div>

            <details style="background:#2c3e50; border:1px solid #34495e; border-radius:4px; padding:8px; margin-bottom:15px; cursor:pointer;">
                 <summary style="font-weight:bold; color:#f1c40f; outline:none;">â“ ì€ì´(Grace) ë° ë°¸ëŸ°ìŠ¤ ì ìˆ˜ ì„¤ëª… (í´ë¦­)</summary>
                 <div style="margin-top:10px; font-size:12px; color:#ecf0f1; line-height:1.6; border-top:1px dashed #555; padding-top:8px;">
                    <div style="margin-bottom:8px;">
                        <b style="color:#e74c3c;">âœ¨ ì€ì´(Grace) ì‹œìŠ¤í…œ:</b><br>
                        ìœ ë¬¼ ì œì‘ ì‹œ ìì›ì„ <span style="color:#f1c40f;">ì •í™•íˆ(Exact Match)</span> ì§€ë¶ˆí•˜ë©´ ì¶”ê°€ ì ìˆ˜ íšë“.<br>
                        (ë“±ê¸‰ë³„ ë³´ë„ˆìŠ¤: Bronze +2 / Silver +3 / Gold +4)
                    </div>
                    <div style="border-top:1px dashed #555; padding-top:6px;">
                        <b style="color:#3498db;">âš–ï¸ í‹°ì–´(Tier) ë° Score ê¸°ì¤€ (í‘œì¤€í¸ì°¨ Ïƒ):</b><br>
                        - <span style="color:#e74c3c; font-weight:bold;">Tier 0 (OP)</span>: +5.0Ïƒ ì´ìƒ (ë°¸ëŸ°ìŠ¤ ë¶•ê´´ ìˆ˜ì¤€ì˜ ê°•ë ¥í•¨)<br>
                        - <span style="color:#e67e22; font-weight:bold;">Tier 1 (Strong)</span>: +3.0Ïƒ ì´ìƒ (í™•ì‹¤í•œ ìš°ìœ„)<br>
                        - <span style="color:#7f8c8d; font-weight:bold;">Balanced</span>: Â±3.0Ïƒ ì´ë‚´ (í†µê³„ì  ì˜¤ì°¨ ë²”ìœ„ ë‚´ ì •ìƒ)<br>
                        - <span style="color:#2c3e50; font-weight:bold;">Under/Weak</span>: -3.0Ïƒ ì´í•˜ (ìƒí–¥ ì¡°ì • í•„ìš”)<br>
                        <span style="color:#aaa; font-size:11px;">* <b>Power Score</b>: (ìŠ¹ë¥  / 25% Ã— 75) + (ìˆœìœ„ì ìˆ˜ Ã— 25) +  [ìƒìœ„ 5% ìŠ¹ë¥  x ê°€ì¤‘ì¹˜]ì„ ì¢…í•©í•œ ì „íˆ¬ë ¥ ì§€í‘œì…ë‹ˆë‹¤. ê°€ì¤‘ì¹˜:  (1,000íšŒ ì´ìƒ): 0.25(25% ë°˜ì˜)ë°ì´í„° ë¶€ì¡± (1,000íšŒ ë¯¸ë§Œ): 0.125 (12.5% ë°˜ì˜)</span>
                    </div>
                 </div>
            </details>

            <div class="dashboard-grid">
                <div class="panel full-width">
                    <div class="panel-header" style="color:#3498db;">âš¡ ì‹ í™”ë³„ ì„±ëŠ¥ ë¶„ì„ (Ratio v2)</div>
                     <div style="display:grid; grid-template-columns: 1.5fr 1fr 1.2fr 1fr 0.8fr; padding:0 8px 5px; font-size:10px; color:#666; border-bottom:1px solid #333;">
                        <div>ì‹ í™” (Tier)</div><div>ìŠ¹ë¥  (Ïƒ / Depth)</div><div>í‰ê·  ìˆœìœ„</div><div>ê³ ì (Elite)</div><div>Score</div>
                    </div>
                    ${mythRows}
                </div>
                ${dailyTableHTML}
                <div class="panel full-width" style="background:#222;">
                     <div class="panel-header" style="color:#f39c12;">ğŸ† Top 5 ê³ ë“ì  ë± ë¶„ì„</div>
                     ${top5HTML}
                </div>
                <div class="panel half-width">
                    <div class="panel-header">ğŸ“ˆ í”Œë ˆì´ì–´ ìŠ¹ë¥ </div>
                    ${['#e74c3c', '#3498db', '#2ecc71', '#f1c40f'].map((c, i) => `<div class="stat-row"><span class="stat-label">P${i+1}</span><div class="bar-wrapper"><div class="bar-fill" style="width:${pct(this.stats.wins[i+1])}%; background:${c};"></div></div><span class="stat-value" style="width:40px;">${pct(this.stats.wins[i+1])}%</span></div>`).join('')}
                    <div class="stat-row" style="margin-top:5px;"><span class="stat-label">Draw</span><span class="stat-value">${pct(this.stats.draws)}%</span></div>
                </div>
                <div class="panel half-width">
                    <div class="panel-header">ğŸ’° ê²½ì œ ë° ì€ì´ í†µê³„</div>
                    <div style="text-align:center; margin-bottom:10px;">
                        <div style="font-size:11px; color:#aaa;">ìì› ì†Œëª¨ íš¨ìœ¨</div>
                        <div style="font-size:24px; font-weight:bold; color:${effColor};">${effVal}%</div>
                    </div>
                    <div style="border-top:1px dashed #444; padding-top:5px; margin-top:5px;">
                        <div style="font-size:11px; color:#e74c3c; font-weight:bold; margin-bottom:4px;">âœ¨ í”Œë ˆì´ì–´ë³„ í‰ê·  ì€ì´ íšë“</div>
                        ${['#e74c3c', '#3498db', '#2ecc71', '#f1c40f'].map((c, i) => {
                            const pGrace = (this.stats.graceCounts[i+1] / total).toFixed(1);
                            return `<div class="stat-row"><span class="stat-label" style="color:${c};">P${i+1}</span><span class="stat-value">${pGrace}íšŒ</span></div>`;
                        }).join('')}
                    </div>
                    <div class="stat-row" style="margin-top:8px;"><span class="stat-label">í‰ê·  ê²Œì„ ê¸¸ì´</span><span class="stat-value">${(this.stats.days / total).toFixed(1)} ì¼</span></div>
                    <div class="stat-row"><span class="stat-label">ì „ì²´ í‰ê·  ì ìˆ˜</span><span class="stat-value">${(this.stats.totalScore / total).toFixed(1)} ì </span></div>
                    <div class="stat-row"><span class="stat-label">1-2ìœ„ í‰ê·  ê²©ì°¨</span><span class="stat-value">${avgGap} ì </span></div>
                </div>
                <div class="panel full-width">
                    <div class="panel-header">ğŸ› ï¸ íŠ¹ìˆ˜ ëŠ¥ë ¥ í™œìš© (í‰ê· )</div>
                    <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; text-align:center;">
                        <div><div style="color:var(--c-olympus); font-weight:bold;">ì˜¬ë¦¼í¬ìŠ¤</div><div style="font-size:16px;">${(this.stats.totalSaved / total).toFixed(1)}</div><div style="font-size:10px; color:#aaa;">ìì› ì ˆì•½</div></div>
                        <div><div style="color:var(--c-egypt); font-weight:bold;">ì´ì§‘íŠ¸</div><div style="font-size:16px;">-</div><div style="font-size:10px; color:#aaa;">(íŒ¨ì‹œë¸Œ)</div></div>
                        <div><div style="color:var(--c-nord); font-weight:bold;">ë…¸ë¥´ë“œ</div><div style="font-size:16px;">${(this.stats.totalWasted / total).toFixed(1)}</div><div style="font-size:10px; color:#aaa;">ë²„ë ¤ì§„ ì¹´ë“œ</div></div>
                        <div><div style="color:var(--c-celt); font-weight:bold;">ì¼ˆíŠ¸</div><div style="font-size:16px;">${(this.stats.totalSwaps / total).toFixed(1)}</div><div style="font-size:10px; color:#aaa;">ë³€í™˜ íšŸìˆ˜</div></div>
                    </div>
                </div>
            </div>
        `;

        document.getElementById('mainStats').style.display = 'none';
        document.getElementById('detailStats').innerHTML = html;
    }
/*
 ==================================================================================
 [Patch Note: v9.1 Fixed - Celt Logic & UI Sync]
 ==================================================================================

 1. [UI] ì‚¬ìš©ì ì•ˆë‚´ ë¬¸êµ¬ ìˆ˜ì • (HTML)
    - ëŒ€ìƒ: ì¼ˆíŠ¸ ë³€í™˜(Convert) ë° ë©´ì œ(Free) ë ˆë²¨ ì…ë ¥ í•„ë“œ
    - ë³€ê²½: "ì‰¼í‘œ êµ¬ë¶„(ì˜ˆ: 2,3)" â†’ "ìµœì†Œ ë ˆë²¨(ì˜ˆ: 2)" ë¡œ Placeholder ë° ê°€ì´ë“œ í…ìŠ¤íŠ¸ ë³€ê²½.
    - ì´ìœ : ì‚¬ìš©ìê°€ ë‹¨ì¼ ìˆ«ìë¥¼ ì…ë ¥í•˜ë„ë¡ ìœ ë„í•˜ì—¬ ì„¤ì • í˜¼ë€ ë°©ì§€.

 2. [Config] ì„¤ì • ì ìš© ë¡œì§ ë³€ê²½ (applyUserBalance)
    - ëŒ€ìƒ: BALANCE_CONFIG.CELT.LVL_CONVERT, LVL_FREE
    - ë³€ê²½: ë°°ì—´ ì „ì²´ ì €ì¥ ë°©ì‹ â†’ ì²« ë²ˆì§¸ ì…ë ¥ê°’(index 0)ì„ Threshold(ì •ìˆ˜)ë¡œ ì €ì¥.
    - ì½”ë“œ: const convertArr = ...; BALANCE_CONFIG.CELT.LVL_CONVERT = convertArr[0];

 3. [Core] í•µì‹¬ ì—”ì§„ ë¡œì§ ë³€ê²½ (Threshold ì ìš©)
    - ëŒ€ìƒ: 
      a) Game.prototype.aiCalculateTargetValue (ê°€ì¹˜ íŒë‹¨)
      b) Game.prototype.processCraftTransaction (ì œì‘ ì‹¤í–‰)
      c) Game.prototype.aiActionGather (ìì› ìˆ˜ì§‘)
    - ë³€ê²½: .includes(count) â†’ (count >= CONFIG_VAL)
    - íš¨ê³¼: ì¼ˆíŠ¸ ìœ ë¬¼ì´ ì„¤ì •ëœ ë ˆë²¨(ì˜ˆ: 3)ì„ ì´ˆê³¼í•˜ì—¬ 4ê°œ, 5ê°œê°€ ë˜ì–´ë„
           ë³€í™˜ ë° ë©´ì œ ëŠ¥ë ¥ì´ ë¹„í™œì„±í™”ë˜ì§€ ì•Šê³  ì§€ì†ì ìœ¼ë¡œ ìœ ì§€ë¨.
           ('ë©´ì œ'ê°€ 'ë³€í™˜'ë³´ë‹¤ ìƒìœ„ ê°œë…ì´ë¯€ë¡œ ìš°ì„ ìˆœìœ„ ë¡œì§ì— ë”°ë¼ ì¶©ëŒ ì—†ìŒ)

 ì‘ì„±ì: Divine Forge Main Developer
 ==================================================================================
*/
const simManager = new SimulationManager();
</script>
</body>
</html>
